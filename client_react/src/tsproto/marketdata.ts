// @generated by protobuf-ts 2.8.2 with parameter long_type_string
// @generated from protobuf file "marketdata.proto" (package "tinkoff.public.invest.api.contract.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { SecurityTradingStatus } from "./common";
import { Timestamp } from "./google/protobuf/timestamp";
import { Quotation } from "./common";
import { Ping } from "./common";
/**
 * Запрос подписки или отписки на определённые биржевые данные.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.MarketDataRequest
 */
export interface MarketDataRequest {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "subscribeCandlesRequest";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SubscribeCandlesRequest subscribe_candles_request = 1;
         */
        subscribeCandlesRequest: SubscribeCandlesRequest; // Запрос подписки на свечи.
    } | {
        oneofKind: "subscribeOrderBookRequest";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SubscribeOrderBookRequest subscribe_order_book_request = 2;
         */
        subscribeOrderBookRequest: SubscribeOrderBookRequest; // Запрос подписки на стаканы.
    } | {
        oneofKind: "subscribeTradesRequest";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SubscribeTradesRequest subscribe_trades_request = 3;
         */
        subscribeTradesRequest: SubscribeTradesRequest; // Запрос подписки на ленту обезличенных сделок.
    } | {
        oneofKind: "subscribeInfoRequest";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SubscribeInfoRequest subscribe_info_request = 4;
         */
        subscribeInfoRequest: SubscribeInfoRequest; // Запрос подписки на торговые статусы инструментов.
    } | {
        oneofKind: "subscribeLastPriceRequest";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SubscribeLastPriceRequest subscribe_last_price_request = 5;
         */
        subscribeLastPriceRequest: SubscribeLastPriceRequest; // Запрос подписки на цены последних сделок.
    } | {
        oneofKind: "getMySubscriptions";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.GetMySubscriptions get_my_subscriptions = 6;
         */
        getMySubscriptions: GetMySubscriptions; // Запрос своих подписок.
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.MarketDataServerSideStreamRequest
 */
export interface MarketDataServerSideStreamRequest {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SubscribeCandlesRequest subscribe_candles_request = 1;
     */
    subscribeCandlesRequest?: SubscribeCandlesRequest; // Запрос подписки на свечи.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SubscribeOrderBookRequest subscribe_order_book_request = 2;
     */
    subscribeOrderBookRequest?: SubscribeOrderBookRequest; // Запрос подписки на стаканы.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SubscribeTradesRequest subscribe_trades_request = 3;
     */
    subscribeTradesRequest?: SubscribeTradesRequest; // Запрос подписки на ленту обезличенных сделок.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SubscribeInfoRequest subscribe_info_request = 4;
     */
    subscribeInfoRequest?: SubscribeInfoRequest; // Запрос подписки на торговые статусы инструментов.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SubscribeLastPriceRequest subscribe_last_price_request = 5;
     */
    subscribeLastPriceRequest?: SubscribeLastPriceRequest; // Запрос подписки на цены последних сделок.
}
/**
 * Пакет биржевой информации по подписке.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.MarketDataResponse
 */
export interface MarketDataResponse {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "subscribeCandlesResponse";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SubscribeCandlesResponse subscribe_candles_response = 1;
         */
        subscribeCandlesResponse: SubscribeCandlesResponse; // Результат подписки на свечи.
    } | {
        oneofKind: "subscribeOrderBookResponse";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SubscribeOrderBookResponse subscribe_order_book_response = 2;
         */
        subscribeOrderBookResponse: SubscribeOrderBookResponse; // Результат подписки на стаканы.
    } | {
        oneofKind: "subscribeTradesResponse";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SubscribeTradesResponse subscribe_trades_response = 3;
         */
        subscribeTradesResponse: SubscribeTradesResponse; // Результат подписки на поток обезличенных сделок.
    } | {
        oneofKind: "subscribeInfoResponse";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SubscribeInfoResponse subscribe_info_response = 4;
         */
        subscribeInfoResponse: SubscribeInfoResponse; // Результат подписки на торговые статусы инструментов.
    } | {
        oneofKind: "candle";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Candle candle = 5;
         */
        candle: Candle; // Свеча.
    } | {
        oneofKind: "trade";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Trade trade = 6;
         */
        trade: Trade; // Сделки.
    } | {
        oneofKind: "orderbook";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.OrderBook orderbook = 7;
         */
        orderbook: OrderBook; // Стакан.
    } | {
        oneofKind: "tradingStatus";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.TradingStatus trading_status = 8;
         */
        tradingStatus: TradingStatus; // Торговый статус.
    } | {
        oneofKind: "ping";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Ping ping = 9;
         */
        ping: Ping; // Проверка активности стрима.
    } | {
        oneofKind: "subscribeLastPriceResponse";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SubscribeLastPriceResponse subscribe_last_price_response = 10;
         */
        subscribeLastPriceResponse: SubscribeLastPriceResponse; // Результат подписки на цены последние сделок по инструментам.
    } | {
        oneofKind: "lastPrice";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.LastPrice last_price = 11;
         */
        lastPrice: LastPrice; // Цена последней сделки.
    } | {
        oneofKind: undefined;
    };
}
/**
 * subscribeCandles | Изменения статуса подписки на свечи.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.SubscribeCandlesRequest
 */
export interface SubscribeCandlesRequest {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SubscriptionAction subscription_action = 1;
     */
    subscriptionAction: SubscriptionAction; // Изменение статуса подписки.
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.CandleInstrument instruments = 2;
     */
    instruments: CandleInstrument[]; // Массив инструментов для подписки на свечи.
    /**
     * @generated from protobuf field: bool waiting_close = 3;
     */
    waitingClose: boolean; // Флаг ожидания закрытия временного интервала для отправки свечи, применяется только для минутных свечей.
}
/**
 * Запрос изменения статус подписки на свечи.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.CandleInstrument
 */
export interface CandleInstrument {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Deprecated Figi-идентификатор инструмента. Необходимо использовать instrument_id.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SubscriptionInterval interval = 2;
     */
    interval: SubscriptionInterval; // Интервал свечей.
    /**
     * @generated from protobuf field: string instrument_id = 3;
     */
    instrumentId: string; // Идентификатор инструмента, принимает значение figi или instrument_uid
}
/**
 * Результат изменения статус подписки на свечи.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.SubscribeCandlesResponse
 */
export interface SubscribeCandlesResponse {
    /**
     * @generated from protobuf field: string tracking_id = 1;
     */
    trackingId: string; // Уникальный идентификатор запроса, подробнее: [tracking_id](https://tinkoff.github.io/investAPI/grpc#tracking-id).
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.CandleSubscription candles_subscriptions = 2;
     */
    candlesSubscriptions: CandleSubscription[]; // Массив статусов подписки на свечи.
}
/**
 * Статус подписки на свечи.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.CandleSubscription
 */
export interface CandleSubscription {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SubscriptionInterval interval = 2;
     */
    interval: SubscriptionInterval; // Интервал свечей.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SubscriptionStatus subscription_status = 3;
     */
    subscriptionStatus: SubscriptionStatus; // Статус подписки.
    /**
     * @generated from protobuf field: string instrument_uid = 4;
     */
    instrumentUid: string; // Uid инструмента
}
/**
 * Запрос на изменение статуса подписки на стаканы.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.SubscribeOrderBookRequest
 */
export interface SubscribeOrderBookRequest {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SubscriptionAction subscription_action = 1;
     */
    subscriptionAction: SubscriptionAction; // Изменение статуса подписки.
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.OrderBookInstrument instruments = 2;
     */
    instruments: OrderBookInstrument[]; // Массив инструментов для подписки на стаканы.
}
/**
 * Запрос подписки на стаканы.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.OrderBookInstrument
 */
export interface OrderBookInstrument {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Deprecated Figi-идентификатор инструмента. Необходимо использовать instrument_id.
    /**
     * @generated from protobuf field: int32 depth = 2;
     */
    depth: number; // Глубина стакана.
    /**
     * @generated from protobuf field: string instrument_id = 3;
     */
    instrumentId: string; // Идентификатор инструмента, принимает значение figi или instrument_uid
}
/**
 * Результат изменения статуса подписки на стаканы.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.SubscribeOrderBookResponse
 */
export interface SubscribeOrderBookResponse {
    /**
     * @generated from protobuf field: string tracking_id = 1;
     */
    trackingId: string; // Уникальный идентификатор запроса, подробнее: [tracking_id](https://tinkoff.github.io/investAPI/grpc#tracking-id).
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.OrderBookSubscription order_book_subscriptions = 2;
     */
    orderBookSubscriptions: OrderBookSubscription[]; // Массив статусов подписки на стаканы.
}
/**
 * Статус подписки.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.OrderBookSubscription
 */
export interface OrderBookSubscription {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: int32 depth = 2;
     */
    depth: number; // Глубина стакана.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SubscriptionStatus subscription_status = 3;
     */
    subscriptionStatus: SubscriptionStatus; // Статус подписки.
    /**
     * @generated from protobuf field: string instrument_uid = 4;
     */
    instrumentUid: string; // Uid инструмента
}
/**
 * Изменение статуса подписки на поток обезличенных сделок.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.SubscribeTradesRequest
 */
export interface SubscribeTradesRequest {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SubscriptionAction subscription_action = 1;
     */
    subscriptionAction: SubscriptionAction; // Изменение статуса подписки.
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.TradeInstrument instruments = 2;
     */
    instruments: TradeInstrument[]; // Массив инструментов для подписки на поток обезличенных сделок.
}
/**
 * Запрос подписки на поток обезличенных сделок.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.TradeInstrument
 */
export interface TradeInstrument {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Deprecated Figi-идентификатор инструмента. Необходимо использовать instrument_id.
    /**
     * @generated from protobuf field: string instrument_id = 2;
     */
    instrumentId: string; // Идентификатор инструмента, принимает значение figi или instrument_uid
}
/**
 * Результат изменения статуса подписки на поток обезличенных сделок.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.SubscribeTradesResponse
 */
export interface SubscribeTradesResponse {
    /**
     * @generated from protobuf field: string tracking_id = 1;
     */
    trackingId: string; // Уникальный идентификатор запроса, подробнее: [tracking_id](https://tinkoff.github.io/investAPI/grpc#tracking-id).
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.TradeSubscription trade_subscriptions = 2;
     */
    tradeSubscriptions: TradeSubscription[]; // Массив статусов подписки на поток сделок.
}
/**
 * Статус подписки.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.TradeSubscription
 */
export interface TradeSubscription {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SubscriptionStatus subscription_status = 2;
     */
    subscriptionStatus: SubscriptionStatus; // Статус подписки.
    /**
     * @generated from protobuf field: string instrument_uid = 3;
     */
    instrumentUid: string; // Uid инструмента
}
/**
 * Изменение статуса подписки на торговый статус инструмента.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.SubscribeInfoRequest
 */
export interface SubscribeInfoRequest {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SubscriptionAction subscription_action = 1;
     */
    subscriptionAction: SubscriptionAction; // Изменение статуса подписки.
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.InfoInstrument instruments = 2;
     */
    instruments: InfoInstrument[]; // Массив инструментов для подписки на торговый статус.
}
/**
 * Запрос подписки на торговый статус.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.InfoInstrument
 */
export interface InfoInstrument {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Deprecated Figi-идентификатор инструмента. Необходимо использовать instrument_id.
    /**
     * @generated from protobuf field: string instrument_id = 2;
     */
    instrumentId: string; // Идентификатор инструмента, принимает значение figi или instrument_uid
}
/**
 * Результат изменения статуса подписки на торговый статус.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.SubscribeInfoResponse
 */
export interface SubscribeInfoResponse {
    /**
     * @generated from protobuf field: string tracking_id = 1;
     */
    trackingId: string; // Уникальный идентификатор запроса, подробнее: [tracking_id](https://tinkoff.github.io/investAPI/grpc#tracking-id).
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.InfoSubscription info_subscriptions = 2;
     */
    infoSubscriptions: InfoSubscription[]; // Массив статусов подписки на торговый статус.
}
/**
 * Статус подписки.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.InfoSubscription
 */
export interface InfoSubscription {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SubscriptionStatus subscription_status = 2;
     */
    subscriptionStatus: SubscriptionStatus; // Статус подписки.
    /**
     * @generated from protobuf field: string instrument_uid = 3;
     */
    instrumentUid: string; // Uid инструмента
}
/**
 * Изменение статуса подписки на цену последней сделки по инструменту.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.SubscribeLastPriceRequest
 */
export interface SubscribeLastPriceRequest {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SubscriptionAction subscription_action = 1;
     */
    subscriptionAction: SubscriptionAction; // Изменение статуса подписки.
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.LastPriceInstrument instruments = 2;
     */
    instruments: LastPriceInstrument[]; // Массив инструментов для подписки на цену последней сделки.
}
/**
 * Запрос подписки на последнюю цену.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.LastPriceInstrument
 */
export interface LastPriceInstrument {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Deprecated Figi-идентификатор инструмента. Необходимо использовать instrument_id.
    /**
     * @generated from protobuf field: string instrument_id = 2;
     */
    instrumentId: string; // Идентификатор инструмента, принимает значение figi или instrument_uid
}
/**
 * Результат изменения статуса подписки на цену последней сделки.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.SubscribeLastPriceResponse
 */
export interface SubscribeLastPriceResponse {
    /**
     * @generated from protobuf field: string tracking_id = 1;
     */
    trackingId: string; // Уникальный идентификатор запроса, подробнее: [tracking_id](https://tinkoff.github.io/investAPI/grpc#tracking-id).
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.LastPriceSubscription last_price_subscriptions = 2;
     */
    lastPriceSubscriptions: LastPriceSubscription[]; // Массив статусов подписки на цену последней сделки.
}
/**
 * Статус подписки на цену последней сделки.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.LastPriceSubscription
 */
export interface LastPriceSubscription {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SubscriptionStatus subscription_status = 2;
     */
    subscriptionStatus: SubscriptionStatus; // Статус подписки.
    /**
     * @generated from protobuf field: string instrument_uid = 3;
     */
    instrumentUid: string; // Uid инструмента
}
/**
 * Пакет свечей в рамках стрима.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.Candle
 */
export interface Candle {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SubscriptionInterval interval = 2;
     */
    interval: SubscriptionInterval; // Интервал свечи.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation open = 3;
     */
    open?: Quotation; // Цена открытия за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation high = 4;
     */
    high?: Quotation; // Максимальная цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation low = 5;
     */
    low?: Quotation; // Минимальная цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation close = 6;
     */
    close?: Quotation; // Цена закрытия за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
    /**
     * @generated from protobuf field: int64 volume = 7;
     */
    volume: string; // Объём сделок в лотах.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp time = 8;
     */
    time?: Timestamp; // Время начала интервала свечи в часовом поясе UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp last_trade_ts = 9;
     */
    lastTradeTs?: Timestamp; // Время последней сделки, вошедшей в свечу в часовом поясе UTC.
    /**
     * @generated from protobuf field: string instrument_uid = 10;
     */
    instrumentUid: string; // Uid инструмента
}
/**
 * Пакет стаканов в рамках стрима.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.OrderBook
 */
export interface OrderBook {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: int32 depth = 2;
     */
    depth: number; // Глубина стакана.
    /**
     * @generated from protobuf field: bool is_consistent = 3;
     */
    isConsistent: boolean; // Флаг консистентности стакана. **false** значит не все заявки попали в стакан по причинам сетевых задержек или нарушения порядка доставки.
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.Order bids = 4;
     */
    bids: Order[]; // Массив предложений.
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.Order asks = 5;
     */
    asks: Order[]; // Массив спроса.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp time = 6;
     */
    time?: Timestamp; // Время формирования стакана в часовом поясе UTC по времени биржи.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation limit_up = 7;
     */
    limitUp?: Quotation; // Верхний лимит цены за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation limit_down = 8;
     */
    limitDown?: Quotation; // Нижний лимит цены за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
    /**
     * @generated from protobuf field: string instrument_uid = 9;
     */
    instrumentUid: string; // Uid инструмента
}
/**
 * Массив предложений/спроса.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.Order
 */
export interface Order {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation price = 1;
     */
    price?: Quotation; // Цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
    /**
     * @generated from protobuf field: int64 quantity = 2;
     */
    quantity: string; // Количество в лотах.
}
/**
 * Информация о сделке.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.Trade
 */
export interface Trade {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.TradeDirection direction = 2;
     */
    direction: TradeDirection; // Направление сделки.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation price = 3;
     */
    price?: Quotation; // Цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
    /**
     * @generated from protobuf field: int64 quantity = 4;
     */
    quantity: string; // Количество лотов.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp time = 5;
     */
    time?: Timestamp; // Время сделки в часовом поясе UTC по времени биржи.
    /**
     * @generated from protobuf field: string instrument_uid = 6;
     */
    instrumentUid: string; // Uid инструмента
}
/**
 * Пакет изменения торгового статуса.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.TradingStatus
 */
export interface TradingStatus {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status = 2;
     */
    tradingStatus: SecurityTradingStatus; // Статус торговли инструментом.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp time = 3;
     */
    time?: Timestamp; // Время изменения торгового статуса в часовом поясе UTC.
    /**
     * @generated from protobuf field: bool limit_order_available_flag = 4;
     */
    limitOrderAvailableFlag: boolean; // Признак доступности выставления лимитной заявки по инструменту.
    /**
     * @generated from protobuf field: bool market_order_available_flag = 5;
     */
    marketOrderAvailableFlag: boolean; // Признак доступности выставления рыночной заявки по инструменту.
    /**
     * @generated from protobuf field: string instrument_uid = 6;
     */
    instrumentUid: string; // Uid инструмента
}
/**
 * Запрос исторических свечей.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetCandlesRequest
 */
export interface GetCandlesRequest {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Deprecated Figi-идентификатор инструмента. Необходимо использовать instrument_id.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp from = 2;
     */
    from?: Timestamp; // Начало запрашиваемого периода в часовом поясе UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp to = 3;
     */
    to?: Timestamp; // Окончание запрашиваемого периода в часовом поясе UTC.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.CandleInterval interval = 4;
     */
    interval: CandleInterval; // Интервал запрошенных свечей.
    /**
     * @generated from protobuf field: string instrument_id = 5;
     */
    instrumentId: string; // Идентификатор инструмента, принимает значение figi или instrument_uid.
}
/**
 * Список свечей.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetCandlesResponse
 */
export interface GetCandlesResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.HistoricCandle candles = 1;
     */
    candles: HistoricCandle[]; // Массив свечей.
}
/**
 * Информация о свече.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.HistoricCandle
 */
export interface HistoricCandle {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation open = 1;
     */
    open?: Quotation; // Цена открытия за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation high = 2;
     */
    high?: Quotation; // Максимальная цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation low = 3;
     */
    low?: Quotation; // Минимальная цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation close = 4;
     */
    close?: Quotation; // Цена закрытия за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
    /**
     * @generated from protobuf field: int64 volume = 5;
     */
    volume: string; // Объём торгов в лотах.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp time = 6;
     */
    time?: Timestamp; // Время свечи в часовом поясе UTC.
    /**
     * @generated from protobuf field: bool is_complete = 7;
     */
    isComplete: boolean; // Признак завершённости свечи. **false** значит, свеча за текущие интервал ещё сформирована не полностью.
}
/**
 * Запрос получения цен последних сделок.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetLastPricesRequest
 */
export interface GetLastPricesRequest {
    /**
     * @generated from protobuf field: repeated string figi = 1;
     */
    figi: string[]; // Deprecated Figi-идентификатор инструмента. Необходимо использовать instrument_id.
    /**
     * @generated from protobuf field: repeated string instrument_id = 2;
     */
    instrumentId: string[]; // Массив идентификаторов инструмента, принимает значения figi или instrument_uid.
}
/**
 * Список цен последних сделок.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetLastPricesResponse
 */
export interface GetLastPricesResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.LastPrice last_prices = 1;
     */
    lastPrices: LastPrice[]; // Массив цен последних сделок.
}
/**
 * Информация о цене последней сделки.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.LastPrice
 */
export interface LastPrice {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi инструмента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation price = 2;
     */
    price?: Quotation; // Цена последней сделки за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
    /**
     * @generated from protobuf field: google.protobuf.Timestamp time = 3;
     */
    time?: Timestamp; // Время получения последней цены в часовом поясе UTC по времени биржи.
    /**
     * @generated from protobuf field: string instrument_uid = 11;
     */
    instrumentUid: string; // Uid инструмента
}
/**
 * Запрос стакана.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetOrderBookRequest
 */
export interface GetOrderBookRequest {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Deprecated Figi-идентификатор инструмента. Необходимо использовать instrument_id.
    /**
     * @generated from protobuf field: int32 depth = 2;
     */
    depth: number; // Глубина стакана.
    /**
     * @generated from protobuf field: string instrument_id = 3;
     */
    instrumentId: string; // Идентификатор инструмента, принимает значение figi или instrument_uid.
}
/**
 * Информация о стакане.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetOrderBookResponse
 */
export interface GetOrderBookResponse {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: int32 depth = 2;
     */
    depth: number; // Глубина стакана.
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.Order bids = 3;
     */
    bids: Order[]; // Множество пар значений на покупку.
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.Order asks = 4;
     */
    asks: Order[]; // Множество пар значений на продажу.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation last_price = 5;
     */
    lastPrice?: Quotation; // Цена последней сделки за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation close_price = 6;
     */
    closePrice?: Quotation; // Цена закрытия за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation limit_up = 7;
     */
    limitUp?: Quotation; // Верхний лимит цены за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation limit_down = 8;
     */
    limitDown?: Quotation; // Нижний лимит цены за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Для перевод цен в валюту рекомендуем использовать [информацию со страницы](https://tinkoff.github.io/investAPI/faq_marketdata/)
    /**
     * @generated from protobuf field: google.protobuf.Timestamp last_price_ts = 21;
     */
    lastPriceTs?: Timestamp; // Время получения цены последней сделки.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp close_price_ts = 22;
     */
    closePriceTs?: Timestamp; // Время получения цены закрытия.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp orderbook_ts = 23;
     */
    orderbookTs?: Timestamp; // Время формирования стакана на бирже.
    /**
     * @generated from protobuf field: string instrument_uid = 9;
     */
    instrumentUid: string; // Uid инструмента.
}
/**
 * Запрос получения торгового статуса.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetTradingStatusRequest
 */
export interface GetTradingStatusRequest {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Deprecated Figi-идентификатор инструмента. Необходимо использовать instrument_id.
    /**
     * @generated from protobuf field: string instrument_id = 2;
     */
    instrumentId: string; // Идентификатор инструмента, принимает значение figi или instrument_uid.
}
/**
 * Запрос получения торгового статуса.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetTradingStatusesRequest
 */
export interface GetTradingStatusesRequest {
    /**
     * @generated from protobuf field: repeated string instrument_id = 1;
     */
    instrumentId: string[]; // Идентификатор инструмента, принимает значение figi или instrument_uid
}
/**
 * Информация о торговом статусе.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetTradingStatusesResponse
 */
export interface GetTradingStatusesResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.GetTradingStatusResponse trading_statuses = 1;
     */
    tradingStatuses: GetTradingStatusResponse[]; // Массив информации о торговых статусах
}
/**
 * Информация о торговом статусе.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetTradingStatusResponse
 */
export interface GetTradingStatusResponse {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status = 2;
     */
    tradingStatus: SecurityTradingStatus; // Статус торговли инструментом.
    /**
     * @generated from protobuf field: bool limit_order_available_flag = 3;
     */
    limitOrderAvailableFlag: boolean; // Признак доступности выставления лимитной заявки по инструменту.
    /**
     * @generated from protobuf field: bool market_order_available_flag = 4;
     */
    marketOrderAvailableFlag: boolean; // Признак доступности выставления рыночной заявки по инструменту.
    /**
     * @generated from protobuf field: bool api_trade_available_flag = 5;
     */
    apiTradeAvailableFlag: boolean; // Признак доступности торгов через API.
    /**
     * @generated from protobuf field: string instrument_uid = 6;
     */
    instrumentUid: string; // Uid инструмента.
}
/**
 * Запрос обезличенных сделок за последний час.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetLastTradesRequest
 */
export interface GetLastTradesRequest {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Deprecated Figi-идентификатор инструмента. Необходимо использовать instrument_id.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp from = 2;
     */
    from?: Timestamp; // Начало запрашиваемого периода в часовом поясе UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp to = 3;
     */
    to?: Timestamp; // Окончание запрашиваемого периода в часовом поясе UTC.
    /**
     * @generated from protobuf field: string instrument_id = 4;
     */
    instrumentId: string; // Идентификатор инструмента, принимает значение figi или instrument_uid.
}
/**
 * Обезличенных сделок за последний час.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetLastTradesResponse
 */
export interface GetLastTradesResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.Trade trades = 1;
     */
    trades: Trade[]; // Массив сделок.
}
/**
 * Запрос активных подписок.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetMySubscriptions
 */
export interface GetMySubscriptions {
}
/**
 * Запрос цен закрытия торговой сессии по инструментам.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetClosePricesRequest
 */
export interface GetClosePricesRequest {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.InstrumentClosePriceRequest instruments = 1;
     */
    instruments: InstrumentClosePriceRequest[]; // Массив по инструментам.
}
/**
 * Запрос цен закрытия торговой сессии по инструменту.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.InstrumentClosePriceRequest
 */
export interface InstrumentClosePriceRequest {
    /**
     * @generated from protobuf field: string instrument_id = 1;
     */
    instrumentId: string; // Идентификатор инструмента, принимает значение figi или instrument_uid.
}
/**
 * Цены закрытия торговой сессии по инструментам.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetClosePricesResponse
 */
export interface GetClosePricesResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.InstrumentClosePriceResponse close_prices = 1;
     */
    closePrices: InstrumentClosePriceResponse[]; // Массив по инструментам.
}
/**
 * Цена закрытия торговой сессии по инструменту.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.InstrumentClosePriceResponse
 */
export interface InstrumentClosePriceResponse {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi инструмента.
    /**
     * @generated from protobuf field: string instrument_uid = 2;
     */
    instrumentUid: string; // Uid инструмента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation price = 11;
     */
    price?: Quotation; // Цена закрытия торговой сессии.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp time = 21;
     */
    time?: Timestamp; // Дата совершения торгов.
}
/**
 * Тип операции со списком подписок.
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.SubscriptionAction
 */
export enum SubscriptionAction {
    /**
     * Статус подписки не определён.
     *
     * @generated from protobuf enum value: SUBSCRIPTION_ACTION_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Подписаться.
     *
     * @generated from protobuf enum value: SUBSCRIPTION_ACTION_SUBSCRIBE = 1;
     */
    SUBSCRIBE = 1,
    /**
     * Отписаться.
     *
     * @generated from protobuf enum value: SUBSCRIPTION_ACTION_UNSUBSCRIBE = 2;
     */
    UNSUBSCRIBE = 2
}
/**
 * Интервал свечи.
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.SubscriptionInterval
 */
export enum SubscriptionInterval {
    /**
     * Интервал свечи не определён.
     *
     * @generated from protobuf enum value: SUBSCRIPTION_INTERVAL_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Минутные свечи.
     *
     * @generated from protobuf enum value: SUBSCRIPTION_INTERVAL_ONE_MINUTE = 1;
     */
    ONE_MINUTE = 1,
    /**
     * Пятиминутные свечи.
     *
     * @generated from protobuf enum value: SUBSCRIPTION_INTERVAL_FIVE_MINUTES = 2;
     */
    FIVE_MINUTES = 2
}
/**
 * Результат подписки.
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.SubscriptionStatus
 */
export enum SubscriptionStatus {
    /**
     * Статус подписки не определён.
     *
     * @generated from protobuf enum value: SUBSCRIPTION_STATUS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Успешно.
     *
     * @generated from protobuf enum value: SUBSCRIPTION_STATUS_SUCCESS = 1;
     */
    SUCCESS = 1,
    /**
     * Инструмент не найден.
     *
     * @generated from protobuf enum value: SUBSCRIPTION_STATUS_INSTRUMENT_NOT_FOUND = 2;
     */
    INSTRUMENT_NOT_FOUND = 2,
    /**
     * Некорректный статус подписки, список возможных значений: [SubscriptionAction](https://tinkoff.github.io/investAPI/marketdata#subscriptionaction).
     *
     * @generated from protobuf enum value: SUBSCRIPTION_STATUS_SUBSCRIPTION_ACTION_IS_INVALID = 3;
     */
    SUBSCRIPTION_ACTION_IS_INVALID = 3,
    /**
     * Некорректная глубина стакана, доступные значения: 1, 10, 20, 30, 40, 50.
     *
     * @generated from protobuf enum value: SUBSCRIPTION_STATUS_DEPTH_IS_INVALID = 4;
     */
    DEPTH_IS_INVALID = 4,
    /**
     * Некорректный интервал свечей, список возможных значений: [SubscriptionInterval](https://tinkoff.github.io/investAPI/marketdata#subscriptioninterval).
     *
     * @generated from protobuf enum value: SUBSCRIPTION_STATUS_INTERVAL_IS_INVALID = 5;
     */
    INTERVAL_IS_INVALID = 5,
    /**
     * Превышен лимит на общее количество подписок в рамках стрима, подробнее: [Лимитная политика](https://tinkoff.github.io/investAPI/limits/).
     *
     * @generated from protobuf enum value: SUBSCRIPTION_STATUS_LIMIT_IS_EXCEEDED = 6;
     */
    LIMIT_IS_EXCEEDED = 6,
    /**
     * Внутренняя ошибка сервиса.
     *
     * @generated from protobuf enum value: SUBSCRIPTION_STATUS_INTERNAL_ERROR = 7;
     */
    INTERNAL_ERROR = 7,
    /**
     * Превышен лимит на количество запросов на подписки в течение установленного отрезка времени
     *
     * @generated from protobuf enum value: SUBSCRIPTION_STATUS_TOO_MANY_REQUESTS = 8;
     */
    TOO_MANY_REQUESTS = 8
}
/**
 * Направление сделки.
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.TradeDirection
 */
export enum TradeDirection {
    /**
     * Направление сделки не определено.
     *
     * @generated from protobuf enum value: TRADE_DIRECTION_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Покупка.
     *
     * @generated from protobuf enum value: TRADE_DIRECTION_BUY = 1;
     */
    BUY = 1,
    /**
     * Продажа.
     *
     * @generated from protobuf enum value: TRADE_DIRECTION_SELL = 2;
     */
    SELL = 2
}
/**
 * Интервал свечей.
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.CandleInterval
 */
export enum CandleInterval {
    /**
     * Интервал не определён.
     *
     * @generated from protobuf enum value: CANDLE_INTERVAL_UNSPECIFIED = 0;
     */
    CANDLE_INTERVAL_UNSPECIFIED = 0,
    /**
     * 1 минута.
     *
     * @generated from protobuf enum value: CANDLE_INTERVAL_1_MIN = 1;
     */
    CANDLE_INTERVAL_1_MIN = 1,
    /**
     * 5 минут.
     *
     * @generated from protobuf enum value: CANDLE_INTERVAL_5_MIN = 2;
     */
    CANDLE_INTERVAL_5_MIN = 2,
    /**
     * 15 минут.
     *
     * @generated from protobuf enum value: CANDLE_INTERVAL_15_MIN = 3;
     */
    CANDLE_INTERVAL_15_MIN = 3,
    /**
     * 1 час.
     *
     * @generated from protobuf enum value: CANDLE_INTERVAL_HOUR = 4;
     */
    CANDLE_INTERVAL_HOUR = 4,
    /**
     * 1 день.
     *
     * @generated from protobuf enum value: CANDLE_INTERVAL_DAY = 5;
     */
    CANDLE_INTERVAL_DAY = 5,
    /**
     * 2 минуты.
     *
     * @generated from protobuf enum value: CANDLE_INTERVAL_2_MIN = 6;
     */
    CANDLE_INTERVAL_2_MIN = 6,
    /**
     * 3 минуты.
     *
     * @generated from protobuf enum value: CANDLE_INTERVAL_3_MIN = 7;
     */
    CANDLE_INTERVAL_3_MIN = 7,
    /**
     * 10 минут.
     *
     * @generated from protobuf enum value: CANDLE_INTERVAL_10_MIN = 8;
     */
    CANDLE_INTERVAL_10_MIN = 8,
    /**
     * 30 минут.
     *
     * @generated from protobuf enum value: CANDLE_INTERVAL_30_MIN = 9;
     */
    CANDLE_INTERVAL_30_MIN = 9,
    /**
     * 2 часа.
     *
     * @generated from protobuf enum value: CANDLE_INTERVAL_2_HOUR = 10;
     */
    CANDLE_INTERVAL_2_HOUR = 10,
    /**
     * 4 часа.
     *
     * @generated from protobuf enum value: CANDLE_INTERVAL_4_HOUR = 11;
     */
    CANDLE_INTERVAL_4_HOUR = 11,
    /**
     * 1 неделя.
     *
     * @generated from protobuf enum value: CANDLE_INTERVAL_WEEK = 12;
     */
    CANDLE_INTERVAL_WEEK = 12,
    /**
     * 1 месяц.
     *
     * @generated from protobuf enum value: CANDLE_INTERVAL_MONTH = 13;
     */
    CANDLE_INTERVAL_MONTH = 13
}
// @generated message type with reflection information, may provide speed optimized methods
class MarketDataRequest$Type extends MessageType<MarketDataRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.MarketDataRequest", [
            { no: 1, name: "subscribe_candles_request", kind: "message", oneof: "payload", T: () => SubscribeCandlesRequest },
            { no: 2, name: "subscribe_order_book_request", kind: "message", oneof: "payload", T: () => SubscribeOrderBookRequest },
            { no: 3, name: "subscribe_trades_request", kind: "message", oneof: "payload", T: () => SubscribeTradesRequest },
            { no: 4, name: "subscribe_info_request", kind: "message", oneof: "payload", T: () => SubscribeInfoRequest },
            { no: 5, name: "subscribe_last_price_request", kind: "message", oneof: "payload", T: () => SubscribeLastPriceRequest },
            { no: 6, name: "get_my_subscriptions", kind: "message", oneof: "payload", T: () => GetMySubscriptions }
        ]);
    }
    create(value?: PartialMessage<MarketDataRequest>): MarketDataRequest {
        const message = { payload: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MarketDataRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketDataRequest): MarketDataRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.SubscribeCandlesRequest subscribe_candles_request */ 1:
                    message.payload = {
                        oneofKind: "subscribeCandlesRequest",
                        subscribeCandlesRequest: SubscribeCandlesRequest.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).subscribeCandlesRequest)
                    };
                    break;
                case /* tinkoff.public.invest.api.contract.v1.SubscribeOrderBookRequest subscribe_order_book_request */ 2:
                    message.payload = {
                        oneofKind: "subscribeOrderBookRequest",
                        subscribeOrderBookRequest: SubscribeOrderBookRequest.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).subscribeOrderBookRequest)
                    };
                    break;
                case /* tinkoff.public.invest.api.contract.v1.SubscribeTradesRequest subscribe_trades_request */ 3:
                    message.payload = {
                        oneofKind: "subscribeTradesRequest",
                        subscribeTradesRequest: SubscribeTradesRequest.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).subscribeTradesRequest)
                    };
                    break;
                case /* tinkoff.public.invest.api.contract.v1.SubscribeInfoRequest subscribe_info_request */ 4:
                    message.payload = {
                        oneofKind: "subscribeInfoRequest",
                        subscribeInfoRequest: SubscribeInfoRequest.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).subscribeInfoRequest)
                    };
                    break;
                case /* tinkoff.public.invest.api.contract.v1.SubscribeLastPriceRequest subscribe_last_price_request */ 5:
                    message.payload = {
                        oneofKind: "subscribeLastPriceRequest",
                        subscribeLastPriceRequest: SubscribeLastPriceRequest.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).subscribeLastPriceRequest)
                    };
                    break;
                case /* tinkoff.public.invest.api.contract.v1.GetMySubscriptions get_my_subscriptions */ 6:
                    message.payload = {
                        oneofKind: "getMySubscriptions",
                        getMySubscriptions: GetMySubscriptions.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).getMySubscriptions)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketDataRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.SubscribeCandlesRequest subscribe_candles_request = 1; */
        if (message.payload.oneofKind === "subscribeCandlesRequest")
            SubscribeCandlesRequest.internalBinaryWrite(message.payload.subscribeCandlesRequest, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.SubscribeOrderBookRequest subscribe_order_book_request = 2; */
        if (message.payload.oneofKind === "subscribeOrderBookRequest")
            SubscribeOrderBookRequest.internalBinaryWrite(message.payload.subscribeOrderBookRequest, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.SubscribeTradesRequest subscribe_trades_request = 3; */
        if (message.payload.oneofKind === "subscribeTradesRequest")
            SubscribeTradesRequest.internalBinaryWrite(message.payload.subscribeTradesRequest, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.SubscribeInfoRequest subscribe_info_request = 4; */
        if (message.payload.oneofKind === "subscribeInfoRequest")
            SubscribeInfoRequest.internalBinaryWrite(message.payload.subscribeInfoRequest, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.SubscribeLastPriceRequest subscribe_last_price_request = 5; */
        if (message.payload.oneofKind === "subscribeLastPriceRequest")
            SubscribeLastPriceRequest.internalBinaryWrite(message.payload.subscribeLastPriceRequest, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.GetMySubscriptions get_my_subscriptions = 6; */
        if (message.payload.oneofKind === "getMySubscriptions")
            GetMySubscriptions.internalBinaryWrite(message.payload.getMySubscriptions, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.MarketDataRequest
 */
export const MarketDataRequest = new MarketDataRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketDataServerSideStreamRequest$Type extends MessageType<MarketDataServerSideStreamRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.MarketDataServerSideStreamRequest", [
            { no: 1, name: "subscribe_candles_request", kind: "message", T: () => SubscribeCandlesRequest },
            { no: 2, name: "subscribe_order_book_request", kind: "message", T: () => SubscribeOrderBookRequest },
            { no: 3, name: "subscribe_trades_request", kind: "message", T: () => SubscribeTradesRequest },
            { no: 4, name: "subscribe_info_request", kind: "message", T: () => SubscribeInfoRequest },
            { no: 5, name: "subscribe_last_price_request", kind: "message", T: () => SubscribeLastPriceRequest }
        ]);
    }
    create(value?: PartialMessage<MarketDataServerSideStreamRequest>): MarketDataServerSideStreamRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MarketDataServerSideStreamRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketDataServerSideStreamRequest): MarketDataServerSideStreamRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.SubscribeCandlesRequest subscribe_candles_request */ 1:
                    message.subscribeCandlesRequest = SubscribeCandlesRequest.internalBinaryRead(reader, reader.uint32(), options, message.subscribeCandlesRequest);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.SubscribeOrderBookRequest subscribe_order_book_request */ 2:
                    message.subscribeOrderBookRequest = SubscribeOrderBookRequest.internalBinaryRead(reader, reader.uint32(), options, message.subscribeOrderBookRequest);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.SubscribeTradesRequest subscribe_trades_request */ 3:
                    message.subscribeTradesRequest = SubscribeTradesRequest.internalBinaryRead(reader, reader.uint32(), options, message.subscribeTradesRequest);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.SubscribeInfoRequest subscribe_info_request */ 4:
                    message.subscribeInfoRequest = SubscribeInfoRequest.internalBinaryRead(reader, reader.uint32(), options, message.subscribeInfoRequest);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.SubscribeLastPriceRequest subscribe_last_price_request */ 5:
                    message.subscribeLastPriceRequest = SubscribeLastPriceRequest.internalBinaryRead(reader, reader.uint32(), options, message.subscribeLastPriceRequest);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketDataServerSideStreamRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.SubscribeCandlesRequest subscribe_candles_request = 1; */
        if (message.subscribeCandlesRequest)
            SubscribeCandlesRequest.internalBinaryWrite(message.subscribeCandlesRequest, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.SubscribeOrderBookRequest subscribe_order_book_request = 2; */
        if (message.subscribeOrderBookRequest)
            SubscribeOrderBookRequest.internalBinaryWrite(message.subscribeOrderBookRequest, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.SubscribeTradesRequest subscribe_trades_request = 3; */
        if (message.subscribeTradesRequest)
            SubscribeTradesRequest.internalBinaryWrite(message.subscribeTradesRequest, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.SubscribeInfoRequest subscribe_info_request = 4; */
        if (message.subscribeInfoRequest)
            SubscribeInfoRequest.internalBinaryWrite(message.subscribeInfoRequest, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.SubscribeLastPriceRequest subscribe_last_price_request = 5; */
        if (message.subscribeLastPriceRequest)
            SubscribeLastPriceRequest.internalBinaryWrite(message.subscribeLastPriceRequest, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.MarketDataServerSideStreamRequest
 */
export const MarketDataServerSideStreamRequest = new MarketDataServerSideStreamRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketDataResponse$Type extends MessageType<MarketDataResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.MarketDataResponse", [
            { no: 1, name: "subscribe_candles_response", kind: "message", oneof: "payload", T: () => SubscribeCandlesResponse },
            { no: 2, name: "subscribe_order_book_response", kind: "message", oneof: "payload", T: () => SubscribeOrderBookResponse },
            { no: 3, name: "subscribe_trades_response", kind: "message", oneof: "payload", T: () => SubscribeTradesResponse },
            { no: 4, name: "subscribe_info_response", kind: "message", oneof: "payload", T: () => SubscribeInfoResponse },
            { no: 5, name: "candle", kind: "message", oneof: "payload", T: () => Candle },
            { no: 6, name: "trade", kind: "message", oneof: "payload", T: () => Trade },
            { no: 7, name: "orderbook", kind: "message", oneof: "payload", T: () => OrderBook },
            { no: 8, name: "trading_status", kind: "message", oneof: "payload", T: () => TradingStatus },
            { no: 9, name: "ping", kind: "message", oneof: "payload", T: () => Ping },
            { no: 10, name: "subscribe_last_price_response", kind: "message", oneof: "payload", T: () => SubscribeLastPriceResponse },
            { no: 11, name: "last_price", kind: "message", oneof: "payload", T: () => LastPrice }
        ]);
    }
    create(value?: PartialMessage<MarketDataResponse>): MarketDataResponse {
        const message = { payload: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MarketDataResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketDataResponse): MarketDataResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.SubscribeCandlesResponse subscribe_candles_response */ 1:
                    message.payload = {
                        oneofKind: "subscribeCandlesResponse",
                        subscribeCandlesResponse: SubscribeCandlesResponse.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).subscribeCandlesResponse)
                    };
                    break;
                case /* tinkoff.public.invest.api.contract.v1.SubscribeOrderBookResponse subscribe_order_book_response */ 2:
                    message.payload = {
                        oneofKind: "subscribeOrderBookResponse",
                        subscribeOrderBookResponse: SubscribeOrderBookResponse.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).subscribeOrderBookResponse)
                    };
                    break;
                case /* tinkoff.public.invest.api.contract.v1.SubscribeTradesResponse subscribe_trades_response */ 3:
                    message.payload = {
                        oneofKind: "subscribeTradesResponse",
                        subscribeTradesResponse: SubscribeTradesResponse.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).subscribeTradesResponse)
                    };
                    break;
                case /* tinkoff.public.invest.api.contract.v1.SubscribeInfoResponse subscribe_info_response */ 4:
                    message.payload = {
                        oneofKind: "subscribeInfoResponse",
                        subscribeInfoResponse: SubscribeInfoResponse.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).subscribeInfoResponse)
                    };
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Candle candle */ 5:
                    message.payload = {
                        oneofKind: "candle",
                        candle: Candle.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).candle)
                    };
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Trade trade */ 6:
                    message.payload = {
                        oneofKind: "trade",
                        trade: Trade.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).trade)
                    };
                    break;
                case /* tinkoff.public.invest.api.contract.v1.OrderBook orderbook */ 7:
                    message.payload = {
                        oneofKind: "orderbook",
                        orderbook: OrderBook.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).orderbook)
                    };
                    break;
                case /* tinkoff.public.invest.api.contract.v1.TradingStatus trading_status */ 8:
                    message.payload = {
                        oneofKind: "tradingStatus",
                        tradingStatus: TradingStatus.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).tradingStatus)
                    };
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Ping ping */ 9:
                    message.payload = {
                        oneofKind: "ping",
                        ping: Ping.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).ping)
                    };
                    break;
                case /* tinkoff.public.invest.api.contract.v1.SubscribeLastPriceResponse subscribe_last_price_response */ 10:
                    message.payload = {
                        oneofKind: "subscribeLastPriceResponse",
                        subscribeLastPriceResponse: SubscribeLastPriceResponse.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).subscribeLastPriceResponse)
                    };
                    break;
                case /* tinkoff.public.invest.api.contract.v1.LastPrice last_price */ 11:
                    message.payload = {
                        oneofKind: "lastPrice",
                        lastPrice: LastPrice.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).lastPrice)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketDataResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.SubscribeCandlesResponse subscribe_candles_response = 1; */
        if (message.payload.oneofKind === "subscribeCandlesResponse")
            SubscribeCandlesResponse.internalBinaryWrite(message.payload.subscribeCandlesResponse, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.SubscribeOrderBookResponse subscribe_order_book_response = 2; */
        if (message.payload.oneofKind === "subscribeOrderBookResponse")
            SubscribeOrderBookResponse.internalBinaryWrite(message.payload.subscribeOrderBookResponse, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.SubscribeTradesResponse subscribe_trades_response = 3; */
        if (message.payload.oneofKind === "subscribeTradesResponse")
            SubscribeTradesResponse.internalBinaryWrite(message.payload.subscribeTradesResponse, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.SubscribeInfoResponse subscribe_info_response = 4; */
        if (message.payload.oneofKind === "subscribeInfoResponse")
            SubscribeInfoResponse.internalBinaryWrite(message.payload.subscribeInfoResponse, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Candle candle = 5; */
        if (message.payload.oneofKind === "candle")
            Candle.internalBinaryWrite(message.payload.candle, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Trade trade = 6; */
        if (message.payload.oneofKind === "trade")
            Trade.internalBinaryWrite(message.payload.trade, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.OrderBook orderbook = 7; */
        if (message.payload.oneofKind === "orderbook")
            OrderBook.internalBinaryWrite(message.payload.orderbook, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.TradingStatus trading_status = 8; */
        if (message.payload.oneofKind === "tradingStatus")
            TradingStatus.internalBinaryWrite(message.payload.tradingStatus, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Ping ping = 9; */
        if (message.payload.oneofKind === "ping")
            Ping.internalBinaryWrite(message.payload.ping, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.SubscribeLastPriceResponse subscribe_last_price_response = 10; */
        if (message.payload.oneofKind === "subscribeLastPriceResponse")
            SubscribeLastPriceResponse.internalBinaryWrite(message.payload.subscribeLastPriceResponse, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.LastPrice last_price = 11; */
        if (message.payload.oneofKind === "lastPrice")
            LastPrice.internalBinaryWrite(message.payload.lastPrice, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.MarketDataResponse
 */
export const MarketDataResponse = new MarketDataResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeCandlesRequest$Type extends MessageType<SubscribeCandlesRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.SubscribeCandlesRequest", [
            { no: 1, name: "subscription_action", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.SubscriptionAction", SubscriptionAction, "SUBSCRIPTION_ACTION_"] },
            { no: 2, name: "instruments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CandleInstrument },
            { no: 3, name: "waiting_close", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SubscribeCandlesRequest>): SubscribeCandlesRequest {
        const message = { subscriptionAction: 0, instruments: [], waitingClose: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeCandlesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeCandlesRequest): SubscribeCandlesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.SubscriptionAction subscription_action */ 1:
                    message.subscriptionAction = reader.int32();
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.CandleInstrument instruments */ 2:
                    message.instruments.push(CandleInstrument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool waiting_close */ 3:
                    message.waitingClose = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeCandlesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.SubscriptionAction subscription_action = 1; */
        if (message.subscriptionAction !== 0)
            writer.tag(1, WireType.Varint).int32(message.subscriptionAction);
        /* repeated tinkoff.public.invest.api.contract.v1.CandleInstrument instruments = 2; */
        for (let i = 0; i < message.instruments.length; i++)
            CandleInstrument.internalBinaryWrite(message.instruments[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool waiting_close = 3; */
        if (message.waitingClose !== false)
            writer.tag(3, WireType.Varint).bool(message.waitingClose);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.SubscribeCandlesRequest
 */
export const SubscribeCandlesRequest = new SubscribeCandlesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CandleInstrument$Type extends MessageType<CandleInstrument> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.CandleInstrument", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "interval", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.SubscriptionInterval", SubscriptionInterval, "SUBSCRIPTION_INTERVAL_"] },
            { no: 3, name: "instrument_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CandleInstrument>): CandleInstrument {
        const message = { figi: "", interval: 0, instrumentId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CandleInstrument>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CandleInstrument): CandleInstrument {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.SubscriptionInterval interval */ 2:
                    message.interval = reader.int32();
                    break;
                case /* string instrument_id */ 3:
                    message.instrumentId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CandleInstrument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* tinkoff.public.invest.api.contract.v1.SubscriptionInterval interval = 2; */
        if (message.interval !== 0)
            writer.tag(2, WireType.Varint).int32(message.interval);
        /* string instrument_id = 3; */
        if (message.instrumentId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.instrumentId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.CandleInstrument
 */
export const CandleInstrument = new CandleInstrument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeCandlesResponse$Type extends MessageType<SubscribeCandlesResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.SubscribeCandlesResponse", [
            { no: 1, name: "tracking_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "candles_subscriptions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CandleSubscription }
        ]);
    }
    create(value?: PartialMessage<SubscribeCandlesResponse>): SubscribeCandlesResponse {
        const message = { trackingId: "", candlesSubscriptions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeCandlesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeCandlesResponse): SubscribeCandlesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tracking_id */ 1:
                    message.trackingId = reader.string();
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.CandleSubscription candles_subscriptions */ 2:
                    message.candlesSubscriptions.push(CandleSubscription.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeCandlesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tracking_id = 1; */
        if (message.trackingId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.trackingId);
        /* repeated tinkoff.public.invest.api.contract.v1.CandleSubscription candles_subscriptions = 2; */
        for (let i = 0; i < message.candlesSubscriptions.length; i++)
            CandleSubscription.internalBinaryWrite(message.candlesSubscriptions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.SubscribeCandlesResponse
 */
export const SubscribeCandlesResponse = new SubscribeCandlesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CandleSubscription$Type extends MessageType<CandleSubscription> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.CandleSubscription", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "interval", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.SubscriptionInterval", SubscriptionInterval, "SUBSCRIPTION_INTERVAL_"] },
            { no: 3, name: "subscription_status", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.SubscriptionStatus", SubscriptionStatus, "SUBSCRIPTION_STATUS_"] },
            { no: 4, name: "instrument_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CandleSubscription>): CandleSubscription {
        const message = { figi: "", interval: 0, subscriptionStatus: 0, instrumentUid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CandleSubscription>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CandleSubscription): CandleSubscription {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.SubscriptionInterval interval */ 2:
                    message.interval = reader.int32();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.SubscriptionStatus subscription_status */ 3:
                    message.subscriptionStatus = reader.int32();
                    break;
                case /* string instrument_uid */ 4:
                    message.instrumentUid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CandleSubscription, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* tinkoff.public.invest.api.contract.v1.SubscriptionInterval interval = 2; */
        if (message.interval !== 0)
            writer.tag(2, WireType.Varint).int32(message.interval);
        /* tinkoff.public.invest.api.contract.v1.SubscriptionStatus subscription_status = 3; */
        if (message.subscriptionStatus !== 0)
            writer.tag(3, WireType.Varint).int32(message.subscriptionStatus);
        /* string instrument_uid = 4; */
        if (message.instrumentUid !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.instrumentUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.CandleSubscription
 */
export const CandleSubscription = new CandleSubscription$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeOrderBookRequest$Type extends MessageType<SubscribeOrderBookRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.SubscribeOrderBookRequest", [
            { no: 1, name: "subscription_action", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.SubscriptionAction", SubscriptionAction, "SUBSCRIPTION_ACTION_"] },
            { no: 2, name: "instruments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => OrderBookInstrument }
        ]);
    }
    create(value?: PartialMessage<SubscribeOrderBookRequest>): SubscribeOrderBookRequest {
        const message = { subscriptionAction: 0, instruments: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeOrderBookRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeOrderBookRequest): SubscribeOrderBookRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.SubscriptionAction subscription_action */ 1:
                    message.subscriptionAction = reader.int32();
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.OrderBookInstrument instruments */ 2:
                    message.instruments.push(OrderBookInstrument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeOrderBookRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.SubscriptionAction subscription_action = 1; */
        if (message.subscriptionAction !== 0)
            writer.tag(1, WireType.Varint).int32(message.subscriptionAction);
        /* repeated tinkoff.public.invest.api.contract.v1.OrderBookInstrument instruments = 2; */
        for (let i = 0; i < message.instruments.length; i++)
            OrderBookInstrument.internalBinaryWrite(message.instruments[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.SubscribeOrderBookRequest
 */
export const SubscribeOrderBookRequest = new SubscribeOrderBookRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderBookInstrument$Type extends MessageType<OrderBookInstrument> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.OrderBookInstrument", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "depth", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "instrument_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OrderBookInstrument>): OrderBookInstrument {
        const message = { figi: "", depth: 0, instrumentId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OrderBookInstrument>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderBookInstrument): OrderBookInstrument {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* int32 depth */ 2:
                    message.depth = reader.int32();
                    break;
                case /* string instrument_id */ 3:
                    message.instrumentId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderBookInstrument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* int32 depth = 2; */
        if (message.depth !== 0)
            writer.tag(2, WireType.Varint).int32(message.depth);
        /* string instrument_id = 3; */
        if (message.instrumentId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.instrumentId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.OrderBookInstrument
 */
export const OrderBookInstrument = new OrderBookInstrument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeOrderBookResponse$Type extends MessageType<SubscribeOrderBookResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.SubscribeOrderBookResponse", [
            { no: 1, name: "tracking_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order_book_subscriptions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => OrderBookSubscription }
        ]);
    }
    create(value?: PartialMessage<SubscribeOrderBookResponse>): SubscribeOrderBookResponse {
        const message = { trackingId: "", orderBookSubscriptions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeOrderBookResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeOrderBookResponse): SubscribeOrderBookResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tracking_id */ 1:
                    message.trackingId = reader.string();
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.OrderBookSubscription order_book_subscriptions */ 2:
                    message.orderBookSubscriptions.push(OrderBookSubscription.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeOrderBookResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tracking_id = 1; */
        if (message.trackingId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.trackingId);
        /* repeated tinkoff.public.invest.api.contract.v1.OrderBookSubscription order_book_subscriptions = 2; */
        for (let i = 0; i < message.orderBookSubscriptions.length; i++)
            OrderBookSubscription.internalBinaryWrite(message.orderBookSubscriptions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.SubscribeOrderBookResponse
 */
export const SubscribeOrderBookResponse = new SubscribeOrderBookResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderBookSubscription$Type extends MessageType<OrderBookSubscription> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.OrderBookSubscription", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "depth", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "subscription_status", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.SubscriptionStatus", SubscriptionStatus, "SUBSCRIPTION_STATUS_"] },
            { no: 4, name: "instrument_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OrderBookSubscription>): OrderBookSubscription {
        const message = { figi: "", depth: 0, subscriptionStatus: 0, instrumentUid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OrderBookSubscription>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderBookSubscription): OrderBookSubscription {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* int32 depth */ 2:
                    message.depth = reader.int32();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.SubscriptionStatus subscription_status */ 3:
                    message.subscriptionStatus = reader.int32();
                    break;
                case /* string instrument_uid */ 4:
                    message.instrumentUid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderBookSubscription, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* int32 depth = 2; */
        if (message.depth !== 0)
            writer.tag(2, WireType.Varint).int32(message.depth);
        /* tinkoff.public.invest.api.contract.v1.SubscriptionStatus subscription_status = 3; */
        if (message.subscriptionStatus !== 0)
            writer.tag(3, WireType.Varint).int32(message.subscriptionStatus);
        /* string instrument_uid = 4; */
        if (message.instrumentUid !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.instrumentUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.OrderBookSubscription
 */
export const OrderBookSubscription = new OrderBookSubscription$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeTradesRequest$Type extends MessageType<SubscribeTradesRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.SubscribeTradesRequest", [
            { no: 1, name: "subscription_action", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.SubscriptionAction", SubscriptionAction, "SUBSCRIPTION_ACTION_"] },
            { no: 2, name: "instruments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TradeInstrument }
        ]);
    }
    create(value?: PartialMessage<SubscribeTradesRequest>): SubscribeTradesRequest {
        const message = { subscriptionAction: 0, instruments: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeTradesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTradesRequest): SubscribeTradesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.SubscriptionAction subscription_action */ 1:
                    message.subscriptionAction = reader.int32();
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.TradeInstrument instruments */ 2:
                    message.instruments.push(TradeInstrument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeTradesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.SubscriptionAction subscription_action = 1; */
        if (message.subscriptionAction !== 0)
            writer.tag(1, WireType.Varint).int32(message.subscriptionAction);
        /* repeated tinkoff.public.invest.api.contract.v1.TradeInstrument instruments = 2; */
        for (let i = 0; i < message.instruments.length; i++)
            TradeInstrument.internalBinaryWrite(message.instruments[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.SubscribeTradesRequest
 */
export const SubscribeTradesRequest = new SubscribeTradesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradeInstrument$Type extends MessageType<TradeInstrument> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.TradeInstrument", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "instrument_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TradeInstrument>): TradeInstrument {
        const message = { figi: "", instrumentId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TradeInstrument>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradeInstrument): TradeInstrument {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* string instrument_id */ 2:
                    message.instrumentId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradeInstrument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* string instrument_id = 2; */
        if (message.instrumentId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.instrumentId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.TradeInstrument
 */
export const TradeInstrument = new TradeInstrument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeTradesResponse$Type extends MessageType<SubscribeTradesResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.SubscribeTradesResponse", [
            { no: 1, name: "tracking_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "trade_subscriptions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TradeSubscription }
        ]);
    }
    create(value?: PartialMessage<SubscribeTradesResponse>): SubscribeTradesResponse {
        const message = { trackingId: "", tradeSubscriptions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeTradesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTradesResponse): SubscribeTradesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tracking_id */ 1:
                    message.trackingId = reader.string();
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.TradeSubscription trade_subscriptions */ 2:
                    message.tradeSubscriptions.push(TradeSubscription.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeTradesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tracking_id = 1; */
        if (message.trackingId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.trackingId);
        /* repeated tinkoff.public.invest.api.contract.v1.TradeSubscription trade_subscriptions = 2; */
        for (let i = 0; i < message.tradeSubscriptions.length; i++)
            TradeSubscription.internalBinaryWrite(message.tradeSubscriptions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.SubscribeTradesResponse
 */
export const SubscribeTradesResponse = new SubscribeTradesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradeSubscription$Type extends MessageType<TradeSubscription> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.TradeSubscription", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subscription_status", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.SubscriptionStatus", SubscriptionStatus, "SUBSCRIPTION_STATUS_"] },
            { no: 3, name: "instrument_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TradeSubscription>): TradeSubscription {
        const message = { figi: "", subscriptionStatus: 0, instrumentUid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TradeSubscription>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradeSubscription): TradeSubscription {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.SubscriptionStatus subscription_status */ 2:
                    message.subscriptionStatus = reader.int32();
                    break;
                case /* string instrument_uid */ 3:
                    message.instrumentUid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradeSubscription, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* tinkoff.public.invest.api.contract.v1.SubscriptionStatus subscription_status = 2; */
        if (message.subscriptionStatus !== 0)
            writer.tag(2, WireType.Varint).int32(message.subscriptionStatus);
        /* string instrument_uid = 3; */
        if (message.instrumentUid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.instrumentUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.TradeSubscription
 */
export const TradeSubscription = new TradeSubscription$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeInfoRequest$Type extends MessageType<SubscribeInfoRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.SubscribeInfoRequest", [
            { no: 1, name: "subscription_action", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.SubscriptionAction", SubscriptionAction, "SUBSCRIPTION_ACTION_"] },
            { no: 2, name: "instruments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => InfoInstrument }
        ]);
    }
    create(value?: PartialMessage<SubscribeInfoRequest>): SubscribeInfoRequest {
        const message = { subscriptionAction: 0, instruments: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeInfoRequest): SubscribeInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.SubscriptionAction subscription_action */ 1:
                    message.subscriptionAction = reader.int32();
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.InfoInstrument instruments */ 2:
                    message.instruments.push(InfoInstrument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.SubscriptionAction subscription_action = 1; */
        if (message.subscriptionAction !== 0)
            writer.tag(1, WireType.Varint).int32(message.subscriptionAction);
        /* repeated tinkoff.public.invest.api.contract.v1.InfoInstrument instruments = 2; */
        for (let i = 0; i < message.instruments.length; i++)
            InfoInstrument.internalBinaryWrite(message.instruments[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.SubscribeInfoRequest
 */
export const SubscribeInfoRequest = new SubscribeInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InfoInstrument$Type extends MessageType<InfoInstrument> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.InfoInstrument", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "instrument_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<InfoInstrument>): InfoInstrument {
        const message = { figi: "", instrumentId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InfoInstrument>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InfoInstrument): InfoInstrument {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* string instrument_id */ 2:
                    message.instrumentId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InfoInstrument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* string instrument_id = 2; */
        if (message.instrumentId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.instrumentId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.InfoInstrument
 */
export const InfoInstrument = new InfoInstrument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeInfoResponse$Type extends MessageType<SubscribeInfoResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.SubscribeInfoResponse", [
            { no: 1, name: "tracking_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "info_subscriptions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => InfoSubscription }
        ]);
    }
    create(value?: PartialMessage<SubscribeInfoResponse>): SubscribeInfoResponse {
        const message = { trackingId: "", infoSubscriptions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeInfoResponse): SubscribeInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tracking_id */ 1:
                    message.trackingId = reader.string();
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.InfoSubscription info_subscriptions */ 2:
                    message.infoSubscriptions.push(InfoSubscription.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tracking_id = 1; */
        if (message.trackingId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.trackingId);
        /* repeated tinkoff.public.invest.api.contract.v1.InfoSubscription info_subscriptions = 2; */
        for (let i = 0; i < message.infoSubscriptions.length; i++)
            InfoSubscription.internalBinaryWrite(message.infoSubscriptions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.SubscribeInfoResponse
 */
export const SubscribeInfoResponse = new SubscribeInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InfoSubscription$Type extends MessageType<InfoSubscription> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.InfoSubscription", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subscription_status", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.SubscriptionStatus", SubscriptionStatus, "SUBSCRIPTION_STATUS_"] },
            { no: 3, name: "instrument_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<InfoSubscription>): InfoSubscription {
        const message = { figi: "", subscriptionStatus: 0, instrumentUid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InfoSubscription>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InfoSubscription): InfoSubscription {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.SubscriptionStatus subscription_status */ 2:
                    message.subscriptionStatus = reader.int32();
                    break;
                case /* string instrument_uid */ 3:
                    message.instrumentUid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InfoSubscription, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* tinkoff.public.invest.api.contract.v1.SubscriptionStatus subscription_status = 2; */
        if (message.subscriptionStatus !== 0)
            writer.tag(2, WireType.Varint).int32(message.subscriptionStatus);
        /* string instrument_uid = 3; */
        if (message.instrumentUid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.instrumentUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.InfoSubscription
 */
export const InfoSubscription = new InfoSubscription$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeLastPriceRequest$Type extends MessageType<SubscribeLastPriceRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.SubscribeLastPriceRequest", [
            { no: 1, name: "subscription_action", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.SubscriptionAction", SubscriptionAction, "SUBSCRIPTION_ACTION_"] },
            { no: 2, name: "instruments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => LastPriceInstrument }
        ]);
    }
    create(value?: PartialMessage<SubscribeLastPriceRequest>): SubscribeLastPriceRequest {
        const message = { subscriptionAction: 0, instruments: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeLastPriceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeLastPriceRequest): SubscribeLastPriceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.SubscriptionAction subscription_action */ 1:
                    message.subscriptionAction = reader.int32();
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.LastPriceInstrument instruments */ 2:
                    message.instruments.push(LastPriceInstrument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeLastPriceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.SubscriptionAction subscription_action = 1; */
        if (message.subscriptionAction !== 0)
            writer.tag(1, WireType.Varint).int32(message.subscriptionAction);
        /* repeated tinkoff.public.invest.api.contract.v1.LastPriceInstrument instruments = 2; */
        for (let i = 0; i < message.instruments.length; i++)
            LastPriceInstrument.internalBinaryWrite(message.instruments[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.SubscribeLastPriceRequest
 */
export const SubscribeLastPriceRequest = new SubscribeLastPriceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LastPriceInstrument$Type extends MessageType<LastPriceInstrument> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.LastPriceInstrument", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "instrument_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LastPriceInstrument>): LastPriceInstrument {
        const message = { figi: "", instrumentId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LastPriceInstrument>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LastPriceInstrument): LastPriceInstrument {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* string instrument_id */ 2:
                    message.instrumentId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LastPriceInstrument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* string instrument_id = 2; */
        if (message.instrumentId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.instrumentId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.LastPriceInstrument
 */
export const LastPriceInstrument = new LastPriceInstrument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeLastPriceResponse$Type extends MessageType<SubscribeLastPriceResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.SubscribeLastPriceResponse", [
            { no: 1, name: "tracking_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "last_price_subscriptions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => LastPriceSubscription }
        ]);
    }
    create(value?: PartialMessage<SubscribeLastPriceResponse>): SubscribeLastPriceResponse {
        const message = { trackingId: "", lastPriceSubscriptions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeLastPriceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeLastPriceResponse): SubscribeLastPriceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tracking_id */ 1:
                    message.trackingId = reader.string();
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.LastPriceSubscription last_price_subscriptions */ 2:
                    message.lastPriceSubscriptions.push(LastPriceSubscription.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeLastPriceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tracking_id = 1; */
        if (message.trackingId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.trackingId);
        /* repeated tinkoff.public.invest.api.contract.v1.LastPriceSubscription last_price_subscriptions = 2; */
        for (let i = 0; i < message.lastPriceSubscriptions.length; i++)
            LastPriceSubscription.internalBinaryWrite(message.lastPriceSubscriptions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.SubscribeLastPriceResponse
 */
export const SubscribeLastPriceResponse = new SubscribeLastPriceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LastPriceSubscription$Type extends MessageType<LastPriceSubscription> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.LastPriceSubscription", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subscription_status", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.SubscriptionStatus", SubscriptionStatus, "SUBSCRIPTION_STATUS_"] },
            { no: 3, name: "instrument_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LastPriceSubscription>): LastPriceSubscription {
        const message = { figi: "", subscriptionStatus: 0, instrumentUid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LastPriceSubscription>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LastPriceSubscription): LastPriceSubscription {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.SubscriptionStatus subscription_status */ 2:
                    message.subscriptionStatus = reader.int32();
                    break;
                case /* string instrument_uid */ 3:
                    message.instrumentUid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LastPriceSubscription, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* tinkoff.public.invest.api.contract.v1.SubscriptionStatus subscription_status = 2; */
        if (message.subscriptionStatus !== 0)
            writer.tag(2, WireType.Varint).int32(message.subscriptionStatus);
        /* string instrument_uid = 3; */
        if (message.instrumentUid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.instrumentUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.LastPriceSubscription
 */
export const LastPriceSubscription = new LastPriceSubscription$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Candle$Type extends MessageType<Candle> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.Candle", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "interval", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.SubscriptionInterval", SubscriptionInterval, "SUBSCRIPTION_INTERVAL_"] },
            { no: 3, name: "open", kind: "message", T: () => Quotation },
            { no: 4, name: "high", kind: "message", T: () => Quotation },
            { no: 5, name: "low", kind: "message", T: () => Quotation },
            { no: 6, name: "close", kind: "message", T: () => Quotation },
            { no: 7, name: "volume", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 8, name: "time", kind: "message", T: () => Timestamp },
            { no: 9, name: "last_trade_ts", kind: "message", T: () => Timestamp },
            { no: 10, name: "instrument_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Candle>): Candle {
        const message = { figi: "", interval: 0, volume: "0", instrumentUid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Candle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Candle): Candle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.SubscriptionInterval interval */ 2:
                    message.interval = reader.int32();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation open */ 3:
                    message.open = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.open);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation high */ 4:
                    message.high = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.high);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation low */ 5:
                    message.low = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.low);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation close */ 6:
                    message.close = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.close);
                    break;
                case /* int64 volume */ 7:
                    message.volume = reader.int64().toString();
                    break;
                case /* google.protobuf.Timestamp time */ 8:
                    message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                case /* google.protobuf.Timestamp last_trade_ts */ 9:
                    message.lastTradeTs = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastTradeTs);
                    break;
                case /* string instrument_uid */ 10:
                    message.instrumentUid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Candle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* tinkoff.public.invest.api.contract.v1.SubscriptionInterval interval = 2; */
        if (message.interval !== 0)
            writer.tag(2, WireType.Varint).int32(message.interval);
        /* tinkoff.public.invest.api.contract.v1.Quotation open = 3; */
        if (message.open)
            Quotation.internalBinaryWrite(message.open, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation high = 4; */
        if (message.high)
            Quotation.internalBinaryWrite(message.high, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation low = 5; */
        if (message.low)
            Quotation.internalBinaryWrite(message.low, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation close = 6; */
        if (message.close)
            Quotation.internalBinaryWrite(message.close, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* int64 volume = 7; */
        if (message.volume !== "0")
            writer.tag(7, WireType.Varint).int64(message.volume);
        /* google.protobuf.Timestamp time = 8; */
        if (message.time)
            Timestamp.internalBinaryWrite(message.time, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_trade_ts = 9; */
        if (message.lastTradeTs)
            Timestamp.internalBinaryWrite(message.lastTradeTs, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* string instrument_uid = 10; */
        if (message.instrumentUid !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.instrumentUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.Candle
 */
export const Candle = new Candle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderBook$Type extends MessageType<OrderBook> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.OrderBook", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "depth", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "is_consistent", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "bids", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Order },
            { no: 5, name: "asks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Order },
            { no: 6, name: "time", kind: "message", T: () => Timestamp },
            { no: 7, name: "limit_up", kind: "message", T: () => Quotation },
            { no: 8, name: "limit_down", kind: "message", T: () => Quotation },
            { no: 9, name: "instrument_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OrderBook>): OrderBook {
        const message = { figi: "", depth: 0, isConsistent: false, bids: [], asks: [], instrumentUid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OrderBook>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderBook): OrderBook {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* int32 depth */ 2:
                    message.depth = reader.int32();
                    break;
                case /* bool is_consistent */ 3:
                    message.isConsistent = reader.bool();
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.Order bids */ 4:
                    message.bids.push(Order.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.Order asks */ 5:
                    message.asks.push(Order.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Timestamp time */ 6:
                    message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation limit_up */ 7:
                    message.limitUp = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.limitUp);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation limit_down */ 8:
                    message.limitDown = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.limitDown);
                    break;
                case /* string instrument_uid */ 9:
                    message.instrumentUid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderBook, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* int32 depth = 2; */
        if (message.depth !== 0)
            writer.tag(2, WireType.Varint).int32(message.depth);
        /* bool is_consistent = 3; */
        if (message.isConsistent !== false)
            writer.tag(3, WireType.Varint).bool(message.isConsistent);
        /* repeated tinkoff.public.invest.api.contract.v1.Order bids = 4; */
        for (let i = 0; i < message.bids.length; i++)
            Order.internalBinaryWrite(message.bids[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated tinkoff.public.invest.api.contract.v1.Order asks = 5; */
        for (let i = 0; i < message.asks.length; i++)
            Order.internalBinaryWrite(message.asks[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp time = 6; */
        if (message.time)
            Timestamp.internalBinaryWrite(message.time, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation limit_up = 7; */
        if (message.limitUp)
            Quotation.internalBinaryWrite(message.limitUp, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation limit_down = 8; */
        if (message.limitDown)
            Quotation.internalBinaryWrite(message.limitDown, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* string instrument_uid = 9; */
        if (message.instrumentUid !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.instrumentUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.OrderBook
 */
export const OrderBook = new OrderBook$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Order$Type extends MessageType<Order> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.Order", [
            { no: 1, name: "price", kind: "message", T: () => Quotation },
            { no: 2, name: "quantity", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<Order>): Order {
        const message = { quantity: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Order>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Order): Order {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.Quotation price */ 1:
                    message.price = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.price);
                    break;
                case /* int64 quantity */ 2:
                    message.quantity = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Order, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.Quotation price = 1; */
        if (message.price)
            Quotation.internalBinaryWrite(message.price, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 quantity = 2; */
        if (message.quantity !== "0")
            writer.tag(2, WireType.Varint).int64(message.quantity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.Order
 */
export const Order = new Order$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Trade$Type extends MessageType<Trade> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.Trade", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "direction", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.TradeDirection", TradeDirection, "TRADE_DIRECTION_"] },
            { no: 3, name: "price", kind: "message", T: () => Quotation },
            { no: 4, name: "quantity", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 5, name: "time", kind: "message", T: () => Timestamp },
            { no: 6, name: "instrument_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Trade>): Trade {
        const message = { figi: "", direction: 0, quantity: "0", instrumentUid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Trade>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Trade): Trade {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.TradeDirection direction */ 2:
                    message.direction = reader.int32();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation price */ 3:
                    message.price = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.price);
                    break;
                case /* int64 quantity */ 4:
                    message.quantity = reader.int64().toString();
                    break;
                case /* google.protobuf.Timestamp time */ 5:
                    message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                case /* string instrument_uid */ 6:
                    message.instrumentUid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Trade, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* tinkoff.public.invest.api.contract.v1.TradeDirection direction = 2; */
        if (message.direction !== 0)
            writer.tag(2, WireType.Varint).int32(message.direction);
        /* tinkoff.public.invest.api.contract.v1.Quotation price = 3; */
        if (message.price)
            Quotation.internalBinaryWrite(message.price, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* int64 quantity = 4; */
        if (message.quantity !== "0")
            writer.tag(4, WireType.Varint).int64(message.quantity);
        /* google.protobuf.Timestamp time = 5; */
        if (message.time)
            Timestamp.internalBinaryWrite(message.time, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string instrument_uid = 6; */
        if (message.instrumentUid !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.instrumentUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.Trade
 */
export const Trade = new Trade$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradingStatus$Type extends MessageType<TradingStatus> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.TradingStatus", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "trading_status", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.SecurityTradingStatus", SecurityTradingStatus, "SECURITY_TRADING_STATUS_"] },
            { no: 3, name: "time", kind: "message", T: () => Timestamp },
            { no: 4, name: "limit_order_available_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "market_order_available_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "instrument_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TradingStatus>): TradingStatus {
        const message = { figi: "", tradingStatus: 0, limitOrderAvailableFlag: false, marketOrderAvailableFlag: false, instrumentUid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TradingStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradingStatus): TradingStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status */ 2:
                    message.tradingStatus = reader.int32();
                    break;
                case /* google.protobuf.Timestamp time */ 3:
                    message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                case /* bool limit_order_available_flag */ 4:
                    message.limitOrderAvailableFlag = reader.bool();
                    break;
                case /* bool market_order_available_flag */ 5:
                    message.marketOrderAvailableFlag = reader.bool();
                    break;
                case /* string instrument_uid */ 6:
                    message.instrumentUid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradingStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status = 2; */
        if (message.tradingStatus !== 0)
            writer.tag(2, WireType.Varint).int32(message.tradingStatus);
        /* google.protobuf.Timestamp time = 3; */
        if (message.time)
            Timestamp.internalBinaryWrite(message.time, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool limit_order_available_flag = 4; */
        if (message.limitOrderAvailableFlag !== false)
            writer.tag(4, WireType.Varint).bool(message.limitOrderAvailableFlag);
        /* bool market_order_available_flag = 5; */
        if (message.marketOrderAvailableFlag !== false)
            writer.tag(5, WireType.Varint).bool(message.marketOrderAvailableFlag);
        /* string instrument_uid = 6; */
        if (message.instrumentUid !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.instrumentUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.TradingStatus
 */
export const TradingStatus = new TradingStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCandlesRequest$Type extends MessageType<GetCandlesRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetCandlesRequest", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "from", kind: "message", T: () => Timestamp },
            { no: 3, name: "to", kind: "message", T: () => Timestamp },
            { no: 4, name: "interval", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.CandleInterval", CandleInterval] },
            { no: 5, name: "instrument_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetCandlesRequest>): GetCandlesRequest {
        const message = { figi: "", interval: 0, instrumentId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetCandlesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCandlesRequest): GetCandlesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* google.protobuf.Timestamp from */ 2:
                    message.from = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.from);
                    break;
                case /* google.protobuf.Timestamp to */ 3:
                    message.to = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.to);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.CandleInterval interval */ 4:
                    message.interval = reader.int32();
                    break;
                case /* string instrument_id */ 5:
                    message.instrumentId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCandlesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* google.protobuf.Timestamp from = 2; */
        if (message.from)
            Timestamp.internalBinaryWrite(message.from, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp to = 3; */
        if (message.to)
            Timestamp.internalBinaryWrite(message.to, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.CandleInterval interval = 4; */
        if (message.interval !== 0)
            writer.tag(4, WireType.Varint).int32(message.interval);
        /* string instrument_id = 5; */
        if (message.instrumentId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.instrumentId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetCandlesRequest
 */
export const GetCandlesRequest = new GetCandlesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCandlesResponse$Type extends MessageType<GetCandlesResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetCandlesResponse", [
            { no: 1, name: "candles", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HistoricCandle }
        ]);
    }
    create(value?: PartialMessage<GetCandlesResponse>): GetCandlesResponse {
        const message = { candles: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetCandlesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCandlesResponse): GetCandlesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.HistoricCandle candles */ 1:
                    message.candles.push(HistoricCandle.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCandlesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.HistoricCandle candles = 1; */
        for (let i = 0; i < message.candles.length; i++)
            HistoricCandle.internalBinaryWrite(message.candles[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetCandlesResponse
 */
export const GetCandlesResponse = new GetCandlesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HistoricCandle$Type extends MessageType<HistoricCandle> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.HistoricCandle", [
            { no: 1, name: "open", kind: "message", T: () => Quotation },
            { no: 2, name: "high", kind: "message", T: () => Quotation },
            { no: 3, name: "low", kind: "message", T: () => Quotation },
            { no: 4, name: "close", kind: "message", T: () => Quotation },
            { no: 5, name: "volume", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 6, name: "time", kind: "message", T: () => Timestamp },
            { no: 7, name: "is_complete", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<HistoricCandle>): HistoricCandle {
        const message = { volume: "0", isComplete: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HistoricCandle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HistoricCandle): HistoricCandle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.Quotation open */ 1:
                    message.open = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.open);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation high */ 2:
                    message.high = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.high);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation low */ 3:
                    message.low = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.low);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation close */ 4:
                    message.close = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.close);
                    break;
                case /* int64 volume */ 5:
                    message.volume = reader.int64().toString();
                    break;
                case /* google.protobuf.Timestamp time */ 6:
                    message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                case /* bool is_complete */ 7:
                    message.isComplete = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HistoricCandle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.Quotation open = 1; */
        if (message.open)
            Quotation.internalBinaryWrite(message.open, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation high = 2; */
        if (message.high)
            Quotation.internalBinaryWrite(message.high, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation low = 3; */
        if (message.low)
            Quotation.internalBinaryWrite(message.low, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation close = 4; */
        if (message.close)
            Quotation.internalBinaryWrite(message.close, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* int64 volume = 5; */
        if (message.volume !== "0")
            writer.tag(5, WireType.Varint).int64(message.volume);
        /* google.protobuf.Timestamp time = 6; */
        if (message.time)
            Timestamp.internalBinaryWrite(message.time, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* bool is_complete = 7; */
        if (message.isComplete !== false)
            writer.tag(7, WireType.Varint).bool(message.isComplete);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.HistoricCandle
 */
export const HistoricCandle = new HistoricCandle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetLastPricesRequest$Type extends MessageType<GetLastPricesRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetLastPricesRequest", [
            { no: 1, name: "figi", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "instrument_id", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetLastPricesRequest>): GetLastPricesRequest {
        const message = { figi: [], instrumentId: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetLastPricesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetLastPricesRequest): GetLastPricesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string figi */ 1:
                    message.figi.push(reader.string());
                    break;
                case /* repeated string instrument_id */ 2:
                    message.instrumentId.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetLastPricesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string figi = 1; */
        for (let i = 0; i < message.figi.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.figi[i]);
        /* repeated string instrument_id = 2; */
        for (let i = 0; i < message.instrumentId.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.instrumentId[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetLastPricesRequest
 */
export const GetLastPricesRequest = new GetLastPricesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetLastPricesResponse$Type extends MessageType<GetLastPricesResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetLastPricesResponse", [
            { no: 1, name: "last_prices", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => LastPrice }
        ]);
    }
    create(value?: PartialMessage<GetLastPricesResponse>): GetLastPricesResponse {
        const message = { lastPrices: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetLastPricesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetLastPricesResponse): GetLastPricesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.LastPrice last_prices */ 1:
                    message.lastPrices.push(LastPrice.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetLastPricesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.LastPrice last_prices = 1; */
        for (let i = 0; i < message.lastPrices.length; i++)
            LastPrice.internalBinaryWrite(message.lastPrices[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetLastPricesResponse
 */
export const GetLastPricesResponse = new GetLastPricesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LastPrice$Type extends MessageType<LastPrice> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.LastPrice", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "price", kind: "message", T: () => Quotation },
            { no: 3, name: "time", kind: "message", T: () => Timestamp },
            { no: 11, name: "instrument_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LastPrice>): LastPrice {
        const message = { figi: "", instrumentUid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LastPrice>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LastPrice): LastPrice {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation price */ 2:
                    message.price = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.price);
                    break;
                case /* google.protobuf.Timestamp time */ 3:
                    message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                case /* string instrument_uid */ 11:
                    message.instrumentUid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LastPrice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* tinkoff.public.invest.api.contract.v1.Quotation price = 2; */
        if (message.price)
            Quotation.internalBinaryWrite(message.price, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp time = 3; */
        if (message.time)
            Timestamp.internalBinaryWrite(message.time, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string instrument_uid = 11; */
        if (message.instrumentUid !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.instrumentUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.LastPrice
 */
export const LastPrice = new LastPrice$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetOrderBookRequest$Type extends MessageType<GetOrderBookRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetOrderBookRequest", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "depth", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "instrument_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetOrderBookRequest>): GetOrderBookRequest {
        const message = { figi: "", depth: 0, instrumentId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetOrderBookRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetOrderBookRequest): GetOrderBookRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* int32 depth */ 2:
                    message.depth = reader.int32();
                    break;
                case /* string instrument_id */ 3:
                    message.instrumentId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetOrderBookRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* int32 depth = 2; */
        if (message.depth !== 0)
            writer.tag(2, WireType.Varint).int32(message.depth);
        /* string instrument_id = 3; */
        if (message.instrumentId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.instrumentId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetOrderBookRequest
 */
export const GetOrderBookRequest = new GetOrderBookRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetOrderBookResponse$Type extends MessageType<GetOrderBookResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetOrderBookResponse", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "depth", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "bids", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Order },
            { no: 4, name: "asks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Order },
            { no: 5, name: "last_price", kind: "message", T: () => Quotation },
            { no: 6, name: "close_price", kind: "message", T: () => Quotation },
            { no: 7, name: "limit_up", kind: "message", T: () => Quotation },
            { no: 8, name: "limit_down", kind: "message", T: () => Quotation },
            { no: 21, name: "last_price_ts", kind: "message", T: () => Timestamp },
            { no: 22, name: "close_price_ts", kind: "message", T: () => Timestamp },
            { no: 23, name: "orderbook_ts", kind: "message", T: () => Timestamp },
            { no: 9, name: "instrument_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetOrderBookResponse>): GetOrderBookResponse {
        const message = { figi: "", depth: 0, bids: [], asks: [], instrumentUid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetOrderBookResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetOrderBookResponse): GetOrderBookResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* int32 depth */ 2:
                    message.depth = reader.int32();
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.Order bids */ 3:
                    message.bids.push(Order.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.Order asks */ 4:
                    message.asks.push(Order.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation last_price */ 5:
                    message.lastPrice = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.lastPrice);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation close_price */ 6:
                    message.closePrice = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.closePrice);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation limit_up */ 7:
                    message.limitUp = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.limitUp);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation limit_down */ 8:
                    message.limitDown = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.limitDown);
                    break;
                case /* google.protobuf.Timestamp last_price_ts */ 21:
                    message.lastPriceTs = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastPriceTs);
                    break;
                case /* google.protobuf.Timestamp close_price_ts */ 22:
                    message.closePriceTs = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.closePriceTs);
                    break;
                case /* google.protobuf.Timestamp orderbook_ts */ 23:
                    message.orderbookTs = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.orderbookTs);
                    break;
                case /* string instrument_uid */ 9:
                    message.instrumentUid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetOrderBookResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* int32 depth = 2; */
        if (message.depth !== 0)
            writer.tag(2, WireType.Varint).int32(message.depth);
        /* repeated tinkoff.public.invest.api.contract.v1.Order bids = 3; */
        for (let i = 0; i < message.bids.length; i++)
            Order.internalBinaryWrite(message.bids[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated tinkoff.public.invest.api.contract.v1.Order asks = 4; */
        for (let i = 0; i < message.asks.length; i++)
            Order.internalBinaryWrite(message.asks[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation last_price = 5; */
        if (message.lastPrice)
            Quotation.internalBinaryWrite(message.lastPrice, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation close_price = 6; */
        if (message.closePrice)
            Quotation.internalBinaryWrite(message.closePrice, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation limit_up = 7; */
        if (message.limitUp)
            Quotation.internalBinaryWrite(message.limitUp, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation limit_down = 8; */
        if (message.limitDown)
            Quotation.internalBinaryWrite(message.limitDown, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_price_ts = 21; */
        if (message.lastPriceTs)
            Timestamp.internalBinaryWrite(message.lastPriceTs, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp close_price_ts = 22; */
        if (message.closePriceTs)
            Timestamp.internalBinaryWrite(message.closePriceTs, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp orderbook_ts = 23; */
        if (message.orderbookTs)
            Timestamp.internalBinaryWrite(message.orderbookTs, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        /* string instrument_uid = 9; */
        if (message.instrumentUid !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.instrumentUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetOrderBookResponse
 */
export const GetOrderBookResponse = new GetOrderBookResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTradingStatusRequest$Type extends MessageType<GetTradingStatusRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetTradingStatusRequest", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "instrument_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetTradingStatusRequest>): GetTradingStatusRequest {
        const message = { figi: "", instrumentId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetTradingStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTradingStatusRequest): GetTradingStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* string instrument_id */ 2:
                    message.instrumentId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTradingStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* string instrument_id = 2; */
        if (message.instrumentId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.instrumentId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetTradingStatusRequest
 */
export const GetTradingStatusRequest = new GetTradingStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTradingStatusesRequest$Type extends MessageType<GetTradingStatusesRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetTradingStatusesRequest", [
            { no: 1, name: "instrument_id", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetTradingStatusesRequest>): GetTradingStatusesRequest {
        const message = { instrumentId: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetTradingStatusesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTradingStatusesRequest): GetTradingStatusesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string instrument_id */ 1:
                    message.instrumentId.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTradingStatusesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string instrument_id = 1; */
        for (let i = 0; i < message.instrumentId.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.instrumentId[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetTradingStatusesRequest
 */
export const GetTradingStatusesRequest = new GetTradingStatusesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTradingStatusesResponse$Type extends MessageType<GetTradingStatusesResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetTradingStatusesResponse", [
            { no: 1, name: "trading_statuses", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GetTradingStatusResponse }
        ]);
    }
    create(value?: PartialMessage<GetTradingStatusesResponse>): GetTradingStatusesResponse {
        const message = { tradingStatuses: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetTradingStatusesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTradingStatusesResponse): GetTradingStatusesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.GetTradingStatusResponse trading_statuses */ 1:
                    message.tradingStatuses.push(GetTradingStatusResponse.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTradingStatusesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.GetTradingStatusResponse trading_statuses = 1; */
        for (let i = 0; i < message.tradingStatuses.length; i++)
            GetTradingStatusResponse.internalBinaryWrite(message.tradingStatuses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetTradingStatusesResponse
 */
export const GetTradingStatusesResponse = new GetTradingStatusesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTradingStatusResponse$Type extends MessageType<GetTradingStatusResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetTradingStatusResponse", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "trading_status", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.SecurityTradingStatus", SecurityTradingStatus, "SECURITY_TRADING_STATUS_"] },
            { no: 3, name: "limit_order_available_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "market_order_available_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "api_trade_available_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "instrument_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetTradingStatusResponse>): GetTradingStatusResponse {
        const message = { figi: "", tradingStatus: 0, limitOrderAvailableFlag: false, marketOrderAvailableFlag: false, apiTradeAvailableFlag: false, instrumentUid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetTradingStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTradingStatusResponse): GetTradingStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status */ 2:
                    message.tradingStatus = reader.int32();
                    break;
                case /* bool limit_order_available_flag */ 3:
                    message.limitOrderAvailableFlag = reader.bool();
                    break;
                case /* bool market_order_available_flag */ 4:
                    message.marketOrderAvailableFlag = reader.bool();
                    break;
                case /* bool api_trade_available_flag */ 5:
                    message.apiTradeAvailableFlag = reader.bool();
                    break;
                case /* string instrument_uid */ 6:
                    message.instrumentUid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTradingStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status = 2; */
        if (message.tradingStatus !== 0)
            writer.tag(2, WireType.Varint).int32(message.tradingStatus);
        /* bool limit_order_available_flag = 3; */
        if (message.limitOrderAvailableFlag !== false)
            writer.tag(3, WireType.Varint).bool(message.limitOrderAvailableFlag);
        /* bool market_order_available_flag = 4; */
        if (message.marketOrderAvailableFlag !== false)
            writer.tag(4, WireType.Varint).bool(message.marketOrderAvailableFlag);
        /* bool api_trade_available_flag = 5; */
        if (message.apiTradeAvailableFlag !== false)
            writer.tag(5, WireType.Varint).bool(message.apiTradeAvailableFlag);
        /* string instrument_uid = 6; */
        if (message.instrumentUid !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.instrumentUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetTradingStatusResponse
 */
export const GetTradingStatusResponse = new GetTradingStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetLastTradesRequest$Type extends MessageType<GetLastTradesRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetLastTradesRequest", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "from", kind: "message", T: () => Timestamp },
            { no: 3, name: "to", kind: "message", T: () => Timestamp },
            { no: 4, name: "instrument_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetLastTradesRequest>): GetLastTradesRequest {
        const message = { figi: "", instrumentId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetLastTradesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetLastTradesRequest): GetLastTradesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* google.protobuf.Timestamp from */ 2:
                    message.from = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.from);
                    break;
                case /* google.protobuf.Timestamp to */ 3:
                    message.to = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.to);
                    break;
                case /* string instrument_id */ 4:
                    message.instrumentId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetLastTradesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* google.protobuf.Timestamp from = 2; */
        if (message.from)
            Timestamp.internalBinaryWrite(message.from, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp to = 3; */
        if (message.to)
            Timestamp.internalBinaryWrite(message.to, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string instrument_id = 4; */
        if (message.instrumentId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.instrumentId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetLastTradesRequest
 */
export const GetLastTradesRequest = new GetLastTradesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetLastTradesResponse$Type extends MessageType<GetLastTradesResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetLastTradesResponse", [
            { no: 1, name: "trades", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Trade }
        ]);
    }
    create(value?: PartialMessage<GetLastTradesResponse>): GetLastTradesResponse {
        const message = { trades: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetLastTradesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetLastTradesResponse): GetLastTradesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.Trade trades */ 1:
                    message.trades.push(Trade.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetLastTradesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.Trade trades = 1; */
        for (let i = 0; i < message.trades.length; i++)
            Trade.internalBinaryWrite(message.trades[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetLastTradesResponse
 */
export const GetLastTradesResponse = new GetLastTradesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMySubscriptions$Type extends MessageType<GetMySubscriptions> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetMySubscriptions", []);
    }
    create(value?: PartialMessage<GetMySubscriptions>): GetMySubscriptions {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMySubscriptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMySubscriptions): GetMySubscriptions {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetMySubscriptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetMySubscriptions
 */
export const GetMySubscriptions = new GetMySubscriptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetClosePricesRequest$Type extends MessageType<GetClosePricesRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetClosePricesRequest", [
            { no: 1, name: "instruments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => InstrumentClosePriceRequest }
        ]);
    }
    create(value?: PartialMessage<GetClosePricesRequest>): GetClosePricesRequest {
        const message = { instruments: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetClosePricesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetClosePricesRequest): GetClosePricesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.InstrumentClosePriceRequest instruments */ 1:
                    message.instruments.push(InstrumentClosePriceRequest.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetClosePricesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.InstrumentClosePriceRequest instruments = 1; */
        for (let i = 0; i < message.instruments.length; i++)
            InstrumentClosePriceRequest.internalBinaryWrite(message.instruments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetClosePricesRequest
 */
export const GetClosePricesRequest = new GetClosePricesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstrumentClosePriceRequest$Type extends MessageType<InstrumentClosePriceRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.InstrumentClosePriceRequest", [
            { no: 1, name: "instrument_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<InstrumentClosePriceRequest>): InstrumentClosePriceRequest {
        const message = { instrumentId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InstrumentClosePriceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstrumentClosePriceRequest): InstrumentClosePriceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string instrument_id */ 1:
                    message.instrumentId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InstrumentClosePriceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string instrument_id = 1; */
        if (message.instrumentId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.instrumentId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.InstrumentClosePriceRequest
 */
export const InstrumentClosePriceRequest = new InstrumentClosePriceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetClosePricesResponse$Type extends MessageType<GetClosePricesResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetClosePricesResponse", [
            { no: 1, name: "close_prices", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => InstrumentClosePriceResponse }
        ]);
    }
    create(value?: PartialMessage<GetClosePricesResponse>): GetClosePricesResponse {
        const message = { closePrices: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetClosePricesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetClosePricesResponse): GetClosePricesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.InstrumentClosePriceResponse close_prices */ 1:
                    message.closePrices.push(InstrumentClosePriceResponse.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetClosePricesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.InstrumentClosePriceResponse close_prices = 1; */
        for (let i = 0; i < message.closePrices.length; i++)
            InstrumentClosePriceResponse.internalBinaryWrite(message.closePrices[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetClosePricesResponse
 */
export const GetClosePricesResponse = new GetClosePricesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstrumentClosePriceResponse$Type extends MessageType<InstrumentClosePriceResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.InstrumentClosePriceResponse", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "instrument_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "price", kind: "message", T: () => Quotation },
            { no: 21, name: "time", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<InstrumentClosePriceResponse>): InstrumentClosePriceResponse {
        const message = { figi: "", instrumentUid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InstrumentClosePriceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstrumentClosePriceResponse): InstrumentClosePriceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* string instrument_uid */ 2:
                    message.instrumentUid = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation price */ 11:
                    message.price = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.price);
                    break;
                case /* google.protobuf.Timestamp time */ 21:
                    message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InstrumentClosePriceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* string instrument_uid = 2; */
        if (message.instrumentUid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.instrumentUid);
        /* tinkoff.public.invest.api.contract.v1.Quotation price = 11; */
        if (message.price)
            Quotation.internalBinaryWrite(message.price, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp time = 21; */
        if (message.time)
            Timestamp.internalBinaryWrite(message.time, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.InstrumentClosePriceResponse
 */
export const InstrumentClosePriceResponse = new InstrumentClosePriceResponse$Type();
/**
 * @generated ServiceType for protobuf service tinkoff.public.invest.api.contract.v1.MarketDataService
 */
export const MarketDataService = new ServiceType("tinkoff.public.invest.api.contract.v1.MarketDataService", [
    { name: "GetCandles", options: {}, I: GetCandlesRequest, O: GetCandlesResponse },
    { name: "GetLastPrices", options: {}, I: GetLastPricesRequest, O: GetLastPricesResponse },
    { name: "GetOrderBook", options: {}, I: GetOrderBookRequest, O: GetOrderBookResponse },
    { name: "GetTradingStatus", options: {}, I: GetTradingStatusRequest, O: GetTradingStatusResponse },
    { name: "GetTradingStatuses", options: {}, I: GetTradingStatusesRequest, O: GetTradingStatusesResponse },
    { name: "GetLastTrades", options: {}, I: GetLastTradesRequest, O: GetLastTradesResponse },
    { name: "GetClosePrices", options: {}, I: GetClosePricesRequest, O: GetClosePricesResponse }
]);
/**
 * @generated ServiceType for protobuf service tinkoff.public.invest.api.contract.v1.MarketDataStreamService
 */
export const MarketDataStreamService = new ServiceType("tinkoff.public.invest.api.contract.v1.MarketDataStreamService", [
    { name: "MarketDataStream", serverStreaming: true, clientStreaming: true, options: {}, I: MarketDataRequest, O: MarketDataResponse },
    { name: "MarketDataServerSideStream", serverStreaming: true, options: {}, I: MarketDataServerSideStreamRequest, O: MarketDataResponse }
]);
