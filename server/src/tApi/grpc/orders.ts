// @generated by protobuf-ts 2.8.2
// @generated from protobuf file "orders.proto" (package "tinkoff.public.invest.api.contract.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { MoneyValue } from "./common.js";
import { Quotation } from "./common.js";
import { Timestamp } from "./google/protobuf/timestamp.js";
import { Ping } from "./common.js";
/**
 * Запрос установки соединения.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.TradesStreamRequest
 */
export interface TradesStreamRequest {
    /**
     * @generated from protobuf field: repeated string accounts = 1;
     */
    accounts: string[]; // Идентификаторы счетов.
}
/**
 * Информация о торговых поручениях.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.TradesStreamResponse
 */
export interface TradesStreamResponse {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "orderTrades";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.OrderTrades order_trades = 1;
         */
        orderTrades: OrderTrades; // Информация об исполнении торгового поручения.
    } | {
        oneofKind: "ping";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Ping ping = 2;
         */
        ping: Ping; // Проверка активности стрима.
    } | {
        oneofKind: undefined;
    };
}
/**
 * Информация об исполнении торгового поручения.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.OrderTrades
 */
export interface OrderTrades {
    /**
     * @generated from protobuf field: string order_id = 1;
     */
    orderId: string; // Идентификатор торгового поручения.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 2;
     */
    createdAt?: Timestamp; // Дата и время создания сообщения в часовом поясе UTC.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.OrderDirection direction = 3;
     */
    direction: OrderDirection; // Направление сделки.
    /**
     * @generated from protobuf field: string figi = 4;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.OrderTrade trades = 5;
     */
    trades: OrderTrade[]; // Массив сделок.
    /**
     * @generated from protobuf field: string account_id = 6;
     */
    accountId: string; // Идентификатор счёта.
    /**
     * @generated from protobuf field: string instrument_uid = 7;
     */
    instrumentUid: string; // UID идентификатор инструмента.
}
/**
 * Информация о сделке.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.OrderTrade
 */
export interface OrderTrade {
    /**
     * @generated from protobuf field: google.protobuf.Timestamp date_time = 1;
     */
    dateTime?: Timestamp; // Дата и время совершения сделки в часовом поясе UTC.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation price = 2;
     */
    price?: Quotation; // Цена за 1 инструмент, по которой совершена сделка.
    /**
     * @generated from protobuf field: int64 quantity = 3;
     */
    quantity: bigint; // Количество штук в сделке.
    /**
     * @generated from protobuf field: string trade_id = 4;
     */
    tradeId: string; // Идентификатор сделки.
}
/**
 * Запрос выставления торгового поручения.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.PostOrderRequest
 */
export interface PostOrderRequest {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: int64 quantity = 2;
     */
    quantity: bigint; // Количество лотов.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation price = 3;
     */
    price?: Quotation; // Цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Игнорируется для рыночных поручений.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.OrderDirection direction = 4;
     */
    direction: OrderDirection; // Направление операции.
    /**
     * @generated from protobuf field: string account_id = 5;
     */
    accountId: string; // Номер счёта.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.OrderType order_type = 6;
     */
    orderType: OrderType; // Тип заявки.
    /**
     * @generated from protobuf field: string order_id = 7;
     */
    orderId: string; // Идентификатор запроса выставления поручения для целей идемпотентности. Максимальная длина 36 символов.
    /**
     * @generated from protobuf field: string instrument_id = 8;
     */
    instrumentId: string; // Идентификатор инструмента, принимает значения Figi или Instrument_uid.
}
/**
 * Информация о выставлении поручения.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.PostOrderResponse
 */
export interface PostOrderResponse {
    /**
     * @generated from protobuf field: string order_id = 1;
     */
    orderId: string; // Идентификатор заявки.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.OrderExecutionReportStatus execution_report_status = 2;
     */
    executionReportStatus: OrderExecutionReportStatus; // Текущий статус заявки.
    /**
     * @generated from protobuf field: int64 lots_requested = 3;
     */
    lotsRequested: bigint; // Запрошено лотов.
    /**
     * @generated from protobuf field: int64 lots_executed = 4;
     */
    lotsExecuted: bigint; // Исполнено лотов.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue initial_order_price = 5;
     */
    initialOrderPrice?: MoneyValue; // Начальная цена заявки. Произведение количества запрошенных лотов на цену.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue executed_order_price = 6;
     */
    executedOrderPrice?: MoneyValue; // Исполненная средняя цена 1 одного инструмента в заявки.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue total_order_amount = 7;
     */
    totalOrderAmount?: MoneyValue; // Итоговая стоимость заявки, включающая все комиссии.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue initial_commission = 8;
     */
    initialCommission?: MoneyValue; // Начальная комиссия. Комиссия рассчитанная при выставлении заявки.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue executed_commission = 9;
     */
    executedCommission?: MoneyValue; // Фактическая комиссия по итогам исполнения заявки.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue aci_value = 10;
     */
    aciValue?: MoneyValue; // Значение НКД (накопленного купонного дохода) на дату. Подробнее: [НКД при выставлении торговых поручений](https://tinkoff.github.io/investAPI/head-orders#coupon)
    /**
     * @generated from protobuf field: string figi = 11;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.OrderDirection direction = 12;
     */
    direction: OrderDirection; // Направление сделки.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue initial_security_price = 13;
     */
    initialSecurityPrice?: MoneyValue; // Начальная цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.OrderType order_type = 14;
     */
    orderType: OrderType; // Тип заявки.
    /**
     * @generated from protobuf field: string message = 15;
     */
    message: string; // Дополнительные данные об исполнении заявки.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation initial_order_price_pt = 16;
     */
    initialOrderPricePt?: Quotation; // Начальная цена заявки в пунктах (для фьючерсов).
    /**
     * @generated from protobuf field: string instrument_uid = 17;
     */
    instrumentUid: string; // UID идентификатор инструмента.
}
/**
 * Запрос отмены торгового поручения.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.CancelOrderRequest
 */
export interface CancelOrderRequest {
    /**
     * @generated from protobuf field: string account_id = 1;
     */
    accountId: string; // Номер счёта.
    /**
     * @generated from protobuf field: string order_id = 2;
     */
    orderId: string; // Идентификатор заявки.
}
/**
 * Результат отмены торгового поручения.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.CancelOrderResponse
 */
export interface CancelOrderResponse {
    /**
     * @generated from protobuf field: google.protobuf.Timestamp time = 1;
     */
    time?: Timestamp; // Дата и время отмены заявки в часовом поясе UTC.
}
/**
 * Запрос получения статуса торгового поручения.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetOrderStateRequest
 */
export interface GetOrderStateRequest {
    /**
     * @generated from protobuf field: string account_id = 1;
     */
    accountId: string; // Номер счёта.
    /**
     * @generated from protobuf field: string order_id = 2;
     */
    orderId: string; // Идентификатор заявки.
}
/**
 * Запрос получения списка активных торговых поручений.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetOrdersRequest
 */
export interface GetOrdersRequest {
    /**
     * @generated from protobuf field: string account_id = 1;
     */
    accountId: string; // Номер счёта.
}
/**
 * Список активных торговых поручений.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetOrdersResponse
 */
export interface GetOrdersResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.OrderState orders = 1;
     */
    orders: OrderState[]; // Массив активных заявок.
}
/**
 * Информация о торговом поручении.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.OrderState
 */
export interface OrderState {
    /**
     * @generated from protobuf field: string order_id = 1;
     */
    orderId: string; // Идентификатор заявки.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.OrderExecutionReportStatus execution_report_status = 2;
     */
    executionReportStatus: OrderExecutionReportStatus; // Текущий статус заявки.
    /**
     * @generated from protobuf field: int64 lots_requested = 3;
     */
    lotsRequested: bigint; // Запрошено лотов.
    /**
     * @generated from protobuf field: int64 lots_executed = 4;
     */
    lotsExecuted: bigint; // Исполнено лотов.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue initial_order_price = 5;
     */
    initialOrderPrice?: MoneyValue; // Начальная цена заявки. Произведение количества запрошенных лотов на цену.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue executed_order_price = 6;
     */
    executedOrderPrice?: MoneyValue; // Исполненная цена заявки. Произведение средней цены покупки на количество лотов.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue total_order_amount = 7;
     */
    totalOrderAmount?: MoneyValue; // Итоговая стоимость заявки, включающая все комиссии.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue average_position_price = 8;
     */
    averagePositionPrice?: MoneyValue; // Средняя цена позиции по сделке.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue initial_commission = 9;
     */
    initialCommission?: MoneyValue; // Начальная комиссия. Комиссия, рассчитанная на момент подачи заявки.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue executed_commission = 10;
     */
    executedCommission?: MoneyValue; // Фактическая комиссия по итогам исполнения заявки.
    /**
     * @generated from protobuf field: string figi = 11;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.OrderDirection direction = 12;
     */
    direction: OrderDirection; // Направление заявки.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue initial_security_price = 13;
     */
    initialSecurityPrice?: MoneyValue; // Начальная цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента.
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.OrderStage stages = 14;
     */
    stages: OrderStage[]; // Стадии выполнения заявки.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue service_commission = 15;
     */
    serviceCommission?: MoneyValue; // Сервисная комиссия.
    /**
     * @generated from protobuf field: string currency = 16;
     */
    currency: string; // Валюта заявки.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.OrderType order_type = 17;
     */
    orderType: OrderType; // Тип заявки.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp order_date = 18;
     */
    orderDate?: Timestamp; // Дата и время выставления заявки в часовом поясе UTC.
    /**
     * @generated from protobuf field: string instrument_uid = 19;
     */
    instrumentUid: string; // UID идентификатор инструмента.
}
/**
 * Сделки в рамках торгового поручения.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.OrderStage
 */
export interface OrderStage {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue price = 1;
     */
    price?: MoneyValue; // Цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента..
    /**
     * @generated from protobuf field: int64 quantity = 2;
     */
    quantity: bigint; // Количество лотов.
    /**
     * @generated from protobuf field: string trade_id = 3;
     */
    tradeId: string; // Идентификатор сделки.
}
/**
 * Запрос изменения выставленной заявки.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.ReplaceOrderRequest
 */
export interface ReplaceOrderRequest {
    /**
     * @generated from protobuf field: string account_id = 1;
     */
    accountId: string; // Номер счета.
    /**
     * @generated from protobuf field: string order_id = 6;
     */
    orderId: string; // Идентификатор заявки на бирже.
    /**
     * @generated from protobuf field: string idempotency_key = 7;
     */
    idempotencyKey: string; // Новый идентификатор запроса выставления поручения для целей идемпотентности. Максимальная длина 36 символов. Перезатирает старый ключ.
    /**
     * @generated from protobuf field: int64 quantity = 11;
     */
    quantity: bigint; // Количество лотов.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation price = 12;
     */
    price?: Quotation; // Цена за 1 инструмент.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.PriceType price_type = 13;
     */
    priceType: PriceType; // Тип цены.
}
/**
 * Направление операции.
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.OrderDirection
 */
export enum OrderDirection {
    /**
     * Значение не указано
     *
     * @generated from protobuf enum value: ORDER_DIRECTION_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Покупка
     *
     * @generated from protobuf enum value: ORDER_DIRECTION_BUY = 1;
     */
    BUY = 1,
    /**
     * Продажа
     *
     * @generated from protobuf enum value: ORDER_DIRECTION_SELL = 2;
     */
    SELL = 2
}
/**
 * Тип заявки.
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.OrderType
 */
export enum OrderType {
    /**
     * Значение не указано
     *
     * @generated from protobuf enum value: ORDER_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Лимитная
     *
     * @generated from protobuf enum value: ORDER_TYPE_LIMIT = 1;
     */
    LIMIT = 1,
    /**
     * Рыночная
     *
     * @generated from protobuf enum value: ORDER_TYPE_MARKET = 2;
     */
    MARKET = 2
}
/**
 * Текущий статус заявки (поручения)
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.OrderExecutionReportStatus
 */
export enum OrderExecutionReportStatus {
    /**
     * @generated from protobuf enum value: EXECUTION_REPORT_STATUS_UNSPECIFIED = 0;
     */
    EXECUTION_REPORT_STATUS_UNSPECIFIED = 0,
    /**
     * Исполнена
     *
     * @generated from protobuf enum value: EXECUTION_REPORT_STATUS_FILL = 1;
     */
    EXECUTION_REPORT_STATUS_FILL = 1,
    /**
     * Отклонена
     *
     * @generated from protobuf enum value: EXECUTION_REPORT_STATUS_REJECTED = 2;
     */
    EXECUTION_REPORT_STATUS_REJECTED = 2,
    /**
     * Отменена пользователем
     *
     * @generated from protobuf enum value: EXECUTION_REPORT_STATUS_CANCELLED = 3;
     */
    EXECUTION_REPORT_STATUS_CANCELLED = 3,
    /**
     * Новая
     *
     * @generated from protobuf enum value: EXECUTION_REPORT_STATUS_NEW = 4;
     */
    EXECUTION_REPORT_STATUS_NEW = 4,
    /**
     * Частично исполнена
     *
     * @generated from protobuf enum value: EXECUTION_REPORT_STATUS_PARTIALLYFILL = 5;
     */
    EXECUTION_REPORT_STATUS_PARTIALLYFILL = 5
}
/**
 * Тип цены.
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.PriceType
 */
export enum PriceType {
    /**
     * Значение не определено.
     *
     * @generated from protobuf enum value: PRICE_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Цена в пунктах (только для фьючерсов и облигаций).
     *
     * @generated from protobuf enum value: PRICE_TYPE_POINT = 1;
     */
    POINT = 1,
    /**
     * Цена в валюте расчётов по инструменту.
     *
     * @generated from protobuf enum value: PRICE_TYPE_CURRENCY = 2;
     */
    CURRENCY = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class TradesStreamRequest$Type extends MessageType<TradesStreamRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.TradesStreamRequest", [
            { no: 1, name: "accounts", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TradesStreamRequest>): TradesStreamRequest {
        const message = { accounts: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TradesStreamRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradesStreamRequest): TradesStreamRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string accounts */ 1:
                    message.accounts.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradesStreamRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string accounts = 1; */
        for (let i = 0; i < message.accounts.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.accounts[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.TradesStreamRequest
 */
export const TradesStreamRequest = new TradesStreamRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradesStreamResponse$Type extends MessageType<TradesStreamResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.TradesStreamResponse", [
            { no: 1, name: "order_trades", kind: "message", oneof: "payload", T: () => OrderTrades },
            { no: 2, name: "ping", kind: "message", oneof: "payload", T: () => Ping }
        ]);
    }
    create(value?: PartialMessage<TradesStreamResponse>): TradesStreamResponse {
        const message = { payload: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TradesStreamResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradesStreamResponse): TradesStreamResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.OrderTrades order_trades */ 1:
                    message.payload = {
                        oneofKind: "orderTrades",
                        orderTrades: OrderTrades.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).orderTrades)
                    };
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Ping ping */ 2:
                    message.payload = {
                        oneofKind: "ping",
                        ping: Ping.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).ping)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradesStreamResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.OrderTrades order_trades = 1; */
        if (message.payload.oneofKind === "orderTrades")
            OrderTrades.internalBinaryWrite(message.payload.orderTrades, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Ping ping = 2; */
        if (message.payload.oneofKind === "ping")
            Ping.internalBinaryWrite(message.payload.ping, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.TradesStreamResponse
 */
export const TradesStreamResponse = new TradesStreamResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderTrades$Type extends MessageType<OrderTrades> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.OrderTrades", [
            { no: 1, name: "order_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "created_at", kind: "message", T: () => Timestamp },
            { no: 3, name: "direction", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.OrderDirection", OrderDirection, "ORDER_DIRECTION_"] },
            { no: 4, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "trades", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => OrderTrade },
            { no: 6, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "instrument_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OrderTrades>): OrderTrades {
        const message = { orderId: "", direction: 0, figi: "", trades: [], accountId: "", instrumentUid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OrderTrades>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderTrades): OrderTrades {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string order_id */ 1:
                    message.orderId = reader.string();
                    break;
                case /* google.protobuf.Timestamp created_at */ 2:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.OrderDirection direction */ 3:
                    message.direction = reader.int32();
                    break;
                case /* string figi */ 4:
                    message.figi = reader.string();
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.OrderTrade trades */ 5:
                    message.trades.push(OrderTrade.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string account_id */ 6:
                    message.accountId = reader.string();
                    break;
                case /* string instrument_uid */ 7:
                    message.instrumentUid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderTrades, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string order_id = 1; */
        if (message.orderId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orderId);
        /* google.protobuf.Timestamp created_at = 2; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.OrderDirection direction = 3; */
        if (message.direction !== 0)
            writer.tag(3, WireType.Varint).int32(message.direction);
        /* string figi = 4; */
        if (message.figi !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.figi);
        /* repeated tinkoff.public.invest.api.contract.v1.OrderTrade trades = 5; */
        for (let i = 0; i < message.trades.length; i++)
            OrderTrade.internalBinaryWrite(message.trades[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string account_id = 6; */
        if (message.accountId !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.accountId);
        /* string instrument_uid = 7; */
        if (message.instrumentUid !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.instrumentUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.OrderTrades
 */
export const OrderTrades = new OrderTrades$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderTrade$Type extends MessageType<OrderTrade> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.OrderTrade", [
            { no: 1, name: "date_time", kind: "message", T: () => Timestamp },
            { no: 2, name: "price", kind: "message", T: () => Quotation },
            { no: 3, name: "quantity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "trade_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OrderTrade>): OrderTrade {
        const message = { quantity: 0n, tradeId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OrderTrade>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderTrade): OrderTrade {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp date_time */ 1:
                    message.dateTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.dateTime);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation price */ 2:
                    message.price = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.price);
                    break;
                case /* int64 quantity */ 3:
                    message.quantity = reader.int64().toBigInt();
                    break;
                case /* string trade_id */ 4:
                    message.tradeId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderTrade, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp date_time = 1; */
        if (message.dateTime)
            Timestamp.internalBinaryWrite(message.dateTime, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation price = 2; */
        if (message.price)
            Quotation.internalBinaryWrite(message.price, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int64 quantity = 3; */
        if (message.quantity !== 0n)
            writer.tag(3, WireType.Varint).int64(message.quantity);
        /* string trade_id = 4; */
        if (message.tradeId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.tradeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.OrderTrade
 */
export const OrderTrade = new OrderTrade$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PostOrderRequest$Type extends MessageType<PostOrderRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.PostOrderRequest", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "price", kind: "message", T: () => Quotation },
            { no: 4, name: "direction", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.OrderDirection", OrderDirection, "ORDER_DIRECTION_"] },
            { no: 5, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "order_type", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.OrderType", OrderType, "ORDER_TYPE_"] },
            { no: 7, name: "order_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "instrument_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PostOrderRequest>): PostOrderRequest {
        const message = { figi: "", quantity: 0n, direction: 0, accountId: "", orderType: 0, orderId: "", instrumentId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PostOrderRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PostOrderRequest): PostOrderRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* int64 quantity */ 2:
                    message.quantity = reader.int64().toBigInt();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation price */ 3:
                    message.price = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.price);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.OrderDirection direction */ 4:
                    message.direction = reader.int32();
                    break;
                case /* string account_id */ 5:
                    message.accountId = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.OrderType order_type */ 6:
                    message.orderType = reader.int32();
                    break;
                case /* string order_id */ 7:
                    message.orderId = reader.string();
                    break;
                case /* string instrument_id */ 8:
                    message.instrumentId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PostOrderRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* int64 quantity = 2; */
        if (message.quantity !== 0n)
            writer.tag(2, WireType.Varint).int64(message.quantity);
        /* tinkoff.public.invest.api.contract.v1.Quotation price = 3; */
        if (message.price)
            Quotation.internalBinaryWrite(message.price, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.OrderDirection direction = 4; */
        if (message.direction !== 0)
            writer.tag(4, WireType.Varint).int32(message.direction);
        /* string account_id = 5; */
        if (message.accountId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.accountId);
        /* tinkoff.public.invest.api.contract.v1.OrderType order_type = 6; */
        if (message.orderType !== 0)
            writer.tag(6, WireType.Varint).int32(message.orderType);
        /* string order_id = 7; */
        if (message.orderId !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.orderId);
        /* string instrument_id = 8; */
        if (message.instrumentId !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.instrumentId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.PostOrderRequest
 */
export const PostOrderRequest = new PostOrderRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PostOrderResponse$Type extends MessageType<PostOrderResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.PostOrderResponse", [
            { no: 1, name: "order_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "execution_report_status", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.OrderExecutionReportStatus", OrderExecutionReportStatus] },
            { no: 3, name: "lots_requested", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "lots_executed", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "initial_order_price", kind: "message", T: () => MoneyValue },
            { no: 6, name: "executed_order_price", kind: "message", T: () => MoneyValue },
            { no: 7, name: "total_order_amount", kind: "message", T: () => MoneyValue },
            { no: 8, name: "initial_commission", kind: "message", T: () => MoneyValue },
            { no: 9, name: "executed_commission", kind: "message", T: () => MoneyValue },
            { no: 10, name: "aci_value", kind: "message", T: () => MoneyValue },
            { no: 11, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "direction", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.OrderDirection", OrderDirection, "ORDER_DIRECTION_"] },
            { no: 13, name: "initial_security_price", kind: "message", T: () => MoneyValue },
            { no: 14, name: "order_type", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.OrderType", OrderType, "ORDER_TYPE_"] },
            { no: 15, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "initial_order_price_pt", kind: "message", T: () => Quotation },
            { no: 17, name: "instrument_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PostOrderResponse>): PostOrderResponse {
        const message = { orderId: "", executionReportStatus: 0, lotsRequested: 0n, lotsExecuted: 0n, figi: "", direction: 0, orderType: 0, message: "", instrumentUid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PostOrderResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PostOrderResponse): PostOrderResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string order_id */ 1:
                    message.orderId = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.OrderExecutionReportStatus execution_report_status */ 2:
                    message.executionReportStatus = reader.int32();
                    break;
                case /* int64 lots_requested */ 3:
                    message.lotsRequested = reader.int64().toBigInt();
                    break;
                case /* int64 lots_executed */ 4:
                    message.lotsExecuted = reader.int64().toBigInt();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue initial_order_price */ 5:
                    message.initialOrderPrice = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.initialOrderPrice);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue executed_order_price */ 6:
                    message.executedOrderPrice = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.executedOrderPrice);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue total_order_amount */ 7:
                    message.totalOrderAmount = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.totalOrderAmount);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue initial_commission */ 8:
                    message.initialCommission = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.initialCommission);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue executed_commission */ 9:
                    message.executedCommission = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.executedCommission);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue aci_value */ 10:
                    message.aciValue = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.aciValue);
                    break;
                case /* string figi */ 11:
                    message.figi = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.OrderDirection direction */ 12:
                    message.direction = reader.int32();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue initial_security_price */ 13:
                    message.initialSecurityPrice = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.initialSecurityPrice);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.OrderType order_type */ 14:
                    message.orderType = reader.int32();
                    break;
                case /* string message */ 15:
                    message.message = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation initial_order_price_pt */ 16:
                    message.initialOrderPricePt = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.initialOrderPricePt);
                    break;
                case /* string instrument_uid */ 17:
                    message.instrumentUid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PostOrderResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string order_id = 1; */
        if (message.orderId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orderId);
        /* tinkoff.public.invest.api.contract.v1.OrderExecutionReportStatus execution_report_status = 2; */
        if (message.executionReportStatus !== 0)
            writer.tag(2, WireType.Varint).int32(message.executionReportStatus);
        /* int64 lots_requested = 3; */
        if (message.lotsRequested !== 0n)
            writer.tag(3, WireType.Varint).int64(message.lotsRequested);
        /* int64 lots_executed = 4; */
        if (message.lotsExecuted !== 0n)
            writer.tag(4, WireType.Varint).int64(message.lotsExecuted);
        /* tinkoff.public.invest.api.contract.v1.MoneyValue initial_order_price = 5; */
        if (message.initialOrderPrice)
            MoneyValue.internalBinaryWrite(message.initialOrderPrice, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue executed_order_price = 6; */
        if (message.executedOrderPrice)
            MoneyValue.internalBinaryWrite(message.executedOrderPrice, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue total_order_amount = 7; */
        if (message.totalOrderAmount)
            MoneyValue.internalBinaryWrite(message.totalOrderAmount, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue initial_commission = 8; */
        if (message.initialCommission)
            MoneyValue.internalBinaryWrite(message.initialCommission, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue executed_commission = 9; */
        if (message.executedCommission)
            MoneyValue.internalBinaryWrite(message.executedCommission, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue aci_value = 10; */
        if (message.aciValue)
            MoneyValue.internalBinaryWrite(message.aciValue, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* string figi = 11; */
        if (message.figi !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.figi);
        /* tinkoff.public.invest.api.contract.v1.OrderDirection direction = 12; */
        if (message.direction !== 0)
            writer.tag(12, WireType.Varint).int32(message.direction);
        /* tinkoff.public.invest.api.contract.v1.MoneyValue initial_security_price = 13; */
        if (message.initialSecurityPrice)
            MoneyValue.internalBinaryWrite(message.initialSecurityPrice, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.OrderType order_type = 14; */
        if (message.orderType !== 0)
            writer.tag(14, WireType.Varint).int32(message.orderType);
        /* string message = 15; */
        if (message.message !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.message);
        /* tinkoff.public.invest.api.contract.v1.Quotation initial_order_price_pt = 16; */
        if (message.initialOrderPricePt)
            Quotation.internalBinaryWrite(message.initialOrderPricePt, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* string instrument_uid = 17; */
        if (message.instrumentUid !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.instrumentUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.PostOrderResponse
 */
export const PostOrderResponse = new PostOrderResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CancelOrderRequest$Type extends MessageType<CancelOrderRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.CancelOrderRequest", [
            { no: 1, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CancelOrderRequest>): CancelOrderRequest {
        const message = { accountId: "", orderId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CancelOrderRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CancelOrderRequest): CancelOrderRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_id */ 1:
                    message.accountId = reader.string();
                    break;
                case /* string order_id */ 2:
                    message.orderId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CancelOrderRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_id = 1; */
        if (message.accountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountId);
        /* string order_id = 2; */
        if (message.orderId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.orderId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.CancelOrderRequest
 */
export const CancelOrderRequest = new CancelOrderRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CancelOrderResponse$Type extends MessageType<CancelOrderResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.CancelOrderResponse", [
            { no: 1, name: "time", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<CancelOrderResponse>): CancelOrderResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CancelOrderResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CancelOrderResponse): CancelOrderResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp time */ 1:
                    message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CancelOrderResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp time = 1; */
        if (message.time)
            Timestamp.internalBinaryWrite(message.time, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.CancelOrderResponse
 */
export const CancelOrderResponse = new CancelOrderResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetOrderStateRequest$Type extends MessageType<GetOrderStateRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetOrderStateRequest", [
            { no: 1, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetOrderStateRequest>): GetOrderStateRequest {
        const message = { accountId: "", orderId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetOrderStateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetOrderStateRequest): GetOrderStateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_id */ 1:
                    message.accountId = reader.string();
                    break;
                case /* string order_id */ 2:
                    message.orderId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetOrderStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_id = 1; */
        if (message.accountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountId);
        /* string order_id = 2; */
        if (message.orderId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.orderId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetOrderStateRequest
 */
export const GetOrderStateRequest = new GetOrderStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetOrdersRequest$Type extends MessageType<GetOrdersRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetOrdersRequest", [
            { no: 1, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetOrdersRequest>): GetOrdersRequest {
        const message = { accountId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetOrdersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetOrdersRequest): GetOrdersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_id */ 1:
                    message.accountId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetOrdersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_id = 1; */
        if (message.accountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetOrdersRequest
 */
export const GetOrdersRequest = new GetOrdersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetOrdersResponse$Type extends MessageType<GetOrdersResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetOrdersResponse", [
            { no: 1, name: "orders", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => OrderState }
        ]);
    }
    create(value?: PartialMessage<GetOrdersResponse>): GetOrdersResponse {
        const message = { orders: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetOrdersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetOrdersResponse): GetOrdersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.OrderState orders */ 1:
                    message.orders.push(OrderState.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetOrdersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.OrderState orders = 1; */
        for (let i = 0; i < message.orders.length; i++)
            OrderState.internalBinaryWrite(message.orders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetOrdersResponse
 */
export const GetOrdersResponse = new GetOrdersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderState$Type extends MessageType<OrderState> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.OrderState", [
            { no: 1, name: "order_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "execution_report_status", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.OrderExecutionReportStatus", OrderExecutionReportStatus] },
            { no: 3, name: "lots_requested", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "lots_executed", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "initial_order_price", kind: "message", T: () => MoneyValue },
            { no: 6, name: "executed_order_price", kind: "message", T: () => MoneyValue },
            { no: 7, name: "total_order_amount", kind: "message", T: () => MoneyValue },
            { no: 8, name: "average_position_price", kind: "message", T: () => MoneyValue },
            { no: 9, name: "initial_commission", kind: "message", T: () => MoneyValue },
            { no: 10, name: "executed_commission", kind: "message", T: () => MoneyValue },
            { no: 11, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "direction", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.OrderDirection", OrderDirection, "ORDER_DIRECTION_"] },
            { no: 13, name: "initial_security_price", kind: "message", T: () => MoneyValue },
            { no: 14, name: "stages", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => OrderStage },
            { no: 15, name: "service_commission", kind: "message", T: () => MoneyValue },
            { no: 16, name: "currency", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "order_type", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.OrderType", OrderType, "ORDER_TYPE_"] },
            { no: 18, name: "order_date", kind: "message", T: () => Timestamp },
            { no: 19, name: "instrument_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OrderState>): OrderState {
        const message = { orderId: "", executionReportStatus: 0, lotsRequested: 0n, lotsExecuted: 0n, figi: "", direction: 0, stages: [], currency: "", orderType: 0, instrumentUid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OrderState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderState): OrderState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string order_id */ 1:
                    message.orderId = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.OrderExecutionReportStatus execution_report_status */ 2:
                    message.executionReportStatus = reader.int32();
                    break;
                case /* int64 lots_requested */ 3:
                    message.lotsRequested = reader.int64().toBigInt();
                    break;
                case /* int64 lots_executed */ 4:
                    message.lotsExecuted = reader.int64().toBigInt();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue initial_order_price */ 5:
                    message.initialOrderPrice = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.initialOrderPrice);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue executed_order_price */ 6:
                    message.executedOrderPrice = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.executedOrderPrice);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue total_order_amount */ 7:
                    message.totalOrderAmount = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.totalOrderAmount);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue average_position_price */ 8:
                    message.averagePositionPrice = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.averagePositionPrice);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue initial_commission */ 9:
                    message.initialCommission = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.initialCommission);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue executed_commission */ 10:
                    message.executedCommission = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.executedCommission);
                    break;
                case /* string figi */ 11:
                    message.figi = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.OrderDirection direction */ 12:
                    message.direction = reader.int32();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue initial_security_price */ 13:
                    message.initialSecurityPrice = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.initialSecurityPrice);
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.OrderStage stages */ 14:
                    message.stages.push(OrderStage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue service_commission */ 15:
                    message.serviceCommission = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.serviceCommission);
                    break;
                case /* string currency */ 16:
                    message.currency = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.OrderType order_type */ 17:
                    message.orderType = reader.int32();
                    break;
                case /* google.protobuf.Timestamp order_date */ 18:
                    message.orderDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.orderDate);
                    break;
                case /* string instrument_uid */ 19:
                    message.instrumentUid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string order_id = 1; */
        if (message.orderId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.orderId);
        /* tinkoff.public.invest.api.contract.v1.OrderExecutionReportStatus execution_report_status = 2; */
        if (message.executionReportStatus !== 0)
            writer.tag(2, WireType.Varint).int32(message.executionReportStatus);
        /* int64 lots_requested = 3; */
        if (message.lotsRequested !== 0n)
            writer.tag(3, WireType.Varint).int64(message.lotsRequested);
        /* int64 lots_executed = 4; */
        if (message.lotsExecuted !== 0n)
            writer.tag(4, WireType.Varint).int64(message.lotsExecuted);
        /* tinkoff.public.invest.api.contract.v1.MoneyValue initial_order_price = 5; */
        if (message.initialOrderPrice)
            MoneyValue.internalBinaryWrite(message.initialOrderPrice, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue executed_order_price = 6; */
        if (message.executedOrderPrice)
            MoneyValue.internalBinaryWrite(message.executedOrderPrice, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue total_order_amount = 7; */
        if (message.totalOrderAmount)
            MoneyValue.internalBinaryWrite(message.totalOrderAmount, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue average_position_price = 8; */
        if (message.averagePositionPrice)
            MoneyValue.internalBinaryWrite(message.averagePositionPrice, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue initial_commission = 9; */
        if (message.initialCommission)
            MoneyValue.internalBinaryWrite(message.initialCommission, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue executed_commission = 10; */
        if (message.executedCommission)
            MoneyValue.internalBinaryWrite(message.executedCommission, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* string figi = 11; */
        if (message.figi !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.figi);
        /* tinkoff.public.invest.api.contract.v1.OrderDirection direction = 12; */
        if (message.direction !== 0)
            writer.tag(12, WireType.Varint).int32(message.direction);
        /* tinkoff.public.invest.api.contract.v1.MoneyValue initial_security_price = 13; */
        if (message.initialSecurityPrice)
            MoneyValue.internalBinaryWrite(message.initialSecurityPrice, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* repeated tinkoff.public.invest.api.contract.v1.OrderStage stages = 14; */
        for (let i = 0; i < message.stages.length; i++)
            OrderStage.internalBinaryWrite(message.stages[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue service_commission = 15; */
        if (message.serviceCommission)
            MoneyValue.internalBinaryWrite(message.serviceCommission, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* string currency = 16; */
        if (message.currency !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.currency);
        /* tinkoff.public.invest.api.contract.v1.OrderType order_type = 17; */
        if (message.orderType !== 0)
            writer.tag(17, WireType.Varint).int32(message.orderType);
        /* google.protobuf.Timestamp order_date = 18; */
        if (message.orderDate)
            Timestamp.internalBinaryWrite(message.orderDate, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* string instrument_uid = 19; */
        if (message.instrumentUid !== "")
            writer.tag(19, WireType.LengthDelimited).string(message.instrumentUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.OrderState
 */
export const OrderState = new OrderState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderStage$Type extends MessageType<OrderStage> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.OrderStage", [
            { no: 1, name: "price", kind: "message", T: () => MoneyValue },
            { no: 2, name: "quantity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "trade_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OrderStage>): OrderStage {
        const message = { quantity: 0n, tradeId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OrderStage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderStage): OrderStage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue price */ 1:
                    message.price = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.price);
                    break;
                case /* int64 quantity */ 2:
                    message.quantity = reader.int64().toBigInt();
                    break;
                case /* string trade_id */ 3:
                    message.tradeId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderStage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.MoneyValue price = 1; */
        if (message.price)
            MoneyValue.internalBinaryWrite(message.price, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 quantity = 2; */
        if (message.quantity !== 0n)
            writer.tag(2, WireType.Varint).int64(message.quantity);
        /* string trade_id = 3; */
        if (message.tradeId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.tradeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.OrderStage
 */
export const OrderStage = new OrderStage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReplaceOrderRequest$Type extends MessageType<ReplaceOrderRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.ReplaceOrderRequest", [
            { no: 1, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "order_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "idempotency_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "quantity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "price", kind: "message", T: () => Quotation },
            { no: 13, name: "price_type", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.PriceType", PriceType, "PRICE_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<ReplaceOrderRequest>): ReplaceOrderRequest {
        const message = { accountId: "", orderId: "", idempotencyKey: "", quantity: 0n, priceType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReplaceOrderRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReplaceOrderRequest): ReplaceOrderRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_id */ 1:
                    message.accountId = reader.string();
                    break;
                case /* string order_id */ 6:
                    message.orderId = reader.string();
                    break;
                case /* string idempotency_key */ 7:
                    message.idempotencyKey = reader.string();
                    break;
                case /* int64 quantity */ 11:
                    message.quantity = reader.int64().toBigInt();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation price */ 12:
                    message.price = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.price);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.PriceType price_type */ 13:
                    message.priceType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReplaceOrderRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_id = 1; */
        if (message.accountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountId);
        /* string order_id = 6; */
        if (message.orderId !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.orderId);
        /* string idempotency_key = 7; */
        if (message.idempotencyKey !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.idempotencyKey);
        /* int64 quantity = 11; */
        if (message.quantity !== 0n)
            writer.tag(11, WireType.Varint).int64(message.quantity);
        /* tinkoff.public.invest.api.contract.v1.Quotation price = 12; */
        if (message.price)
            Quotation.internalBinaryWrite(message.price, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.PriceType price_type = 13; */
        if (message.priceType !== 0)
            writer.tag(13, WireType.Varint).int32(message.priceType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.ReplaceOrderRequest
 */
export const ReplaceOrderRequest = new ReplaceOrderRequest$Type();
/**
 * @generated ServiceType for protobuf service tinkoff.public.invest.api.contract.v1.OrdersStreamService
 */
export const OrdersStreamService = new ServiceType("tinkoff.public.invest.api.contract.v1.OrdersStreamService", [
    { name: "TradesStream", serverStreaming: true, options: {}, I: TradesStreamRequest, O: TradesStreamResponse }
]);
/**
 * @generated ServiceType for protobuf service tinkoff.public.invest.api.contract.v1.OrdersService
 */
export const OrdersService = new ServiceType("tinkoff.public.invest.api.contract.v1.OrdersService", [
    { name: "PostOrder", options: {}, I: PostOrderRequest, O: PostOrderResponse },
    { name: "CancelOrder", options: {}, I: CancelOrderRequest, O: CancelOrderResponse },
    { name: "GetOrderState", options: {}, I: GetOrderStateRequest, O: OrderState },
    { name: "GetOrders", options: {}, I: GetOrdersRequest, O: GetOrdersResponse },
    { name: "ReplaceOrder", options: {}, I: ReplaceOrderRequest, O: PostOrderResponse }
]);
