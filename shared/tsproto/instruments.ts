// @generated by protobuf-ts 2.8.2 with parameter long_type_string
// @generated from protobuf file "instruments.proto" (package "tinkoff.public.invest.api.contract.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { InstrumentType } from "./common";
import { Quotation } from "./common";
import { SecurityTradingStatus } from "./common";
import { MoneyValue } from "./common";
import { Timestamp } from "./google/protobuf/timestamp";
/**
 * Запрос расписания торгов.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.TradingSchedulesRequest
 */
export interface TradingSchedulesRequest {
    /**
     * @generated from protobuf field: string exchange = 1;
     */
    exchange: string; // Наименование биржи или расчетного календаря. </br>Если не передаётся, возвращается информация по всем доступным торговым площадкам.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp from = 2;
     */
    from?: Timestamp; // Начало периода по часовому поясу UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp to = 3;
     */
    to?: Timestamp; // Окончание периода по часовому поясу UTC.
}
/**
 * Список торговых площадок.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.TradingSchedulesResponse
 */
export interface TradingSchedulesResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.TradingSchedule exchanges = 1;
     */
    exchanges: TradingSchedule[]; // Список торговых площадок и режимов торгов.
}
/**
 * Данные по торговой площадке.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.TradingSchedule
 */
export interface TradingSchedule {
    /**
     * @generated from protobuf field: string exchange = 1;
     */
    exchange: string; // Наименование торговой площадки.
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.TradingDay days = 2;
     */
    days: TradingDay[]; // Массив с торговыми и неторговыми днями.
}
/**
 * Информация о времени торгов.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.TradingDay
 */
export interface TradingDay {
    /**
     * @generated from protobuf field: google.protobuf.Timestamp date = 1;
     */
    date?: Timestamp; // Дата.
    /**
     * @generated from protobuf field: bool is_trading_day = 2;
     */
    isTradingDay: boolean; // Признак торгового дня на бирже.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp start_time = 3;
     */
    startTime?: Timestamp; // Время начала торгов по часовому поясу UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp end_time = 4;
     */
    endTime?: Timestamp; // Время окончания торгов по часовому поясу UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp opening_auction_start_time = 7;
     */
    openingAuctionStartTime?: Timestamp; // Время начала аукциона открытия в часовом поясе UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp closing_auction_end_time = 8;
     */
    closingAuctionEndTime?: Timestamp; // Время окончания аукциона закрытия в часовом поясе UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp evening_opening_auction_start_time = 9;
     */
    eveningOpeningAuctionStartTime?: Timestamp; // Время начала аукциона открытия вечерней сессии в часовом поясе UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp evening_start_time = 10;
     */
    eveningStartTime?: Timestamp; // Время начала вечерней сессии в часовом поясе UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp evening_end_time = 11;
     */
    eveningEndTime?: Timestamp; // Время окончания вечерней сессии в часовом поясе UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp clearing_start_time = 12;
     */
    clearingStartTime?: Timestamp; // Время начала основного клиринга в часовом поясе UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp clearing_end_time = 13;
     */
    clearingEndTime?: Timestamp; // Время окончания основного клиринга в часовом поясе UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp premarket_start_time = 14;
     */
    premarketStartTime?: Timestamp; // Время начала премаркета в часовом поясе UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp premarket_end_time = 15;
     */
    premarketEndTime?: Timestamp; // Время окончания премаркета в часовом поясе UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp closing_auction_start_time = 16;
     */
    closingAuctionStartTime?: Timestamp; // Время начала аукциона закрытия в часовом поясе UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp opening_auction_end_time = 17;
     */
    openingAuctionEndTime?: Timestamp; // Время окончания аукциона открытия в часовом поясе UTC.
}
/**
 * Запрос получения инструмента по идентификатору.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.InstrumentRequest
 */
export interface InstrumentRequest {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.InstrumentIdType id_type = 1;
     */
    idType: InstrumentIdType; // Тип идентификатора инструмента. Возможные значения: figi, ticker. Подробнее об идентификации инструментов: [Идентификация инструментов](https://tinkoff.github.io/investAPI/faq_identification/)
    /**
     * @generated from protobuf field: string class_code = 2;
     */
    classCode: string; // Идентификатор class_code. Обязателен при id_type = ticker.
    /**
     * @generated from protobuf field: string id = 3;
     */
    id: string; // Идентификатор запрашиваемого инструмента.
}
/**
 * Запрос получения инструментов.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.InstrumentsRequest
 */
export interface InstrumentsRequest {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.InstrumentStatus instrument_status = 1;
     */
    instrumentStatus: InstrumentStatus; // Статус запрашиваемых инструментов. Возможные значения: [InstrumentStatus](#instrumentstatus)
}
/**
 * Информация об облигации.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.BondResponse
 */
export interface BondResponse {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Bond instrument = 1;
     */
    instrument?: Bond; // Информация об облигации.
}
/**
 * Список облигаций.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.BondsResponse
 */
export interface BondsResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.Bond instruments = 1;
     */
    instruments: Bond[]; // Массив облигаций.
}
/**
 * Запрос купонов по облигации.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetBondCouponsRequest
 */
export interface GetBondCouponsRequest {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp from = 2;
     */
    from?: Timestamp; // Начало запрашиваемого периода в часовом поясе UTC. Фильтрация по coupon_date (дата выплаты купона)
    /**
     * @generated from protobuf field: google.protobuf.Timestamp to = 3;
     */
    to?: Timestamp; // Окончание запрашиваемого периода в часовом поясе UTC. Фильтрация по coupon_date (дата выплаты купона)
}
/**
 * Купоны по облигации.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetBondCouponsResponse
 */
export interface GetBondCouponsResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.Coupon events = 1;
     */
    events: Coupon[];
}
/**
 * Объект передачи информации о купоне облигации.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.Coupon
 */
export interface Coupon {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp coupon_date = 2;
     */
    couponDate?: Timestamp; // Дата выплаты купона.
    /**
     * @generated from protobuf field: int64 coupon_number = 3;
     */
    couponNumber: string; // Номер купона.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp fix_date = 4;
     */
    fixDate?: Timestamp; // (Опционально) Дата фиксации реестра для выплаты купона.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue pay_one_bond = 5;
     */
    payOneBond?: MoneyValue; // Выплата на одну облигацию.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.CouponType coupon_type = 6;
     */
    couponType: CouponType; // Тип купона.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp coupon_start_date = 7;
     */
    couponStartDate?: Timestamp; // Начало купонного периода.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp coupon_end_date = 8;
     */
    couponEndDate?: Timestamp; // Окончание купонного периода.
    /**
     * @generated from protobuf field: int32 coupon_period = 9;
     */
    couponPeriod: number; // Купонный период в днях.
}
/**
 * Данные по валюте.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.CurrencyResponse
 */
export interface CurrencyResponse {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Currency instrument = 1;
     */
    instrument?: Currency; // Информация о валюте.
}
/**
 * Данные по валютам.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.CurrenciesResponse
 */
export interface CurrenciesResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.Currency instruments = 1;
     */
    instruments: Currency[]; // Массив валют.
}
/**
 * Данные по фонду.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.EtfResponse
 */
export interface EtfResponse {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Etf instrument = 1;
     */
    instrument?: Etf; // Информация о фонде.
}
/**
 * Данные по фондам.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.EtfsResponse
 */
export interface EtfsResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.Etf instruments = 1;
     */
    instruments: Etf[]; // Массив фондов.
}
/**
 * Данные по фьючерсу.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.FutureResponse
 */
export interface FutureResponse {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Future instrument = 1;
     */
    instrument?: Future; // Информация о фьючерсу.
}
/**
 * Данные по фьючерсам.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.FuturesResponse
 */
export interface FuturesResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.Future instruments = 1;
     */
    instruments: Future[]; // Массив фьючерсов.
}
/**
 * Данные по опциону.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.OptionResponse
 */
export interface OptionResponse {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Option instrument = 1;
     */
    instrument?: Option; // Информация по опциону.
}
/**
 * Данные по опционам.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.OptionsResponse
 */
export interface OptionsResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.Option instruments = 1;
     */
    instruments: Option[]; // Массив данных по опциону.
}
/**
 * Опцион.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.Option
 */
export interface Option {
    /**
     * @generated from protobuf field: string uid = 1;
     */
    uid: string; // Уникальный идентификатор инструмента.
    /**
     * @generated from protobuf field: string position_uid = 2;
     */
    positionUid: string; // Уникальный идентификатор позиции.
    /**
     * @generated from protobuf field: string ticker = 3;
     */
    ticker: string; // Тикер инструмента.
    /**
     * @generated from protobuf field: string class_code = 4;
     */
    classCode: string; // Класс-код.
    /**
     * @generated from protobuf field: string basic_asset_position_uid = 5;
     */
    basicAssetPositionUid: string; // Уникальный идентификатор позиции основного инструмента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status = 21;
     */
    tradingStatus: SecurityTradingStatus; // Текущий режим торгов инструмента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.RealExchange real_exchange = 31;
     */
    realExchange: RealExchange; // Реальная площадка исполнения расчётов. Допустимые значения: [REAL_EXCHANGE_MOEX, REAL_EXCHANGE_RTS]
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.OptionDirection direction = 41;
     */
    direction: OptionDirection; // Направление опциона.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.OptionPaymentType payment_type = 42;
     */
    paymentType: OptionPaymentType; // Тип расчетов по опциону.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.OptionStyle style = 43;
     */
    style: OptionStyle; // Стиль опциона.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.OptionSettlementType settlement_type = 44;
     */
    settlementType: OptionSettlementType; // Способ исполнения опциона.
    /**
     * @generated from protobuf field: string name = 101;
     */
    name: string; // Название инструмента.
    /**
     * @generated from protobuf field: string currency = 111;
     */
    currency: string; // Валюта.
    /**
     * @generated from protobuf field: string settlement_currency = 112;
     */
    settlementCurrency: string; // Валюта, в которой оценивается контракт.
    /**
     * @generated from protobuf field: string asset_type = 131;
     */
    assetType: string; // Тип актива.
    /**
     * @generated from protobuf field: string basic_asset = 132;
     */
    basicAsset: string; // Основной актив.
    /**
     * @generated from protobuf field: string exchange = 141;
     */
    exchange: string; // Биржа.
    /**
     * @generated from protobuf field: string country_of_risk = 151;
     */
    countryOfRisk: string; // Код страны рисков.
    /**
     * @generated from protobuf field: string country_of_risk_name = 152;
     */
    countryOfRiskName: string; // Наименование страны рисков.
    /**
     * @generated from protobuf field: string sector = 161;
     */
    sector: string; // Сектор экономики.
    /**
     * @generated from protobuf field: int32 lot = 201;
     */
    lot: number; // Количество бумаг в лоте.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation basic_asset_size = 211;
     */
    basicAssetSize?: Quotation; // Размер основного актива.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation klong = 221;
     */
    klong?: Quotation; // Коэффициент ставки риска длинной позиции по клиенту.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation kshort = 222;
     */
    kshort?: Quotation; // Коэффициент ставки риска короткой позиции по клиенту.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dlong = 223;
     */
    dlong?: Quotation; // Ставка риска минимальной маржи лонг.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dshort = 224;
     */
    dshort?: Quotation; // Ставка риска минимальной маржи шорт.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dlong_min = 225;
     */
    dlongMin?: Quotation; // Ставка риска начальной маржи лонг.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dshort_min = 226;
     */
    dshortMin?: Quotation; // Ставка риска начальной маржи шорт.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation min_price_increment = 231;
     */
    minPriceIncrement?: Quotation; // Минимальный шаг цены.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue strike_price = 241;
     */
    strikePrice?: MoneyValue; // Цена страйка.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp expiration_date = 301;
     */
    expirationDate?: Timestamp; // Дата истечения срока в формате UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp first_trade_date = 311;
     */
    firstTradeDate?: Timestamp; // Дата начала обращения контракта в формате UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp last_trade_date = 312;
     */
    lastTradeDate?: Timestamp; // Дата исполнения в формате UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp first_1min_candle_date = 321 [json_name = "first1minCandleDate"];
     */
    first1MinCandleDate?: Timestamp; // Дата первой минутной свечи в формате UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp first_1day_candle_date = 322 [json_name = "first1dayCandleDate"];
     */
    first1DayCandleDate?: Timestamp; // Дата первой дневной свечи в формате UTC.
    /**
     * @generated from protobuf field: bool short_enabled_flag = 401;
     */
    shortEnabledFlag: boolean; // Признак доступности для операций шорт.
    /**
     * @generated from protobuf field: bool for_iis_flag = 402;
     */
    forIisFlag: boolean; // Возможность покупки/продажи на ИИС.
    /**
     * @generated from protobuf field: bool otc_flag = 403;
     */
    otcFlag: boolean; // Признак внебиржевой ценной бумаги.
    /**
     * @generated from protobuf field: bool buy_available_flag = 404;
     */
    buyAvailableFlag: boolean; // Признак доступности для покупки.
    /**
     * @generated from protobuf field: bool sell_available_flag = 405;
     */
    sellAvailableFlag: boolean; // Признак доступности для продажи.
    /**
     * @generated from protobuf field: bool for_qual_investor_flag = 406;
     */
    forQualInvestorFlag: boolean; // Флаг отображающий доступность торговли инструментом только для квалифицированных инвесторов.
    /**
     * @generated from protobuf field: bool weekend_flag = 407;
     */
    weekendFlag: boolean; // Флаг отображающий доступность торговли инструментом по выходным.
    /**
     * @generated from protobuf field: bool blocked_tca_flag = 408;
     */
    blockedTcaFlag: boolean; // Флаг заблокированного ТКС.
    /**
     * @generated from protobuf field: bool api_trade_available_flag = 409;
     */
    apiTradeAvailableFlag: boolean; // Параметр указывает на возможность торговать инструментом через API.
}
/**
 * Данные по акции.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.ShareResponse
 */
export interface ShareResponse {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Share instrument = 1;
     */
    instrument?: Share; // Информация об акции.
}
/**
 * Данные по акциям.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.SharesResponse
 */
export interface SharesResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.Share instruments = 1;
     */
    instruments: Share[]; // Массив акций.
}
/**
 * Объект передачи информации об облигации.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.Bond
 */
export interface Bond {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: string ticker = 2;
     */
    ticker: string; // Тикер инструмента.
    /**
     * @generated from protobuf field: string class_code = 3;
     */
    classCode: string; // Класс-код (секция торгов).
    /**
     * @generated from protobuf field: string isin = 4;
     */
    isin: string; // Isin-идентификатор инструмента.
    /**
     * @generated from protobuf field: int32 lot = 5;
     */
    lot: number; // Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру *lot*. Подробнее: [лот](https://tinkoff.github.io/investAPI/glossary#lot)
    /**
     * @generated from protobuf field: string currency = 6;
     */
    currency: string; // Валюта расчётов.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation klong = 7;
     */
    klong?: Quotation; // Коэффициент ставки риска длинной позиции по инструменту.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation kshort = 8;
     */
    kshort?: Quotation; // Коэффициент ставки риска короткой позиции по инструменту.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dlong = 9;
     */
    dlong?: Quotation; // Ставка риска минимальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dshort = 10;
     */
    dshort?: Quotation; // Ставка риска минимальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dlong_min = 11;
     */
    dlongMin?: Quotation; // Ставка риска начальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dshort_min = 12;
     */
    dshortMin?: Quotation; // Ставка риска начальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
    /**
     * @generated from protobuf field: bool short_enabled_flag = 13;
     */
    shortEnabledFlag: boolean; // Признак доступности для операций в шорт.
    /**
     * @generated from protobuf field: string name = 15;
     */
    name: string; // Название инструмента.
    /**
     * @generated from protobuf field: string exchange = 16;
     */
    exchange: string; // Торговая площадка.
    /**
     * @generated from protobuf field: int32 coupon_quantity_per_year = 17;
     */
    couponQuantityPerYear: number; // Количество выплат по купонам в год.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp maturity_date = 18;
     */
    maturityDate?: Timestamp; // Дата погашения облигации в часовом поясе UTC.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue nominal = 19;
     */
    nominal?: MoneyValue; // Номинал облигации.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue initial_nominal = 20;
     */
    initialNominal?: MoneyValue; // Первоначальный номинал облигации.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp state_reg_date = 21;
     */
    stateRegDate?: Timestamp; // Дата выпуска облигации в часовом поясе UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp placement_date = 22;
     */
    placementDate?: Timestamp; // Дата размещения в часовом поясе UTC.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue placement_price = 23;
     */
    placementPrice?: MoneyValue; // Цена размещения.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue aci_value = 24;
     */
    aciValue?: MoneyValue; // Значение НКД (накопленного купонного дохода) на дату.
    /**
     * @generated from protobuf field: string country_of_risk = 25;
     */
    countryOfRisk: string; // Код страны риска, т.е. страны, в которой компания ведёт основной бизнес.
    /**
     * @generated from protobuf field: string country_of_risk_name = 26;
     */
    countryOfRiskName: string; // Наименование страны риска, т.е. страны, в которой компания ведёт основной бизнес.
    /**
     * @generated from protobuf field: string sector = 27;
     */
    sector: string; // Сектор экономики.
    /**
     * @generated from protobuf field: string issue_kind = 28;
     */
    issueKind: string; // Форма выпуска. Возможные значения: </br>**documentary** — документарная; </br>**non_documentary** — бездокументарная.
    /**
     * @generated from protobuf field: int64 issue_size = 29;
     */
    issueSize: string; // Размер выпуска.
    /**
     * @generated from protobuf field: int64 issue_size_plan = 30;
     */
    issueSizePlan: string; // Плановый размер выпуска.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status = 31;
     */
    tradingStatus: SecurityTradingStatus; // Текущий режим торгов инструмента.
    /**
     * @generated from protobuf field: bool otc_flag = 32;
     */
    otcFlag: boolean; // Признак внебиржевой ценной бумаги.
    /**
     * @generated from protobuf field: bool buy_available_flag = 33;
     */
    buyAvailableFlag: boolean; // Признак доступности для покупки.
    /**
     * @generated from protobuf field: bool sell_available_flag = 34;
     */
    sellAvailableFlag: boolean; // Признак доступности для продажи.
    /**
     * @generated from protobuf field: bool floating_coupon_flag = 35;
     */
    floatingCouponFlag: boolean; // Признак облигации с плавающим купоном.
    /**
     * @generated from protobuf field: bool perpetual_flag = 36;
     */
    perpetualFlag: boolean; // Признак бессрочной облигации.
    /**
     * @generated from protobuf field: bool amortization_flag = 37;
     */
    amortizationFlag: boolean; // Признак облигации с амортизацией долга.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation min_price_increment = 38;
     */
    minPriceIncrement?: Quotation; // Шаг цены.
    /**
     * @generated from protobuf field: bool api_trade_available_flag = 39;
     */
    apiTradeAvailableFlag: boolean; // Параметр указывает на возможность торговать инструментом через API.
    /**
     * @generated from protobuf field: string uid = 40;
     */
    uid: string; // Уникальный идентификатор инструмента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.RealExchange real_exchange = 41;
     */
    realExchange: RealExchange; // Реальная площадка исполнения расчётов.
    /**
     * @generated from protobuf field: string position_uid = 42;
     */
    positionUid: string; // Уникальный идентификатор позиции инструмента.
    /**
     * @generated from protobuf field: bool for_iis_flag = 51;
     */
    forIisFlag: boolean; // Признак доступности для ИИС.
    /**
     * @generated from protobuf field: bool for_qual_investor_flag = 52;
     */
    forQualInvestorFlag: boolean; // Флаг отображающий доступность торговли инструментом только для квалифицированных инвесторов.
    /**
     * @generated from protobuf field: bool weekend_flag = 53;
     */
    weekendFlag: boolean; // Флаг отображающий доступность торговли инструментом по выходным
    /**
     * @generated from protobuf field: bool blocked_tca_flag = 54;
     */
    blockedTcaFlag: boolean; // Флаг заблокированного ТКС
    /**
     * @generated from protobuf field: bool subordinated_flag = 55;
     */
    subordinatedFlag: boolean; // Признак субординированной облигации.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp first_1min_candle_date = 61 [json_name = "first1minCandleDate"];
     */
    first1MinCandleDate?: Timestamp; // Дата первой минутной свечи.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp first_1day_candle_date = 62 [json_name = "first1dayCandleDate"];
     */
    first1DayCandleDate?: Timestamp; // Дата первой дневной свечи.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.RiskLevel risk_level = 63;
     */
    riskLevel: RiskLevel; // Уровень риска.
}
/**
 * Объект передачи информации о валюте.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.Currency
 */
export interface Currency {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: string ticker = 2;
     */
    ticker: string; // Тикер инструмента.
    /**
     * @generated from protobuf field: string class_code = 3;
     */
    classCode: string; // Класс-код (секция торгов).
    /**
     * @generated from protobuf field: string isin = 4;
     */
    isin: string; // Isin-идентификатор инструмента.
    /**
     * @generated from protobuf field: int32 lot = 5;
     */
    lot: number; // Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру *lot*. Подробнее: [лот](https://tinkoff.github.io/investAPI/glossary#lot)
    /**
     * @generated from protobuf field: string currency = 6;
     */
    currency: string; // Валюта расчётов.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation klong = 7;
     */
    klong?: Quotation; // Коэффициент ставки риска длинной позиции по инструменту.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation kshort = 8;
     */
    kshort?: Quotation; // Коэффициент ставки риска короткой позиции по инструменту.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dlong = 9;
     */
    dlong?: Quotation; // Ставка риска минимальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dshort = 10;
     */
    dshort?: Quotation; // Ставка риска минимальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dlong_min = 11;
     */
    dlongMin?: Quotation; // Ставка риска начальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dshort_min = 12;
     */
    dshortMin?: Quotation; // Ставка риска начальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
    /**
     * @generated from protobuf field: bool short_enabled_flag = 13;
     */
    shortEnabledFlag: boolean; // Признак доступности для операций в шорт.
    /**
     * @generated from protobuf field: string name = 15;
     */
    name: string; // Название инструмента.
    /**
     * @generated from protobuf field: string exchange = 16;
     */
    exchange: string; // Торговая площадка.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue nominal = 17;
     */
    nominal?: MoneyValue; // Номинал.
    /**
     * @generated from protobuf field: string country_of_risk = 18;
     */
    countryOfRisk: string; // Код страны риска, т.е. страны, в которой компания ведёт основной бизнес.
    /**
     * @generated from protobuf field: string country_of_risk_name = 19;
     */
    countryOfRiskName: string; // Наименование страны риска, т.е. страны, в которой компания ведёт основной бизнес.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status = 20;
     */
    tradingStatus: SecurityTradingStatus; // Текущий режим торгов инструмента.
    /**
     * @generated from protobuf field: bool otc_flag = 21;
     */
    otcFlag: boolean; // Признак внебиржевой ценной бумаги.
    /**
     * @generated from protobuf field: bool buy_available_flag = 22;
     */
    buyAvailableFlag: boolean; // Признак доступности для покупки.
    /**
     * @generated from protobuf field: bool sell_available_flag = 23;
     */
    sellAvailableFlag: boolean; // Признак доступности для продажи.
    /**
     * @generated from protobuf field: string iso_currency_name = 24;
     */
    isoCurrencyName: string; // Строковый ISO-код валюты.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation min_price_increment = 25;
     */
    minPriceIncrement?: Quotation; // Шаг цены.
    /**
     * @generated from protobuf field: bool api_trade_available_flag = 26;
     */
    apiTradeAvailableFlag: boolean; // Параметр указывает на возможность торговать инструментом через API.
    /**
     * @generated from protobuf field: string uid = 27;
     */
    uid: string; // Уникальный идентификатор инструмента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.RealExchange real_exchange = 28;
     */
    realExchange: RealExchange; // Реальная площадка исполнения расчётов.
    /**
     * @generated from protobuf field: string position_uid = 29;
     */
    positionUid: string; // Уникальный идентификатор позиции инструмента.
    /**
     * @generated from protobuf field: bool for_iis_flag = 41;
     */
    forIisFlag: boolean; // Признак доступности для ИИС.
    /**
     * @generated from protobuf field: bool for_qual_investor_flag = 52;
     */
    forQualInvestorFlag: boolean; // Флаг отображающий доступность торговли инструментом только для квалифицированных инвесторов.
    /**
     * @generated from protobuf field: bool weekend_flag = 53;
     */
    weekendFlag: boolean; // Флаг отображающий доступность торговли инструментом по выходным.
    /**
     * @generated from protobuf field: bool blocked_tca_flag = 54;
     */
    blockedTcaFlag: boolean; // Флаг заблокированного ТКС.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp first_1min_candle_date = 56 [json_name = "first1minCandleDate"];
     */
    first1MinCandleDate?: Timestamp; // Дата первой минутной свечи.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp first_1day_candle_date = 57 [json_name = "first1dayCandleDate"];
     */
    first1DayCandleDate?: Timestamp; // Дата первой дневной свечи.
}
/**
 * Объект передачи информации об инвестиционном фонде.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.Etf
 */
export interface Etf {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: string ticker = 2;
     */
    ticker: string; // Тикер инструмента.
    /**
     * @generated from protobuf field: string class_code = 3;
     */
    classCode: string; // Класс-код (секция торгов).
    /**
     * @generated from protobuf field: string isin = 4;
     */
    isin: string; // Isin-идентификатор инструмента.
    /**
     * @generated from protobuf field: int32 lot = 5;
     */
    lot: number; // Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру *lot*. Подробнее: [лот](https://tinkoff.github.io/investAPI/glossary#lot)
    /**
     * @generated from protobuf field: string currency = 6;
     */
    currency: string; // Валюта расчётов.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation klong = 7;
     */
    klong?: Quotation; // Коэффициент ставки риска длинной позиции по инструменту.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation kshort = 8;
     */
    kshort?: Quotation; // Коэффициент ставки риска короткой позиции по инструменту.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dlong = 9;
     */
    dlong?: Quotation; // Ставка риска минимальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dshort = 10;
     */
    dshort?: Quotation; // Ставка риска минимальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dlong_min = 11;
     */
    dlongMin?: Quotation; // Ставка риска начальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dshort_min = 12;
     */
    dshortMin?: Quotation; // Ставка риска начальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
    /**
     * @generated from protobuf field: bool short_enabled_flag = 13;
     */
    shortEnabledFlag: boolean; // Признак доступности для операций в шорт.
    /**
     * @generated from protobuf field: string name = 15;
     */
    name: string; // Название инструмента.
    /**
     * @generated from protobuf field: string exchange = 16;
     */
    exchange: string; // Торговая площадка.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation fixed_commission = 17;
     */
    fixedCommission?: Quotation; // Размер фиксированной комиссии фонда.
    /**
     * @generated from protobuf field: string focus_type = 18;
     */
    focusType: string; // Возможные значения: </br>**equity** — акции;</br>**fixed_income** — облигации;</br>**mixed_allocation** — смешанный;</br>**money_market** — денежный рынок;</br>**real_estate** — недвижимость;</br>**commodity** — товары;</br>**specialty** — специальный;</br>**private_equity** — private equity;</br>**alternative_investment** — альтернативные инвестиции.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp released_date = 19;
     */
    releasedDate?: Timestamp; // Дата выпуска в часовом поясе UTC.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation num_shares = 20;
     */
    numShares?: Quotation; // Количество акций фонда в обращении.
    /**
     * @generated from protobuf field: string country_of_risk = 21;
     */
    countryOfRisk: string; // Код страны риска, т.е. страны, в которой компания ведёт основной бизнес.
    /**
     * @generated from protobuf field: string country_of_risk_name = 22;
     */
    countryOfRiskName: string; // Наименование страны риска, т.е. страны, в которой компания ведёт основной бизнес.
    /**
     * @generated from protobuf field: string sector = 23;
     */
    sector: string; // Сектор экономики.
    /**
     * @generated from protobuf field: string rebalancing_freq = 24;
     */
    rebalancingFreq: string; // Частота ребалансировки.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status = 25;
     */
    tradingStatus: SecurityTradingStatus; // Текущий режим торгов инструмента.
    /**
     * @generated from protobuf field: bool otc_flag = 26;
     */
    otcFlag: boolean; // Признак внебиржевой ценной бумаги.
    /**
     * @generated from protobuf field: bool buy_available_flag = 27;
     */
    buyAvailableFlag: boolean; // Признак доступности для покупки.
    /**
     * @generated from protobuf field: bool sell_available_flag = 28;
     */
    sellAvailableFlag: boolean; // Признак доступности для продажи.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation min_price_increment = 29;
     */
    minPriceIncrement?: Quotation; // Шаг цены.
    /**
     * @generated from protobuf field: bool api_trade_available_flag = 30;
     */
    apiTradeAvailableFlag: boolean; // Параметр указывает на возможность торговать инструментом через API.
    /**
     * @generated from protobuf field: string uid = 31;
     */
    uid: string; // Уникальный идентификатор инструмента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.RealExchange real_exchange = 32;
     */
    realExchange: RealExchange; // Реальная площадка исполнения расчётов.
    /**
     * @generated from protobuf field: string position_uid = 33;
     */
    positionUid: string; // Уникальный идентификатор позиции инструмента.
    /**
     * @generated from protobuf field: bool for_iis_flag = 41;
     */
    forIisFlag: boolean; // Признак доступности для ИИС.
    /**
     * @generated from protobuf field: bool for_qual_investor_flag = 42;
     */
    forQualInvestorFlag: boolean; // Флаг отображающий доступность торговли инструментом только для квалифицированных инвесторов.
    /**
     * @generated from protobuf field: bool weekend_flag = 43;
     */
    weekendFlag: boolean; // Флаг отображающий доступность торговли инструментом по выходным.
    /**
     * @generated from protobuf field: bool blocked_tca_flag = 44;
     */
    blockedTcaFlag: boolean; // Флаг заблокированного ТКС.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp first_1min_candle_date = 56 [json_name = "first1minCandleDate"];
     */
    first1MinCandleDate?: Timestamp; // Дата первой минутной свечи.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp first_1day_candle_date = 57 [json_name = "first1dayCandleDate"];
     */
    first1DayCandleDate?: Timestamp; // Дата первой дневной свечи.
}
/**
 * Объект передачи информации о фьючерсе.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.Future
 */
export interface Future {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: string ticker = 2;
     */
    ticker: string; // Тикер инструмента.
    /**
     * @generated from protobuf field: string class_code = 3;
     */
    classCode: string; // Класс-код (секция торгов).
    /**
     * @generated from protobuf field: int32 lot = 4;
     */
    lot: number; // Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру *lot*. Подробнее: [лот](https://tinkoff.github.io/investAPI/glossary#lot)
    /**
     * @generated from protobuf field: string currency = 5;
     */
    currency: string; // Валюта расчётов.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation klong = 6;
     */
    klong?: Quotation; // Коэффициент ставки риска длинной позиции по клиенту.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation kshort = 7;
     */
    kshort?: Quotation; // Коэффициент ставки риска короткой позиции по клиенту.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dlong = 8;
     */
    dlong?: Quotation; // Ставка риска минимальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dshort = 9;
     */
    dshort?: Quotation; // Ставка риска минимальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dlong_min = 10;
     */
    dlongMin?: Quotation; // Ставка риска начальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dshort_min = 11;
     */
    dshortMin?: Quotation; // Ставка риска начальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
    /**
     * @generated from protobuf field: bool short_enabled_flag = 12;
     */
    shortEnabledFlag: boolean; // Признак доступности для операций шорт.
    /**
     * @generated from protobuf field: string name = 13;
     */
    name: string; // Название инструмента.
    /**
     * @generated from protobuf field: string exchange = 14;
     */
    exchange: string; // Торговая площадка.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp first_trade_date = 15;
     */
    firstTradeDate?: Timestamp; // Дата начала обращения контракта в часовом поясе UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp last_trade_date = 16;
     */
    lastTradeDate?: Timestamp; // Дата в часовом поясе UTC, до которой возможно проведение операций с фьючерсом.
    /**
     * @generated from protobuf field: string futures_type = 17;
     */
    futuresType: string; // Тип фьючерса. Возможные значения: </br>**physical_delivery** — физические поставки; </br>**cash_settlement** — денежный эквивалент.
    /**
     * @generated from protobuf field: string asset_type = 18;
     */
    assetType: string; // Тип актива. Возможные значения: </br>**commodity** — товар; </br>**currency** — валюта; </br>**security** — ценная бумага; </br>**index** — индекс.
    /**
     * @generated from protobuf field: string basic_asset = 19;
     */
    basicAsset: string; // Основной актив.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation basic_asset_size = 20;
     */
    basicAssetSize?: Quotation; // Размер основного актива.
    /**
     * @generated from protobuf field: string country_of_risk = 21;
     */
    countryOfRisk: string; // Код страны риска, т.е. страны, в которой компания ведёт основной бизнес.
    /**
     * @generated from protobuf field: string country_of_risk_name = 22;
     */
    countryOfRiskName: string; // Наименование страны риска, т.е. страны, в которой компания ведёт основной бизнес.
    /**
     * @generated from protobuf field: string sector = 23;
     */
    sector: string; // Сектор экономики.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp expiration_date = 24;
     */
    expirationDate?: Timestamp; // Дата истечения срока в часов поясе UTC.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status = 25;
     */
    tradingStatus: SecurityTradingStatus; // Текущий режим торгов инструмента.
    /**
     * @generated from protobuf field: bool otc_flag = 26;
     */
    otcFlag: boolean; // Признак внебиржевой ценной бумаги.
    /**
     * @generated from protobuf field: bool buy_available_flag = 27;
     */
    buyAvailableFlag: boolean; // Признак доступности для покупки.
    /**
     * @generated from protobuf field: bool sell_available_flag = 28;
     */
    sellAvailableFlag: boolean; // Признак доступности для продажи.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation min_price_increment = 29;
     */
    minPriceIncrement?: Quotation; // Шаг цены.
    /**
     * @generated from protobuf field: bool api_trade_available_flag = 30;
     */
    apiTradeAvailableFlag: boolean; // Параметр указывает на возможность торговать инструментом через API.
    /**
     * @generated from protobuf field: string uid = 31;
     */
    uid: string; // Уникальный идентификатор инструмента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.RealExchange real_exchange = 32;
     */
    realExchange: RealExchange; // Реальная площадка исполнения расчётов.
    /**
     * @generated from protobuf field: string position_uid = 33;
     */
    positionUid: string; // Уникальный идентификатор позиции инструмента.
    /**
     * @generated from protobuf field: string basic_asset_position_uid = 34;
     */
    basicAssetPositionUid: string; // Уникальный идентификатор позиции основного инструмента.
    /**
     * @generated from protobuf field: bool for_iis_flag = 41;
     */
    forIisFlag: boolean; // Признак доступности для ИИС.
    /**
     * @generated from protobuf field: bool for_qual_investor_flag = 42;
     */
    forQualInvestorFlag: boolean; // Флаг отображающий доступность торговли инструментом только для квалифицированных инвесторов.
    /**
     * @generated from protobuf field: bool weekend_flag = 43;
     */
    weekendFlag: boolean; // Флаг отображающий доступность торговли инструментом по выходным.
    /**
     * @generated from protobuf field: bool blocked_tca_flag = 44;
     */
    blockedTcaFlag: boolean; // Флаг заблокированного ТКС.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp first_1min_candle_date = 56 [json_name = "first1minCandleDate"];
     */
    first1MinCandleDate?: Timestamp; // Дата первой минутной свечи.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp first_1day_candle_date = 57 [json_name = "first1dayCandleDate"];
     */
    first1DayCandleDate?: Timestamp; // Дата первой дневной свечи.
}
/**
 * Объект передачи информации об акции.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.Share
 */
export interface Share {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: string ticker = 2;
     */
    ticker: string; // Тикер инструмента.
    /**
     * @generated from protobuf field: string class_code = 3;
     */
    classCode: string; // Класс-код (секция торгов).
    /**
     * @generated from protobuf field: string isin = 4;
     */
    isin: string; // Isin-идентификатор инструмента.
    /**
     * @generated from protobuf field: int32 lot = 5;
     */
    lot: number; // Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру *lot*. Подробнее: [лот](https://tinkoff.github.io/investAPI/glossary#lot)
    /**
     * @generated from protobuf field: string currency = 6;
     */
    currency: string; // Валюта расчётов.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation klong = 7;
     */
    klong?: Quotation; // Коэффициент ставки риска длинной позиции по инструменту.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation kshort = 8;
     */
    kshort?: Quotation; // Коэффициент ставки риска короткой позиции по инструменту.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dlong = 9;
     */
    dlong?: Quotation; // Ставка риска минимальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dshort = 10;
     */
    dshort?: Quotation; // Ставка риска минимальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dlong_min = 11;
     */
    dlongMin?: Quotation; // Ставка риска начальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dshort_min = 12;
     */
    dshortMin?: Quotation; // Ставка риска начальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
    /**
     * @generated from protobuf field: bool short_enabled_flag = 13;
     */
    shortEnabledFlag: boolean; // Признак доступности для операций в шорт.
    /**
     * @generated from protobuf field: string name = 15;
     */
    name: string; // Название инструмента.
    /**
     * @generated from protobuf field: string exchange = 16;
     */
    exchange: string; // Торговая площадка.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp ipo_date = 17;
     */
    ipoDate?: Timestamp; // Дата IPO акции в часовом поясе UTC.
    /**
     * @generated from protobuf field: int64 issue_size = 18;
     */
    issueSize: string; // Размер выпуска.
    /**
     * @generated from protobuf field: string country_of_risk = 19;
     */
    countryOfRisk: string; // Код страны риска, т.е. страны, в которой компания ведёт основной бизнес.
    /**
     * @generated from protobuf field: string country_of_risk_name = 20;
     */
    countryOfRiskName: string; // Наименование страны риска, т.е. страны, в которой компания ведёт основной бизнес.
    /**
     * @generated from protobuf field: string sector = 21;
     */
    sector: string; // Сектор экономики.
    /**
     * @generated from protobuf field: int64 issue_size_plan = 22;
     */
    issueSizePlan: string; // Плановый размер выпуска.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue nominal = 23;
     */
    nominal?: MoneyValue; // Номинал.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status = 25;
     */
    tradingStatus: SecurityTradingStatus; // Текущий режим торгов инструмента.
    /**
     * @generated from protobuf field: bool otc_flag = 26;
     */
    otcFlag: boolean; // Признак внебиржевой ценной бумаги.
    /**
     * @generated from protobuf field: bool buy_available_flag = 27;
     */
    buyAvailableFlag: boolean; // Признак доступности для покупки.
    /**
     * @generated from protobuf field: bool sell_available_flag = 28;
     */
    sellAvailableFlag: boolean; // Признак доступности для продажи.
    /**
     * @generated from protobuf field: bool div_yield_flag = 29;
     */
    divYieldFlag: boolean; // Признак наличия дивидендной доходности.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.ShareType share_type = 30;
     */
    shareType: ShareType; // Тип акции. Возможные значения: [ShareType](https://tinkoff.github.io/investAPI/instruments#sharetype)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation min_price_increment = 31;
     */
    minPriceIncrement?: Quotation; // Шаг цены.
    /**
     * @generated from protobuf field: bool api_trade_available_flag = 32;
     */
    apiTradeAvailableFlag: boolean; // Параметр указывает на возможность торговать инструментом через API.
    /**
     * @generated from protobuf field: string uid = 33;
     */
    uid: string; // Уникальный идентификатор инструмента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.RealExchange real_exchange = 34;
     */
    realExchange: RealExchange; // Реальная площадка исполнения расчётов.
    /**
     * @generated from protobuf field: string position_uid = 35;
     */
    positionUid: string; // Уникальный идентификатор позиции инструмента.
    /**
     * @generated from protobuf field: bool for_iis_flag = 46;
     */
    forIisFlag: boolean; // Признак доступности для ИИС.
    /**
     * @generated from protobuf field: bool for_qual_investor_flag = 47;
     */
    forQualInvestorFlag: boolean; // Флаг отображающий доступность торговли инструментом только для квалифицированных инвесторов.
    /**
     * @generated from protobuf field: bool weekend_flag = 48;
     */
    weekendFlag: boolean; // Флаг отображающий доступность торговли инструментом по выходным
    /**
     * @generated from protobuf field: bool blocked_tca_flag = 49;
     */
    blockedTcaFlag: boolean; // Флаг заблокированного ТКС
    /**
     * @generated from protobuf field: google.protobuf.Timestamp first_1min_candle_date = 56 [json_name = "first1minCandleDate"];
     */
    first1MinCandleDate?: Timestamp; // Дата первой минутной свечи.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp first_1day_candle_date = 57 [json_name = "first1dayCandleDate"];
     */
    first1DayCandleDate?: Timestamp; // Дата первой дневной свечи.
}
/**
 * Запрос НКД по облигации
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetAccruedInterestsRequest
 */
export interface GetAccruedInterestsRequest {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp from = 2;
     */
    from?: Timestamp; // Начало запрашиваемого периода в часовом поясе UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp to = 3;
     */
    to?: Timestamp; // Окончание запрашиваемого периода в часовом поясе UTC.
}
/**
 * НКД облигации
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetAccruedInterestsResponse
 */
export interface GetAccruedInterestsResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.AccruedInterest accrued_interests = 1;
     */
    accruedInterests: AccruedInterest[]; // Массив операций начисления купонов.
}
/**
 * Операция начисления купонов.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.AccruedInterest
 */
export interface AccruedInterest {
    /**
     * @generated from protobuf field: google.protobuf.Timestamp date = 1;
     */
    date?: Timestamp; // Дата и время выплаты в часовом поясе UTC.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation value = 2;
     */
    value?: Quotation; // Величина выплаты.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation value_percent = 3;
     */
    valuePercent?: Quotation; // Величина выплаты в процентах от номинала.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation nominal = 4;
     */
    nominal?: Quotation; // Номинал облигации.
}
/**
 * Запрос информации о фьючерсе
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetFuturesMarginRequest
 */
export interface GetFuturesMarginRequest {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Идентификатор инструмента.
}
/**
 * Данные по фьючерсу
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetFuturesMarginResponse
 */
export interface GetFuturesMarginResponse {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue initial_margin_on_buy = 1;
     */
    initialMarginOnBuy?: MoneyValue; // Гарантийное обеспечение при покупке.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue initial_margin_on_sell = 2;
     */
    initialMarginOnSell?: MoneyValue; // Гарантийное обеспечение при продаже.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation min_price_increment = 3;
     */
    minPriceIncrement?: Quotation; // Шаг цены.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation min_price_increment_amount = 4;
     */
    minPriceIncrementAmount?: Quotation; // Стоимость шага цены.
}
/**
 * Данные по инструменту.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.InstrumentResponse
 */
export interface InstrumentResponse {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Instrument instrument = 1;
     */
    instrument?: Instrument; // Основная информация об инструменте.
}
/**
 * Объект передачи основной информации об инструменте.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.Instrument
 */
export interface Instrument {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: string ticker = 2;
     */
    ticker: string; // Тикер инструмента.
    /**
     * @generated from protobuf field: string class_code = 3;
     */
    classCode: string; // Класс-код инструмента.
    /**
     * @generated from protobuf field: string isin = 4;
     */
    isin: string; // Isin-идентификатор инструмента.
    /**
     * @generated from protobuf field: int32 lot = 5;
     */
    lot: number; // Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру *lot*. Подробнее: [лот](https://tinkoff.github.io/investAPI/glossary#lot)
    /**
     * @generated from protobuf field: string currency = 6;
     */
    currency: string; // Валюта расчётов.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation klong = 7;
     */
    klong?: Quotation; // Коэффициент ставки риска длинной позиции по инструменту.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation kshort = 8;
     */
    kshort?: Quotation; // Коэффициент ставки риска короткой позиции по инструменту.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dlong = 9;
     */
    dlong?: Quotation; // Ставка риска минимальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dshort = 10;
     */
    dshort?: Quotation; // Ставка риска минимальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dlong_min = 11;
     */
    dlongMin?: Quotation; // Ставка риска начальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dshort_min = 12;
     */
    dshortMin?: Quotation; // Ставка риска начальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
    /**
     * @generated from protobuf field: bool short_enabled_flag = 13;
     */
    shortEnabledFlag: boolean; // Признак доступности для операций в шорт.
    /**
     * @generated from protobuf field: string name = 14;
     */
    name: string; // Название инструмента.
    /**
     * @generated from protobuf field: string exchange = 15;
     */
    exchange: string; // Торговая площадка.
    /**
     * @generated from protobuf field: string country_of_risk = 16;
     */
    countryOfRisk: string; // Код страны риска, т.е. страны, в которой компания ведёт основной бизнес.
    /**
     * @generated from protobuf field: string country_of_risk_name = 17;
     */
    countryOfRiskName: string; // Наименование страны риска, т.е. страны, в которой компания ведёт основной бизнес.
    /**
     * @generated from protobuf field: string instrument_type = 18;
     */
    instrumentType: string; // Тип инструмента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status = 19;
     */
    tradingStatus: SecurityTradingStatus; // Текущий режим торгов инструмента.
    /**
     * @generated from protobuf field: bool otc_flag = 20;
     */
    otcFlag: boolean; // Признак внебиржевой ценной бумаги.
    /**
     * @generated from protobuf field: bool buy_available_flag = 21;
     */
    buyAvailableFlag: boolean; // Признак доступности для покупки.
    /**
     * @generated from protobuf field: bool sell_available_flag = 22;
     */
    sellAvailableFlag: boolean; // Признак доступности для продажи.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation min_price_increment = 23;
     */
    minPriceIncrement?: Quotation; // Шаг цены.
    /**
     * @generated from protobuf field: bool api_trade_available_flag = 24;
     */
    apiTradeAvailableFlag: boolean; // Параметр указывает на возможность торговать инструментом через API.
    /**
     * @generated from protobuf field: string uid = 25;
     */
    uid: string; // Уникальный идентификатор инструмента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.RealExchange real_exchange = 26;
     */
    realExchange: RealExchange; // Реальная площадка исполнения расчётов.
    /**
     * @generated from protobuf field: string position_uid = 27;
     */
    positionUid: string; // Уникальный идентификатор позиции инструмента.
    /**
     * @generated from protobuf field: bool for_iis_flag = 36;
     */
    forIisFlag: boolean; // Признак доступности для ИИС.
    /**
     * @generated from protobuf field: bool for_qual_investor_flag = 37;
     */
    forQualInvestorFlag: boolean; // Флаг отображающий доступность торговли инструментом только для квалифицированных инвесторов.
    /**
     * @generated from protobuf field: bool weekend_flag = 38;
     */
    weekendFlag: boolean; // Флаг отображающий доступность торговли инструментом по выходным
    /**
     * @generated from protobuf field: bool blocked_tca_flag = 39;
     */
    blockedTcaFlag: boolean; // Флаг заблокированного ТКС
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.InstrumentType instrument_kind = 40;
     */
    instrumentKind: InstrumentType; // Тип инструмента.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp first_1min_candle_date = 56 [json_name = "first1minCandleDate"];
     */
    first1MinCandleDate?: Timestamp; // Дата первой минутной свечи.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp first_1day_candle_date = 57 [json_name = "first1dayCandleDate"];
     */
    first1DayCandleDate?: Timestamp; // Дата первой дневной свечи.
}
/**
 * Запрос дивидендов.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetDividendsRequest
 */
export interface GetDividendsRequest {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp from = 2;
     */
    from?: Timestamp; // Начало запрашиваемого периода в часовом поясе UTC. Фильтрация происходит по параметру *record_date* (дата фиксации реестра).
    /**
     * @generated from protobuf field: google.protobuf.Timestamp to = 3;
     */
    to?: Timestamp; // Окончание запрашиваемого периода в часовом поясе UTC. Фильтрация происходит по параметру *record_date* (дата фиксации реестра).
}
/**
 * Дивиденды.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetDividendsResponse
 */
export interface GetDividendsResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.Dividend dividends = 1;
     */
    dividends: Dividend[];
}
/**
 * Информация о выплате.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.Dividend
 */
export interface Dividend {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue dividend_net = 1;
     */
    dividendNet?: MoneyValue; // Величина дивиденда на 1 ценную бумагу (включая валюту).
    /**
     * @generated from protobuf field: google.protobuf.Timestamp payment_date = 2;
     */
    paymentDate?: Timestamp; // Дата фактических выплат в часовом поясе UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp declared_date = 3;
     */
    declaredDate?: Timestamp; // Дата объявления дивидендов в часовом поясе UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp last_buy_date = 4;
     */
    lastBuyDate?: Timestamp; // Последний день (включительно) покупки для получения выплаты в часовом поясе UTC.
    /**
     * @generated from protobuf field: string dividend_type = 5;
     */
    dividendType: string; // Тип выплаты. Возможные значения: Regular Cash – регулярные выплаты, Cancelled – выплата отменена, Daily Accrual – ежедневное начисление, Return of Capital – возврат капитала, прочие типы выплат.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp record_date = 6;
     */
    recordDate?: Timestamp; // Дата фиксации реестра в часовом поясе UTC.
    /**
     * @generated from protobuf field: string regularity = 7;
     */
    regularity: string; // Регулярность выплаты. Возможные значения: Annual – ежегодная, Semi-Anl – каждые полгода, прочие типы выплат.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue close_price = 8;
     */
    closePrice?: MoneyValue; // Цена закрытия инструмента на момент ex_dividend_date.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation yield_value = 9;
     */
    yieldValue?: Quotation; // Величина доходности.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 10;
     */
    createdAt?: Timestamp; // Дата и время создания записи в часовом поясе UTC.
}
/**
 * Запрос актива по идентификатору.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.AssetRequest
 */
export interface AssetRequest {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string; // uid-идентификатор актива.
}
/**
 * Данные по активу.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.AssetResponse
 */
export interface AssetResponse {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.AssetFull asset = 1;
     */
    asset?: AssetFull; // Актив.
}
/**
 * Запрос списка активов.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.AssetsRequest
 */
export interface AssetsRequest {
}
/**
 * Список активов.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.AssetsResponse
 */
export interface AssetsResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.Asset assets = 1;
     */
    assets: Asset[]; // Активы.
}
/**
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.AssetFull
 */
export interface AssetFull {
    /**
     * @generated from protobuf field: string uid = 1;
     */
    uid: string; // Уникальный идентификатор актива.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.AssetType type = 2;
     */
    type: AssetType; // Тип актива.
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string; // Наименование актива.
    /**
     * @generated from protobuf field: string name_brief = 4;
     */
    nameBrief: string; // Короткое наименование актива.
    /**
     * @generated from protobuf field: string description = 5;
     */
    description: string; // Описание актива.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp deleted_at = 6;
     */
    deletedAt?: Timestamp; // Дата и время удаления актива.
    /**
     * @generated from protobuf field: repeated string required_tests = 7;
     */
    requiredTests: string[]; // Тестирование клиентов.
    /**
     * @generated from protobuf oneof: ext
     */
    ext: {
        oneofKind: "currency";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.AssetCurrency currency = 8;
         */
        currency: AssetCurrency; // Валюта. Обязательно и заполняется только для type = "ASSET_TYPE_CURRENCY".
    } | {
        oneofKind: "security";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.AssetSecurity security = 9;
         */
        security: AssetSecurity; // Ценная бумага. Обязательно и заполняется только для type = "ASSET_TYPE_SECURITY".
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: string gos_reg_code = 10;
     */
    gosRegCode: string; // Номер государственной регистрации.
    /**
     * @generated from protobuf field: string cfi = 11;
     */
    cfi: string; // Код CFI.
    /**
     * @generated from protobuf field: string code_nsd = 12;
     */
    codeNsd: string; // Код НРД инструмента.
    /**
     * @generated from protobuf field: string status = 13;
     */
    status: string; // Статус актива.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Brand brand = 14;
     */
    brand?: Brand; // Бренд.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp updated_at = 15;
     */
    updatedAt?: Timestamp; // Дата и время последнего обновления записи.
    /**
     * @generated from protobuf field: string br_code = 16;
     */
    brCode: string; // Код типа ц.б. по классификации Банка России.
    /**
     * @generated from protobuf field: string br_code_name = 17;
     */
    brCodeName: string; // Наименование кода типа ц.б. по классификации Банка России.
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.AssetInstrument instruments = 18;
     */
    instruments: AssetInstrument[]; // Массив идентификаторов инструментов.
}
/**
 * Информация об активе.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.Asset
 */
export interface Asset {
    /**
     * @generated from protobuf field: string uid = 1;
     */
    uid: string; // Уникальный идентификатор актива.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.AssetType type = 2;
     */
    type: AssetType; // Тип актива.
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string; // Наименование актива.
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.AssetInstrument instruments = 4;
     */
    instruments: AssetInstrument[]; // Массив идентификаторов инструментов.
}
/**
 * Валюта.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.AssetCurrency
 */
export interface AssetCurrency {
    /**
     * @generated from protobuf field: string base_currency = 1;
     */
    baseCurrency: string; // ISO-код валюты.
}
/**
 * Ценная бумага.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.AssetSecurity
 */
export interface AssetSecurity {
    /**
     * @generated from protobuf field: string isin = 1;
     */
    isin: string; // ISIN-идентификатор ценной бумаги.
    /**
     * @generated from protobuf field: string type = 2;
     */
    type: string; // Тип ценной бумаги.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.InstrumentType instrument_kind = 10;
     */
    instrumentKind: InstrumentType; // Тип инструмента.
    /**
     * @generated from protobuf oneof: ext
     */
    ext: {
        oneofKind: "share";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.AssetShare share = 3;
         */
        share: AssetShare; // Акция. Заполняется только для акций (тип актива asset.type = "ASSET_TYPE_SECURITY" и security.type = share).
    } | {
        oneofKind: "bond";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.AssetBond bond = 4;
         */
        bond: AssetBond; // Облигация. Заполняется только для облигаций (тип актива asset.type = "ASSET_TYPE_SECURITY" и security.type = bond).
    } | {
        oneofKind: "sp";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.AssetStructuredProduct sp = 5;
         */
        sp: AssetStructuredProduct; // Структурная нота. Заполняется только для структурных продуктов (тип актива asset.type = "ASSET_TYPE_SECURITY" и security.type = sp).
    } | {
        oneofKind: "etf";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.AssetEtf etf = 6;
         */
        etf: AssetEtf; // Фонд. Заполняется только для фондов (тип актива asset.type = "ASSET_TYPE_SECURITY" и security.type = etf).
    } | {
        oneofKind: "clearingCertificate";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.AssetClearingCertificate clearing_certificate = 7;
         */
        clearingCertificate: AssetClearingCertificate; // Клиринговый сертификат участия. Заполняется только для клиринговых сертификатов (тип актива asset.type = "ASSET_TYPE_SECURITY" и security.type = clearing_certificate).
    } | {
        oneofKind: undefined;
    };
}
/**
 * Акция.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.AssetShare
 */
export interface AssetShare {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.ShareType type = 1;
     */
    type: ShareType; // Тип акции.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation issue_size = 2;
     */
    issueSize?: Quotation; // Объем выпуска (шт.).
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation nominal = 3;
     */
    nominal?: Quotation; // Номинал.
    /**
     * @generated from protobuf field: string nominal_currency = 4;
     */
    nominalCurrency: string; // Валюта номинала.
    /**
     * @generated from protobuf field: string primary_index = 5;
     */
    primaryIndex: string; // Индекс (Bloomberg).
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dividend_rate = 6;
     */
    dividendRate?: Quotation; // Ставка дивиденда (для привилегированных акций).
    /**
     * @generated from protobuf field: string preferred_share_type = 7;
     */
    preferredShareType: string; // Тип привилегированных акций.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp ipo_date = 8;
     */
    ipoDate?: Timestamp; // Дата IPO.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp registry_date = 9;
     */
    registryDate?: Timestamp; // Дата регистрации.
    /**
     * @generated from protobuf field: bool div_yield_flag = 10;
     */
    divYieldFlag: boolean; // Признак наличия дивидендной доходности.
    /**
     * @generated from protobuf field: string issue_kind = 11;
     */
    issueKind: string; // Форма выпуска ФИ.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp placement_date = 12;
     */
    placementDate?: Timestamp; // Дата размещения акции.
    /**
     * @generated from protobuf field: string repres_isin = 13;
     */
    represIsin: string; // ISIN базового актива.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation issue_size_plan = 14;
     */
    issueSizePlan?: Quotation; // Объявленное количество шт.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation total_float = 15;
     */
    totalFloat?: Quotation; // Количество акций в свободном обращении.
}
/**
 * Облигация.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.AssetBond
 */
export interface AssetBond {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation current_nominal = 1;
     */
    currentNominal?: Quotation; // Текущий номинал.
    /**
     * @generated from protobuf field: string borrow_name = 2;
     */
    borrowName: string; // Наименование заемщика.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation issue_size = 3;
     */
    issueSize?: Quotation; // Объем эмиссии облигации (стоимость).
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation nominal = 4;
     */
    nominal?: Quotation; // Номинал облигации.
    /**
     * @generated from protobuf field: string nominal_currency = 5;
     */
    nominalCurrency: string; // Валюта номинала.
    /**
     * @generated from protobuf field: string issue_kind = 6;
     */
    issueKind: string; // Форма выпуска облигации.
    /**
     * @generated from protobuf field: string interest_kind = 7;
     */
    interestKind: string; // Форма дохода облигации.
    /**
     * @generated from protobuf field: int32 coupon_quantity_per_year = 8;
     */
    couponQuantityPerYear: number; // Количество выплат в год.
    /**
     * @generated from protobuf field: bool indexed_nominal_flag = 9;
     */
    indexedNominalFlag: boolean; // Признак облигации с индексируемым номиналом.
    /**
     * @generated from protobuf field: bool subordinated_flag = 10;
     */
    subordinatedFlag: boolean; // Признак субординированной облигации.
    /**
     * @generated from protobuf field: bool collateral_flag = 11;
     */
    collateralFlag: boolean; // Признак обеспеченной облигации.
    /**
     * @generated from protobuf field: bool tax_free_flag = 12;
     */
    taxFreeFlag: boolean; // Признак показывает, что купоны облигации не облагаются налогом (для mass market).
    /**
     * @generated from protobuf field: bool amortization_flag = 13;
     */
    amortizationFlag: boolean; // Признак облигации с амортизацией долга.
    /**
     * @generated from protobuf field: bool floating_coupon_flag = 14;
     */
    floatingCouponFlag: boolean; // Признак облигации с плавающим купоном.
    /**
     * @generated from protobuf field: bool perpetual_flag = 15;
     */
    perpetualFlag: boolean; // Признак бессрочной облигации.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp maturity_date = 16;
     */
    maturityDate?: Timestamp; // Дата погашения облигации.
    /**
     * @generated from protobuf field: string return_condition = 17;
     */
    returnCondition: string; // Описание и условия получения дополнительного дохода.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp state_reg_date = 18;
     */
    stateRegDate?: Timestamp; // Дата выпуска облигации.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp placement_date = 19;
     */
    placementDate?: Timestamp; // Дата размещения облигации.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation placement_price = 20;
     */
    placementPrice?: Quotation; // Цена размещения облигации.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation issue_size_plan = 21;
     */
    issueSizePlan?: Quotation; // Объявленное количество шт.
}
/**
 * Структурная нота.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.AssetStructuredProduct
 */
export interface AssetStructuredProduct {
    /**
     * @generated from protobuf field: string borrow_name = 1;
     */
    borrowName: string; // Наименование заемщика.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation nominal = 2;
     */
    nominal?: Quotation; // Номинал.
    /**
     * @generated from protobuf field: string nominal_currency = 3;
     */
    nominalCurrency: string; // Валюта номинала.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.StructuredProductType type = 4;
     */
    type: StructuredProductType; // Тип структурной ноты.
    /**
     * @generated from protobuf field: string logic_portfolio = 5;
     */
    logicPortfolio: string; // Стратегия портфеля.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.AssetType asset_type = 6;
     */
    assetType: AssetType; // Тип базового актива.
    /**
     * @generated from protobuf field: string basic_asset = 7;
     */
    basicAsset: string; // Вид базового актива в зависимости от типа базового актива.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation safety_barrier = 8;
     */
    safetyBarrier?: Quotation; // Барьер сохранности (в процентах).
    /**
     * @generated from protobuf field: google.protobuf.Timestamp maturity_date = 9;
     */
    maturityDate?: Timestamp; // Дата погашения.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation issue_size_plan = 10;
     */
    issueSizePlan?: Quotation; // Объявленное количество шт.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation issue_size = 11;
     */
    issueSize?: Quotation; // Объем размещения.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp placement_date = 12;
     */
    placementDate?: Timestamp; // Дата размещения ноты.
    /**
     * @generated from protobuf field: string issue_kind = 13;
     */
    issueKind: string; // Форма выпуска.
}
/**
 * Фонд.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.AssetEtf
 */
export interface AssetEtf {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation total_expense = 1;
     */
    totalExpense?: Quotation; // Суммарные расходы фонда (в %).
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation hurdle_rate = 2;
     */
    hurdleRate?: Quotation; // Барьерная ставка доходности после которой фонд имеет право на perfomance fee (в процентах).
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation performance_fee = 3;
     */
    performanceFee?: Quotation; // Комиссия за успешные результаты фонда (в процентах).
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation fixed_commission = 4;
     */
    fixedCommission?: Quotation; // Фиксированная комиссия за управление (в процентах).
    /**
     * @generated from protobuf field: string payment_type = 5;
     */
    paymentType: string; // Тип распределения доходов от выплат по бумагам.
    /**
     * @generated from protobuf field: bool watermark_flag = 6;
     */
    watermarkFlag: boolean; // Признак необходимости выхода фонда в плюс для получения комиссии.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation buy_premium = 7;
     */
    buyPremium?: Quotation; // Премия (надбавка к цене) при покупке доли в фонде (в процентах).
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation sell_discount = 8;
     */
    sellDiscount?: Quotation; // Ставка дисконта (вычет из цены) при продаже доли в фонде (в процентах).
    /**
     * @generated from protobuf field: bool rebalancing_flag = 9;
     */
    rebalancingFlag: boolean; // Признак ребалансируемости портфеля фонда.
    /**
     * @generated from protobuf field: string rebalancing_freq = 10;
     */
    rebalancingFreq: string; // Периодичность ребалансировки.
    /**
     * @generated from protobuf field: string management_type = 11;
     */
    managementType: string; // Тип управления.
    /**
     * @generated from protobuf field: string primary_index = 12;
     */
    primaryIndex: string; // Индекс, который реплицирует (старается копировать) фонд.
    /**
     * @generated from protobuf field: string focus_type = 13;
     */
    focusType: string; // База ETF.
    /**
     * @generated from protobuf field: bool leveraged_flag = 14;
     */
    leveragedFlag: boolean; // Признак использования заемных активов (плечо).
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation num_share = 15;
     */
    numShare?: Quotation; // Количество акций в обращении.
    /**
     * @generated from protobuf field: bool ucits_flag = 16;
     */
    ucitsFlag: boolean; // Признак обязательства по отчетности перед регулятором.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp released_date = 17;
     */
    releasedDate?: Timestamp; // Дата выпуска.
    /**
     * @generated from protobuf field: string description = 18;
     */
    description: string; // Описание фонда.
    /**
     * @generated from protobuf field: string primary_index_description = 19;
     */
    primaryIndexDescription: string; // Описание индекса, за которым следует фонд.
    /**
     * @generated from protobuf field: string primary_index_company = 20;
     */
    primaryIndexCompany: string; // Основные компании, в которые вкладывается фонд.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation index_recovery_period = 21;
     */
    indexRecoveryPeriod?: Quotation; // Срок восстановления индекса (после просадки).
    /**
     * @generated from protobuf field: string inav_code = 22;
     */
    inavCode: string; // IVAV-код.
    /**
     * @generated from protobuf field: bool div_yield_flag = 23;
     */
    divYieldFlag: boolean; // Признак наличия дивидендной доходности.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation expense_commission = 24;
     */
    expenseCommission?: Quotation; // Комиссия на покрытие расходов фонда (в процентах).
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation primary_index_tracking_error = 25;
     */
    primaryIndexTrackingError?: Quotation; // Ошибка следования за индексом (в процентах).
    /**
     * @generated from protobuf field: string rebalancing_plan = 26;
     */
    rebalancingPlan: string; // Плановая ребалансировка портфеля.
    /**
     * @generated from protobuf field: string tax_rate = 27;
     */
    taxRate: string; // Ставки налогообложения дивидендов и купонов.
    /**
     * @generated from protobuf field: repeated google.protobuf.Timestamp rebalancing_dates = 28;
     */
    rebalancingDates: Timestamp[]; // Даты ребалансировок.
    /**
     * @generated from protobuf field: string issue_kind = 29;
     */
    issueKind: string; // Форма выпуска.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation nominal = 30;
     */
    nominal?: Quotation; // Номинал.
    /**
     * @generated from protobuf field: string nominal_currency = 31;
     */
    nominalCurrency: string; // Валюта номинала.
}
/**
 * Клиринговый сертификат участия.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.AssetClearingCertificate
 */
export interface AssetClearingCertificate {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation nominal = 1;
     */
    nominal?: Quotation; // Номинал.
    /**
     * @generated from protobuf field: string nominal_currency = 2;
     */
    nominalCurrency: string; // Валюта номинала.
}
/**
 * Бренд.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.Brand
 */
export interface Brand {
    /**
     * @generated from protobuf field: string uid = 1;
     */
    uid: string; // uid идентификатор бренда.
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string; // Наименование бренда.
    /**
     * @generated from protobuf field: string description = 3;
     */
    description: string; // Описание.
    /**
     * @generated from protobuf field: string info = 4;
     */
    info: string; // Информация о бренде.
    /**
     * @generated from protobuf field: string company = 5;
     */
    company: string; // Компания.
    /**
     * @generated from protobuf field: string sector = 6;
     */
    sector: string; // Сектор.
    /**
     * @generated from protobuf field: string country_of_risk = 7;
     */
    countryOfRisk: string; // Код страны риска.
    /**
     * @generated from protobuf field: string country_of_risk_name = 8;
     */
    countryOfRiskName: string; // Наименование страны риска.
}
/**
 * Идентификаторы инструмента.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.AssetInstrument
 */
export interface AssetInstrument {
    /**
     * @generated from protobuf field: string uid = 1;
     */
    uid: string; // uid идентификатор инструмента.
    /**
     * @generated from protobuf field: string figi = 2;
     */
    figi: string; // figi идентификатор инструмента.
    /**
     * @generated from protobuf field: string instrument_type = 3;
     */
    instrumentType: string; // Тип инструмента.
    /**
     * @generated from protobuf field: string ticker = 4;
     */
    ticker: string; // Тикер инструмента.
    /**
     * @generated from protobuf field: string class_code = 5;
     */
    classCode: string; // Класс-код (секция торгов).
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.InstrumentLink links = 6;
     */
    links: InstrumentLink[]; // Массив связанных инструментов.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.InstrumentType instrument_kind = 10;
     */
    instrumentKind: InstrumentType; // Тип инструмента.
}
/**
 * Связь с другим инструментом.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.InstrumentLink
 */
export interface InstrumentLink {
    /**
     * @generated from protobuf field: string type = 1;
     */
    type: string; // Тип связи.
    /**
     * @generated from protobuf field: string instrument_uid = 2;
     */
    instrumentUid: string; // uid идентификатор связанного инструмента.
}
/**
 * Запрос списка избранных инструментов, входные параметры не требуются.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetFavoritesRequest
 */
export interface GetFavoritesRequest {
}
/**
 * В ответ передаётся список избранных инструментов в качестве массива.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetFavoritesResponse
 */
export interface GetFavoritesResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.FavoriteInstrument favorite_instruments = 1;
     */
    favoriteInstruments: FavoriteInstrument[]; // Массив инструментов
}
/**
 * Массив избранных инструментов.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.FavoriteInstrument
 */
export interface FavoriteInstrument {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: string ticker = 2;
     */
    ticker: string; // Тикер инструмента.
    /**
     * @generated from protobuf field: string class_code = 3;
     */
    classCode: string; // Класс-код инструмента.
    /**
     * @generated from protobuf field: string isin = 4;
     */
    isin: string; // Isin-идентификатор инструмента.
    /**
     * @generated from protobuf field: string instrument_type = 11;
     */
    instrumentType: string; // Тип инструмента.
    /**
     * @generated from protobuf field: bool otc_flag = 16;
     */
    otcFlag: boolean; // Признак внебиржевой ценной бумаги.
    /**
     * @generated from protobuf field: bool api_trade_available_flag = 17;
     */
    apiTradeAvailableFlag: boolean; // Параметр указывает на возможность торговать инструментом через API.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.InstrumentType instrument_kind = 18;
     */
    instrumentKind: InstrumentType; // Тип инструмента.
}
/**
 * Запрос редактирования списка избранных инструментов.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.EditFavoritesRequest
 */
export interface EditFavoritesRequest {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.EditFavoritesRequestInstrument instruments = 1;
     */
    instruments: EditFavoritesRequestInstrument[]; // Массив инструментов.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.EditFavoritesActionType action_type = 6;
     */
    actionType: EditFavoritesActionType; // Тип действия со списком.
}
/**
 * Массив инструментов для редактирования списка избранных инструментов.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.EditFavoritesRequestInstrument
 */
export interface EditFavoritesRequestInstrument {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
}
/**
 * Результат редактирования списка избранных инструментов.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.EditFavoritesResponse
 */
export interface EditFavoritesResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.FavoriteInstrument favorite_instruments = 1;
     */
    favoriteInstruments: FavoriteInstrument[]; // Массив инструментов
}
/**
 * Запрос справочника стран.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetCountriesRequest
 */
export interface GetCountriesRequest {
}
/**
 * Справочник стран.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetCountriesResponse
 */
export interface GetCountriesResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.CountryResponse countries = 1;
     */
    countries: CountryResponse[]; // Массив стран.
}
/**
 * Данные о стране.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.CountryResponse
 */
export interface CountryResponse {
    /**
     * @generated from protobuf field: string alfa_two = 1;
     */
    alfaTwo: string; // Двухбуквенный код страны.
    /**
     * @generated from protobuf field: string alfa_three = 2;
     */
    alfaThree: string; // Трёхбуквенный код страны.
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string; // Наименование страны.
    /**
     * @generated from protobuf field: string name_brief = 4;
     */
    nameBrief: string; // Краткое наименование страны.
}
/**
 * Запрос на поиск инструментов.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.FindInstrumentRequest
 */
export interface FindInstrumentRequest {
    /**
     * @generated from protobuf field: string query = 1;
     */
    query: string; // Строка поиска.
}
/**
 * Результат поиска инструментов.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.FindInstrumentResponse
 */
export interface FindInstrumentResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.InstrumentShort instruments = 1;
     */
    instruments: InstrumentShort[]; // Массив инструментов, удовлетворяющих условиям поиска.
}
/**
 * Краткая информация об инструменте.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.InstrumentShort
 */
export interface InstrumentShort {
    /**
     * @generated from protobuf field: string isin = 1;
     */
    isin: string; // Isin инструмента.
    /**
     * @generated from protobuf field: string figi = 2;
     */
    figi: string; // Figi инструмента.
    /**
     * @generated from protobuf field: string ticker = 3;
     */
    ticker: string; // Ticker инструмента.
    /**
     * @generated from protobuf field: string class_code = 4;
     */
    classCode: string; // ClassCode инструмента.
    /**
     * @generated from protobuf field: string instrument_type = 5;
     */
    instrumentType: string; // Тип инструмента.
    /**
     * @generated from protobuf field: string name = 6;
     */
    name: string; // Название инструмента.
    /**
     * @generated from protobuf field: string uid = 7;
     */
    uid: string; // Уникальный идентификатор инструмента.
    /**
     * @generated from protobuf field: string position_uid = 8;
     */
    positionUid: string; // Уникальный идентификатор позиции инструмента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.InstrumentType instrument_kind = 10;
     */
    instrumentKind: InstrumentType; // Тип инструмента.
    /**
     * @generated from protobuf field: bool api_trade_available_flag = 11;
     */
    apiTradeAvailableFlag: boolean; // Параметр указывает на возможность торговать инструментом через API.
    /**
     * @generated from protobuf field: bool for_iis_flag = 12;
     */
    forIisFlag: boolean; // Признак доступности для ИИС.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp first_1min_candle_date = 26 [json_name = "first1minCandleDate"];
     */
    first1MinCandleDate?: Timestamp; // Дата первой минутной свечи.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp first_1day_candle_date = 27 [json_name = "first1dayCandleDate"];
     */
    first1DayCandleDate?: Timestamp; // Дата первой дневной свечи.
    /**
     * @generated from protobuf field: bool for_qual_investor_flag = 28;
     */
    forQualInvestorFlag: boolean; // Флаг отображающий доступность торговли инструментом только для квалифицированных инвесторов.
    /**
     * @generated from protobuf field: bool weekend_flag = 29;
     */
    weekendFlag: boolean; // Флаг отображающий доступность торговли инструментом по выходным
    /**
     * @generated from protobuf field: bool blocked_tca_flag = 30;
     */
    blockedTcaFlag: boolean; // Флаг заблокированного ТКС
}
/**
 * Запрос списка брендов.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetBrandsRequest
 */
export interface GetBrandsRequest {
}
/**
 * Запрос бренда.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetBrandRequest
 */
export interface GetBrandRequest {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string; // Uid-идентификатор бренда.
}
/**
 * Список брендов.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetBrandsResponse
 */
export interface GetBrandsResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.Brand brands = 1;
     */
    brands: Brand[]; // Массив брендов.
}
/**
 * Тип купонов.
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.CouponType
 */
export enum CouponType {
    /**
     * Неопределенное значение
     *
     * @generated from protobuf enum value: COUPON_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Постоянный
     *
     * @generated from protobuf enum value: COUPON_TYPE_CONSTANT = 1;
     */
    CONSTANT = 1,
    /**
     * Плавающий
     *
     * @generated from protobuf enum value: COUPON_TYPE_FLOATING = 2;
     */
    FLOATING = 2,
    /**
     * Дисконт
     *
     * @generated from protobuf enum value: COUPON_TYPE_DISCOUNT = 3;
     */
    DISCOUNT = 3,
    /**
     * Ипотечный
     *
     * @generated from protobuf enum value: COUPON_TYPE_MORTGAGE = 4;
     */
    MORTGAGE = 4,
    /**
     * Фиксированный
     *
     * @generated from protobuf enum value: COUPON_TYPE_FIX = 5;
     */
    FIX = 5,
    /**
     * Переменный
     *
     * @generated from protobuf enum value: COUPON_TYPE_VARIABLE = 6;
     */
    VARIABLE = 6,
    /**
     * Прочее
     *
     * @generated from protobuf enum value: COUPON_TYPE_OTHER = 7;
     */
    OTHER = 7
}
/**
 * Тип опциона по направлению сделки.
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.OptionDirection
 */
export enum OptionDirection {
    /**
     * Тип не определен.
     *
     * @generated from protobuf enum value: OPTION_DIRECTION_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Опцион на продажу.
     *
     * @generated from protobuf enum value: OPTION_DIRECTION_PUT = 1;
     */
    PUT = 1,
    /**
     * Опцион на покупку.
     *
     * @generated from protobuf enum value: OPTION_DIRECTION_CALL = 2;
     */
    CALL = 2
}
/**
 * Тип расчетов по опциону.
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.OptionPaymentType
 */
export enum OptionPaymentType {
    /**
     * Тип не определен.
     *
     * @generated from protobuf enum value: OPTION_PAYMENT_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Опционы с использованием премии в расчетах.
     *
     * @generated from protobuf enum value: OPTION_PAYMENT_TYPE_PREMIUM = 1;
     */
    PREMIUM = 1,
    /**
     * Маржируемые опционы.
     *
     * @generated from protobuf enum value: OPTION_PAYMENT_TYPE_MARGINAL = 2;
     */
    MARGINAL = 2
}
/**
 * Тип опциона по стилю.
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.OptionStyle
 */
export enum OptionStyle {
    /**
     * Тип не определен.
     *
     * @generated from protobuf enum value: OPTION_STYLE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Американский опцион.
     *
     * @generated from protobuf enum value: OPTION_STYLE_AMERICAN = 1;
     */
    AMERICAN = 1,
    /**
     * Европейский опцион.
     *
     * @generated from protobuf enum value: OPTION_STYLE_EUROPEAN = 2;
     */
    EUROPEAN = 2
}
/**
 * Тип опциона по способу исполнения.
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.OptionSettlementType
 */
export enum OptionSettlementType {
    /**
     * Тип не определен.
     *
     * @generated from protobuf enum value: OPTION_EXECUTION_TYPE_UNSPECIFIED = 0;
     */
    OPTION_EXECUTION_TYPE_UNSPECIFIED = 0,
    /**
     * Поставочный тип опциона.
     *
     * @generated from protobuf enum value: OPTION_EXECUTION_TYPE_PHYSICAL_DELIVERY = 1;
     */
    OPTION_EXECUTION_TYPE_PHYSICAL_DELIVERY = 1,
    /**
     * Расчетный тип опциона.
     *
     * @generated from protobuf enum value: OPTION_EXECUTION_TYPE_CASH_SETTLEMENT = 2;
     */
    OPTION_EXECUTION_TYPE_CASH_SETTLEMENT = 2
}
/**
 * Тип идентификатора инструмента. Подробнее об идентификации инструментов: [Идентификация инструментов](https://tinkoff.github.io/investAPI/faq_identification/)
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.InstrumentIdType
 */
export enum InstrumentIdType {
    /**
     * Значение не определено.
     *
     * @generated from protobuf enum value: INSTRUMENT_ID_UNSPECIFIED = 0;
     */
    INSTRUMENT_ID_UNSPECIFIED = 0,
    /**
     * Figi.
     *
     * @generated from protobuf enum value: INSTRUMENT_ID_TYPE_FIGI = 1;
     */
    INSTRUMENT_ID_TYPE_FIGI = 1,
    /**
     * Ticker.
     *
     * @generated from protobuf enum value: INSTRUMENT_ID_TYPE_TICKER = 2;
     */
    INSTRUMENT_ID_TYPE_TICKER = 2,
    /**
     * Уникальный идентификатор.
     *
     * @generated from protobuf enum value: INSTRUMENT_ID_TYPE_UID = 3;
     */
    INSTRUMENT_ID_TYPE_UID = 3,
    /**
     * Идентификатор позиции.
     *
     * @generated from protobuf enum value: INSTRUMENT_ID_TYPE_POSITION_UID = 4;
     */
    INSTRUMENT_ID_TYPE_POSITION_UID = 4
}
/**
 * Статус запрашиваемых инструментов.
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.InstrumentStatus
 */
export enum InstrumentStatus {
    /**
     * Значение не определено.
     *
     * @generated from protobuf enum value: INSTRUMENT_STATUS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Базовый список инструментов (по умолчанию). Инструменты доступные для торговли через TINKOFF INVEST API.
     *
     * @generated from protobuf enum value: INSTRUMENT_STATUS_BASE = 1;
     */
    BASE = 1,
    /**
     * Список всех инструментов.
     *
     * @generated from protobuf enum value: INSTRUMENT_STATUS_ALL = 2;
     */
    ALL = 2
}
/**
 * Тип акций.
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.ShareType
 */
export enum ShareType {
    /**
     * Значение не определено.
     *
     * @generated from protobuf enum value: SHARE_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Обыкновенная
     *
     * @generated from protobuf enum value: SHARE_TYPE_COMMON = 1;
     */
    COMMON = 1,
    /**
     * Привилегированная
     *
     * @generated from protobuf enum value: SHARE_TYPE_PREFERRED = 2;
     */
    PREFERRED = 2,
    /**
     * Американские депозитарные расписки
     *
     * @generated from protobuf enum value: SHARE_TYPE_ADR = 3;
     */
    ADR = 3,
    /**
     * Глобальные депозитарные расписки
     *
     * @generated from protobuf enum value: SHARE_TYPE_GDR = 4;
     */
    GDR = 4,
    /**
     * Товарищество с ограниченной ответственностью
     *
     * @generated from protobuf enum value: SHARE_TYPE_MLP = 5;
     */
    MLP = 5,
    /**
     * Акции из реестра Нью-Йорка
     *
     * @generated from protobuf enum value: SHARE_TYPE_NY_REG_SHRS = 6;
     */
    NY_REG_SHRS = 6,
    /**
     * Закрытый инвестиционный фонд
     *
     * @generated from protobuf enum value: SHARE_TYPE_CLOSED_END_FUND = 7;
     */
    CLOSED_END_FUND = 7,
    /**
     * Траст недвижимости
     *
     * @generated from protobuf enum value: SHARE_TYPE_REIT = 8;
     */
    REIT = 8
}
/**
 * Тип актива.
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.AssetType
 */
export enum AssetType {
    /**
     * Тип не определён.
     *
     * @generated from protobuf enum value: ASSET_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Валюта.
     *
     * @generated from protobuf enum value: ASSET_TYPE_CURRENCY = 1;
     */
    CURRENCY = 1,
    /**
     * Товар.
     *
     * @generated from protobuf enum value: ASSET_TYPE_COMMODITY = 2;
     */
    COMMODITY = 2,
    /**
     * Индекс.
     *
     * @generated from protobuf enum value: ASSET_TYPE_INDEX = 3;
     */
    INDEX = 3,
    /**
     * Ценная бумага.
     *
     * @generated from protobuf enum value: ASSET_TYPE_SECURITY = 4;
     */
    SECURITY = 4
}
/**
 * Тип структурной ноты.
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.StructuredProductType
 */
export enum StructuredProductType {
    /**
     * Тип не определён.
     *
     * @generated from protobuf enum value: SP_TYPE_UNSPECIFIED = 0;
     */
    SP_TYPE_UNSPECIFIED = 0,
    /**
     * Поставочный.
     *
     * @generated from protobuf enum value: SP_TYPE_DELIVERABLE = 1;
     */
    SP_TYPE_DELIVERABLE = 1,
    /**
     * Беспоставочный.
     *
     * @generated from protobuf enum value: SP_TYPE_NON_DELIVERABLE = 2;
     */
    SP_TYPE_NON_DELIVERABLE = 2
}
/**
 * Тип действия со списком избранных инструментов.
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.EditFavoritesActionType
 */
export enum EditFavoritesActionType {
    /**
     * Тип не определён.
     *
     * @generated from protobuf enum value: EDIT_FAVORITES_ACTION_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Добавить в список.
     *
     * @generated from protobuf enum value: EDIT_FAVORITES_ACTION_TYPE_ADD = 1;
     */
    ADD = 1,
    /**
     * Удалить из списка.
     *
     * @generated from protobuf enum value: EDIT_FAVORITES_ACTION_TYPE_DEL = 2;
     */
    DEL = 2
}
/**
 * Реальная площадка исполнения расчётов.
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.RealExchange
 */
export enum RealExchange {
    /**
     * Тип не определён.
     *
     * @generated from protobuf enum value: REAL_EXCHANGE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Московская биржа.
     *
     * @generated from protobuf enum value: REAL_EXCHANGE_MOEX = 1;
     */
    MOEX = 1,
    /**
     * Санкт-Петербургская биржа.
     *
     * @generated from protobuf enum value: REAL_EXCHANGE_RTS = 2;
     */
    RTS = 2,
    /**
     * Внебиржевой инструмент.
     *
     * @generated from protobuf enum value: REAL_EXCHANGE_OTC = 3;
     */
    OTC = 3
}
/**
 * Уровень риска облигации.
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.RiskLevel
 */
export enum RiskLevel {
    /**
     * @generated from protobuf enum value: RISK_LEVEL_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Низкий уровень риска
     *
     * @generated from protobuf enum value: RISK_LEVEL_LOW = 1;
     */
    LOW = 1,
    /**
     * Средний уровень риска
     *
     * @generated from protobuf enum value: RISK_LEVEL_MODERATE = 2;
     */
    MODERATE = 2,
    /**
     * Высокий уровень риска
     *
     * @generated from protobuf enum value: RISK_LEVEL_HIGH = 3;
     */
    HIGH = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class TradingSchedulesRequest$Type extends MessageType<TradingSchedulesRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.TradingSchedulesRequest", [
            { no: 1, name: "exchange", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "from", kind: "message", T: () => Timestamp },
            { no: 3, name: "to", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<TradingSchedulesRequest>): TradingSchedulesRequest {
        const message = { exchange: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TradingSchedulesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradingSchedulesRequest): TradingSchedulesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string exchange */ 1:
                    message.exchange = reader.string();
                    break;
                case /* google.protobuf.Timestamp from */ 2:
                    message.from = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.from);
                    break;
                case /* google.protobuf.Timestamp to */ 3:
                    message.to = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.to);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradingSchedulesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string exchange = 1; */
        if (message.exchange !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.exchange);
        /* google.protobuf.Timestamp from = 2; */
        if (message.from)
            Timestamp.internalBinaryWrite(message.from, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp to = 3; */
        if (message.to)
            Timestamp.internalBinaryWrite(message.to, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.TradingSchedulesRequest
 */
export const TradingSchedulesRequest = new TradingSchedulesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradingSchedulesResponse$Type extends MessageType<TradingSchedulesResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.TradingSchedulesResponse", [
            { no: 1, name: "exchanges", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TradingSchedule }
        ]);
    }
    create(value?: PartialMessage<TradingSchedulesResponse>): TradingSchedulesResponse {
        const message = { exchanges: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TradingSchedulesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradingSchedulesResponse): TradingSchedulesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.TradingSchedule exchanges */ 1:
                    message.exchanges.push(TradingSchedule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradingSchedulesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.TradingSchedule exchanges = 1; */
        for (let i = 0; i < message.exchanges.length; i++)
            TradingSchedule.internalBinaryWrite(message.exchanges[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.TradingSchedulesResponse
 */
export const TradingSchedulesResponse = new TradingSchedulesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradingSchedule$Type extends MessageType<TradingSchedule> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.TradingSchedule", [
            { no: 1, name: "exchange", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "days", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TradingDay }
        ]);
    }
    create(value?: PartialMessage<TradingSchedule>): TradingSchedule {
        const message = { exchange: "", days: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TradingSchedule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradingSchedule): TradingSchedule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string exchange */ 1:
                    message.exchange = reader.string();
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.TradingDay days */ 2:
                    message.days.push(TradingDay.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradingSchedule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string exchange = 1; */
        if (message.exchange !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.exchange);
        /* repeated tinkoff.public.invest.api.contract.v1.TradingDay days = 2; */
        for (let i = 0; i < message.days.length; i++)
            TradingDay.internalBinaryWrite(message.days[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.TradingSchedule
 */
export const TradingSchedule = new TradingSchedule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradingDay$Type extends MessageType<TradingDay> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.TradingDay", [
            { no: 1, name: "date", kind: "message", T: () => Timestamp },
            { no: 2, name: "is_trading_day", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "start_time", kind: "message", T: () => Timestamp },
            { no: 4, name: "end_time", kind: "message", T: () => Timestamp },
            { no: 7, name: "opening_auction_start_time", kind: "message", T: () => Timestamp },
            { no: 8, name: "closing_auction_end_time", kind: "message", T: () => Timestamp },
            { no: 9, name: "evening_opening_auction_start_time", kind: "message", T: () => Timestamp },
            { no: 10, name: "evening_start_time", kind: "message", T: () => Timestamp },
            { no: 11, name: "evening_end_time", kind: "message", T: () => Timestamp },
            { no: 12, name: "clearing_start_time", kind: "message", T: () => Timestamp },
            { no: 13, name: "clearing_end_time", kind: "message", T: () => Timestamp },
            { no: 14, name: "premarket_start_time", kind: "message", T: () => Timestamp },
            { no: 15, name: "premarket_end_time", kind: "message", T: () => Timestamp },
            { no: 16, name: "closing_auction_start_time", kind: "message", T: () => Timestamp },
            { no: 17, name: "opening_auction_end_time", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<TradingDay>): TradingDay {
        const message = { isTradingDay: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TradingDay>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradingDay): TradingDay {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp date */ 1:
                    message.date = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.date);
                    break;
                case /* bool is_trading_day */ 2:
                    message.isTradingDay = reader.bool();
                    break;
                case /* google.protobuf.Timestamp start_time */ 3:
                    message.startTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.startTime);
                    break;
                case /* google.protobuf.Timestamp end_time */ 4:
                    message.endTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.endTime);
                    break;
                case /* google.protobuf.Timestamp opening_auction_start_time */ 7:
                    message.openingAuctionStartTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.openingAuctionStartTime);
                    break;
                case /* google.protobuf.Timestamp closing_auction_end_time */ 8:
                    message.closingAuctionEndTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.closingAuctionEndTime);
                    break;
                case /* google.protobuf.Timestamp evening_opening_auction_start_time */ 9:
                    message.eveningOpeningAuctionStartTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.eveningOpeningAuctionStartTime);
                    break;
                case /* google.protobuf.Timestamp evening_start_time */ 10:
                    message.eveningStartTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.eveningStartTime);
                    break;
                case /* google.protobuf.Timestamp evening_end_time */ 11:
                    message.eveningEndTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.eveningEndTime);
                    break;
                case /* google.protobuf.Timestamp clearing_start_time */ 12:
                    message.clearingStartTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.clearingStartTime);
                    break;
                case /* google.protobuf.Timestamp clearing_end_time */ 13:
                    message.clearingEndTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.clearingEndTime);
                    break;
                case /* google.protobuf.Timestamp premarket_start_time */ 14:
                    message.premarketStartTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.premarketStartTime);
                    break;
                case /* google.protobuf.Timestamp premarket_end_time */ 15:
                    message.premarketEndTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.premarketEndTime);
                    break;
                case /* google.protobuf.Timestamp closing_auction_start_time */ 16:
                    message.closingAuctionStartTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.closingAuctionStartTime);
                    break;
                case /* google.protobuf.Timestamp opening_auction_end_time */ 17:
                    message.openingAuctionEndTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.openingAuctionEndTime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradingDay, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp date = 1; */
        if (message.date)
            Timestamp.internalBinaryWrite(message.date, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool is_trading_day = 2; */
        if (message.isTradingDay !== false)
            writer.tag(2, WireType.Varint).bool(message.isTradingDay);
        /* google.protobuf.Timestamp start_time = 3; */
        if (message.startTime)
            Timestamp.internalBinaryWrite(message.startTime, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp end_time = 4; */
        if (message.endTime)
            Timestamp.internalBinaryWrite(message.endTime, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp opening_auction_start_time = 7; */
        if (message.openingAuctionStartTime)
            Timestamp.internalBinaryWrite(message.openingAuctionStartTime, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp closing_auction_end_time = 8; */
        if (message.closingAuctionEndTime)
            Timestamp.internalBinaryWrite(message.closingAuctionEndTime, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp evening_opening_auction_start_time = 9; */
        if (message.eveningOpeningAuctionStartTime)
            Timestamp.internalBinaryWrite(message.eveningOpeningAuctionStartTime, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp evening_start_time = 10; */
        if (message.eveningStartTime)
            Timestamp.internalBinaryWrite(message.eveningStartTime, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp evening_end_time = 11; */
        if (message.eveningEndTime)
            Timestamp.internalBinaryWrite(message.eveningEndTime, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp clearing_start_time = 12; */
        if (message.clearingStartTime)
            Timestamp.internalBinaryWrite(message.clearingStartTime, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp clearing_end_time = 13; */
        if (message.clearingEndTime)
            Timestamp.internalBinaryWrite(message.clearingEndTime, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp premarket_start_time = 14; */
        if (message.premarketStartTime)
            Timestamp.internalBinaryWrite(message.premarketStartTime, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp premarket_end_time = 15; */
        if (message.premarketEndTime)
            Timestamp.internalBinaryWrite(message.premarketEndTime, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp closing_auction_start_time = 16; */
        if (message.closingAuctionStartTime)
            Timestamp.internalBinaryWrite(message.closingAuctionStartTime, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp opening_auction_end_time = 17; */
        if (message.openingAuctionEndTime)
            Timestamp.internalBinaryWrite(message.openingAuctionEndTime, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.TradingDay
 */
export const TradingDay = new TradingDay$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstrumentRequest$Type extends MessageType<InstrumentRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.InstrumentRequest", [
            { no: 1, name: "id_type", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.InstrumentIdType", InstrumentIdType] },
            { no: 2, name: "class_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<InstrumentRequest>): InstrumentRequest {
        const message = { idType: 0, classCode: "", id: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InstrumentRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstrumentRequest): InstrumentRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.InstrumentIdType id_type */ 1:
                    message.idType = reader.int32();
                    break;
                case /* string class_code */ 2:
                    message.classCode = reader.string();
                    break;
                case /* string id */ 3:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InstrumentRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.InstrumentIdType id_type = 1; */
        if (message.idType !== 0)
            writer.tag(1, WireType.Varint).int32(message.idType);
        /* string class_code = 2; */
        if (message.classCode !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.classCode);
        /* string id = 3; */
        if (message.id !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.InstrumentRequest
 */
export const InstrumentRequest = new InstrumentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstrumentsRequest$Type extends MessageType<InstrumentsRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.InstrumentsRequest", [
            { no: 1, name: "instrument_status", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.InstrumentStatus", InstrumentStatus, "INSTRUMENT_STATUS_"] }
        ]);
    }
    create(value?: PartialMessage<InstrumentsRequest>): InstrumentsRequest {
        const message = { instrumentStatus: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InstrumentsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstrumentsRequest): InstrumentsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.InstrumentStatus instrument_status */ 1:
                    message.instrumentStatus = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InstrumentsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.InstrumentStatus instrument_status = 1; */
        if (message.instrumentStatus !== 0)
            writer.tag(1, WireType.Varint).int32(message.instrumentStatus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.InstrumentsRequest
 */
export const InstrumentsRequest = new InstrumentsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BondResponse$Type extends MessageType<BondResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.BondResponse", [
            { no: 1, name: "instrument", kind: "message", T: () => Bond }
        ]);
    }
    create(value?: PartialMessage<BondResponse>): BondResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BondResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BondResponse): BondResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.Bond instrument */ 1:
                    message.instrument = Bond.internalBinaryRead(reader, reader.uint32(), options, message.instrument);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BondResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.Bond instrument = 1; */
        if (message.instrument)
            Bond.internalBinaryWrite(message.instrument, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.BondResponse
 */
export const BondResponse = new BondResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BondsResponse$Type extends MessageType<BondsResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.BondsResponse", [
            { no: 1, name: "instruments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Bond }
        ]);
    }
    create(value?: PartialMessage<BondsResponse>): BondsResponse {
        const message = { instruments: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BondsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BondsResponse): BondsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.Bond instruments */ 1:
                    message.instruments.push(Bond.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BondsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.Bond instruments = 1; */
        for (let i = 0; i < message.instruments.length; i++)
            Bond.internalBinaryWrite(message.instruments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.BondsResponse
 */
export const BondsResponse = new BondsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBondCouponsRequest$Type extends MessageType<GetBondCouponsRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetBondCouponsRequest", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "from", kind: "message", T: () => Timestamp },
            { no: 3, name: "to", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<GetBondCouponsRequest>): GetBondCouponsRequest {
        const message = { figi: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetBondCouponsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBondCouponsRequest): GetBondCouponsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* google.protobuf.Timestamp from */ 2:
                    message.from = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.from);
                    break;
                case /* google.protobuf.Timestamp to */ 3:
                    message.to = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.to);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBondCouponsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* google.protobuf.Timestamp from = 2; */
        if (message.from)
            Timestamp.internalBinaryWrite(message.from, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp to = 3; */
        if (message.to)
            Timestamp.internalBinaryWrite(message.to, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetBondCouponsRequest
 */
export const GetBondCouponsRequest = new GetBondCouponsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBondCouponsResponse$Type extends MessageType<GetBondCouponsResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetBondCouponsResponse", [
            { no: 1, name: "events", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Coupon }
        ]);
    }
    create(value?: PartialMessage<GetBondCouponsResponse>): GetBondCouponsResponse {
        const message = { events: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetBondCouponsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBondCouponsResponse): GetBondCouponsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.Coupon events */ 1:
                    message.events.push(Coupon.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBondCouponsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.Coupon events = 1; */
        for (let i = 0; i < message.events.length; i++)
            Coupon.internalBinaryWrite(message.events[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetBondCouponsResponse
 */
export const GetBondCouponsResponse = new GetBondCouponsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Coupon$Type extends MessageType<Coupon> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.Coupon", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "coupon_date", kind: "message", T: () => Timestamp },
            { no: 3, name: "coupon_number", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 4, name: "fix_date", kind: "message", T: () => Timestamp },
            { no: 5, name: "pay_one_bond", kind: "message", T: () => MoneyValue },
            { no: 6, name: "coupon_type", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.CouponType", CouponType, "COUPON_TYPE_"] },
            { no: 7, name: "coupon_start_date", kind: "message", T: () => Timestamp },
            { no: 8, name: "coupon_end_date", kind: "message", T: () => Timestamp },
            { no: 9, name: "coupon_period", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Coupon>): Coupon {
        const message = { figi: "", couponNumber: "0", couponType: 0, couponPeriod: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Coupon>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Coupon): Coupon {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* google.protobuf.Timestamp coupon_date */ 2:
                    message.couponDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.couponDate);
                    break;
                case /* int64 coupon_number */ 3:
                    message.couponNumber = reader.int64().toString();
                    break;
                case /* google.protobuf.Timestamp fix_date */ 4:
                    message.fixDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.fixDate);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue pay_one_bond */ 5:
                    message.payOneBond = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.payOneBond);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.CouponType coupon_type */ 6:
                    message.couponType = reader.int32();
                    break;
                case /* google.protobuf.Timestamp coupon_start_date */ 7:
                    message.couponStartDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.couponStartDate);
                    break;
                case /* google.protobuf.Timestamp coupon_end_date */ 8:
                    message.couponEndDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.couponEndDate);
                    break;
                case /* int32 coupon_period */ 9:
                    message.couponPeriod = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Coupon, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* google.protobuf.Timestamp coupon_date = 2; */
        if (message.couponDate)
            Timestamp.internalBinaryWrite(message.couponDate, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int64 coupon_number = 3; */
        if (message.couponNumber !== "0")
            writer.tag(3, WireType.Varint).int64(message.couponNumber);
        /* google.protobuf.Timestamp fix_date = 4; */
        if (message.fixDate)
            Timestamp.internalBinaryWrite(message.fixDate, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue pay_one_bond = 5; */
        if (message.payOneBond)
            MoneyValue.internalBinaryWrite(message.payOneBond, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.CouponType coupon_type = 6; */
        if (message.couponType !== 0)
            writer.tag(6, WireType.Varint).int32(message.couponType);
        /* google.protobuf.Timestamp coupon_start_date = 7; */
        if (message.couponStartDate)
            Timestamp.internalBinaryWrite(message.couponStartDate, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp coupon_end_date = 8; */
        if (message.couponEndDate)
            Timestamp.internalBinaryWrite(message.couponEndDate, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* int32 coupon_period = 9; */
        if (message.couponPeriod !== 0)
            writer.tag(9, WireType.Varint).int32(message.couponPeriod);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.Coupon
 */
export const Coupon = new Coupon$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CurrencyResponse$Type extends MessageType<CurrencyResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.CurrencyResponse", [
            { no: 1, name: "instrument", kind: "message", T: () => Currency }
        ]);
    }
    create(value?: PartialMessage<CurrencyResponse>): CurrencyResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CurrencyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CurrencyResponse): CurrencyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.Currency instrument */ 1:
                    message.instrument = Currency.internalBinaryRead(reader, reader.uint32(), options, message.instrument);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CurrencyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.Currency instrument = 1; */
        if (message.instrument)
            Currency.internalBinaryWrite(message.instrument, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.CurrencyResponse
 */
export const CurrencyResponse = new CurrencyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CurrenciesResponse$Type extends MessageType<CurrenciesResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.CurrenciesResponse", [
            { no: 1, name: "instruments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Currency }
        ]);
    }
    create(value?: PartialMessage<CurrenciesResponse>): CurrenciesResponse {
        const message = { instruments: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CurrenciesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CurrenciesResponse): CurrenciesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.Currency instruments */ 1:
                    message.instruments.push(Currency.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CurrenciesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.Currency instruments = 1; */
        for (let i = 0; i < message.instruments.length; i++)
            Currency.internalBinaryWrite(message.instruments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.CurrenciesResponse
 */
export const CurrenciesResponse = new CurrenciesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EtfResponse$Type extends MessageType<EtfResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.EtfResponse", [
            { no: 1, name: "instrument", kind: "message", T: () => Etf }
        ]);
    }
    create(value?: PartialMessage<EtfResponse>): EtfResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EtfResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EtfResponse): EtfResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.Etf instrument */ 1:
                    message.instrument = Etf.internalBinaryRead(reader, reader.uint32(), options, message.instrument);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EtfResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.Etf instrument = 1; */
        if (message.instrument)
            Etf.internalBinaryWrite(message.instrument, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.EtfResponse
 */
export const EtfResponse = new EtfResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EtfsResponse$Type extends MessageType<EtfsResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.EtfsResponse", [
            { no: 1, name: "instruments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Etf }
        ]);
    }
    create(value?: PartialMessage<EtfsResponse>): EtfsResponse {
        const message = { instruments: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EtfsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EtfsResponse): EtfsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.Etf instruments */ 1:
                    message.instruments.push(Etf.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EtfsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.Etf instruments = 1; */
        for (let i = 0; i < message.instruments.length; i++)
            Etf.internalBinaryWrite(message.instruments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.EtfsResponse
 */
export const EtfsResponse = new EtfsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FutureResponse$Type extends MessageType<FutureResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.FutureResponse", [
            { no: 1, name: "instrument", kind: "message", T: () => Future }
        ]);
    }
    create(value?: PartialMessage<FutureResponse>): FutureResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FutureResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FutureResponse): FutureResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.Future instrument */ 1:
                    message.instrument = Future.internalBinaryRead(reader, reader.uint32(), options, message.instrument);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FutureResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.Future instrument = 1; */
        if (message.instrument)
            Future.internalBinaryWrite(message.instrument, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.FutureResponse
 */
export const FutureResponse = new FutureResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FuturesResponse$Type extends MessageType<FuturesResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.FuturesResponse", [
            { no: 1, name: "instruments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Future }
        ]);
    }
    create(value?: PartialMessage<FuturesResponse>): FuturesResponse {
        const message = { instruments: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FuturesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FuturesResponse): FuturesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.Future instruments */ 1:
                    message.instruments.push(Future.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FuturesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.Future instruments = 1; */
        for (let i = 0; i < message.instruments.length; i++)
            Future.internalBinaryWrite(message.instruments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.FuturesResponse
 */
export const FuturesResponse = new FuturesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OptionResponse$Type extends MessageType<OptionResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.OptionResponse", [
            { no: 1, name: "instrument", kind: "message", T: () => Option }
        ]);
    }
    create(value?: PartialMessage<OptionResponse>): OptionResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OptionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OptionResponse): OptionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.Option instrument */ 1:
                    message.instrument = Option.internalBinaryRead(reader, reader.uint32(), options, message.instrument);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OptionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.Option instrument = 1; */
        if (message.instrument)
            Option.internalBinaryWrite(message.instrument, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.OptionResponse
 */
export const OptionResponse = new OptionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OptionsResponse$Type extends MessageType<OptionsResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.OptionsResponse", [
            { no: 1, name: "instruments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Option }
        ]);
    }
    create(value?: PartialMessage<OptionsResponse>): OptionsResponse {
        const message = { instruments: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OptionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OptionsResponse): OptionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.Option instruments */ 1:
                    message.instruments.push(Option.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OptionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.Option instruments = 1; */
        for (let i = 0; i < message.instruments.length; i++)
            Option.internalBinaryWrite(message.instruments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.OptionsResponse
 */
export const OptionsResponse = new OptionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Option$Type extends MessageType<Option> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.Option", [
            { no: 1, name: "uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "position_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "class_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "basic_asset_position_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 21, name: "trading_status", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.SecurityTradingStatus", SecurityTradingStatus, "SECURITY_TRADING_STATUS_"] },
            { no: 31, name: "real_exchange", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.RealExchange", RealExchange, "REAL_EXCHANGE_"] },
            { no: 41, name: "direction", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.OptionDirection", OptionDirection, "OPTION_DIRECTION_"] },
            { no: 42, name: "payment_type", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.OptionPaymentType", OptionPaymentType, "OPTION_PAYMENT_TYPE_"] },
            { no: 43, name: "style", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.OptionStyle", OptionStyle, "OPTION_STYLE_"] },
            { no: 44, name: "settlement_type", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.OptionSettlementType", OptionSettlementType] },
            { no: 101, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 111, name: "currency", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 112, name: "settlement_currency", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 131, name: "asset_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 132, name: "basic_asset", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 141, name: "exchange", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 151, name: "country_of_risk", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 152, name: "country_of_risk_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 161, name: "sector", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 201, name: "lot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 211, name: "basic_asset_size", kind: "message", T: () => Quotation },
            { no: 221, name: "klong", kind: "message", T: () => Quotation },
            { no: 222, name: "kshort", kind: "message", T: () => Quotation },
            { no: 223, name: "dlong", kind: "message", T: () => Quotation },
            { no: 224, name: "dshort", kind: "message", T: () => Quotation },
            { no: 225, name: "dlong_min", kind: "message", T: () => Quotation },
            { no: 226, name: "dshort_min", kind: "message", T: () => Quotation },
            { no: 231, name: "min_price_increment", kind: "message", T: () => Quotation },
            { no: 241, name: "strike_price", kind: "message", T: () => MoneyValue },
            { no: 301, name: "expiration_date", kind: "message", T: () => Timestamp },
            { no: 311, name: "first_trade_date", kind: "message", T: () => Timestamp },
            { no: 312, name: "last_trade_date", kind: "message", T: () => Timestamp },
            { no: 321, name: "first_1min_candle_date", kind: "message", jsonName: "first1minCandleDate", T: () => Timestamp },
            { no: 322, name: "first_1day_candle_date", kind: "message", jsonName: "first1dayCandleDate", T: () => Timestamp },
            { no: 401, name: "short_enabled_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 402, name: "for_iis_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 403, name: "otc_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 404, name: "buy_available_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 405, name: "sell_available_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 406, name: "for_qual_investor_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 407, name: "weekend_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 408, name: "blocked_tca_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 409, name: "api_trade_available_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Option>): Option {
        const message = { uid: "", positionUid: "", ticker: "", classCode: "", basicAssetPositionUid: "", tradingStatus: 0, realExchange: 0, direction: 0, paymentType: 0, style: 0, settlementType: 0, name: "", currency: "", settlementCurrency: "", assetType: "", basicAsset: "", exchange: "", countryOfRisk: "", countryOfRiskName: "", sector: "", lot: 0, shortEnabledFlag: false, forIisFlag: false, otcFlag: false, buyAvailableFlag: false, sellAvailableFlag: false, forQualInvestorFlag: false, weekendFlag: false, blockedTcaFlag: false, apiTradeAvailableFlag: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Option>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Option): Option {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uid */ 1:
                    message.uid = reader.string();
                    break;
                case /* string position_uid */ 2:
                    message.positionUid = reader.string();
                    break;
                case /* string ticker */ 3:
                    message.ticker = reader.string();
                    break;
                case /* string class_code */ 4:
                    message.classCode = reader.string();
                    break;
                case /* string basic_asset_position_uid */ 5:
                    message.basicAssetPositionUid = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status */ 21:
                    message.tradingStatus = reader.int32();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.RealExchange real_exchange */ 31:
                    message.realExchange = reader.int32();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.OptionDirection direction */ 41:
                    message.direction = reader.int32();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.OptionPaymentType payment_type */ 42:
                    message.paymentType = reader.int32();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.OptionStyle style */ 43:
                    message.style = reader.int32();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.OptionSettlementType settlement_type */ 44:
                    message.settlementType = reader.int32();
                    break;
                case /* string name */ 101:
                    message.name = reader.string();
                    break;
                case /* string currency */ 111:
                    message.currency = reader.string();
                    break;
                case /* string settlement_currency */ 112:
                    message.settlementCurrency = reader.string();
                    break;
                case /* string asset_type */ 131:
                    message.assetType = reader.string();
                    break;
                case /* string basic_asset */ 132:
                    message.basicAsset = reader.string();
                    break;
                case /* string exchange */ 141:
                    message.exchange = reader.string();
                    break;
                case /* string country_of_risk */ 151:
                    message.countryOfRisk = reader.string();
                    break;
                case /* string country_of_risk_name */ 152:
                    message.countryOfRiskName = reader.string();
                    break;
                case /* string sector */ 161:
                    message.sector = reader.string();
                    break;
                case /* int32 lot */ 201:
                    message.lot = reader.int32();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation basic_asset_size */ 211:
                    message.basicAssetSize = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.basicAssetSize);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation klong */ 221:
                    message.klong = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.klong);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation kshort */ 222:
                    message.kshort = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.kshort);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dlong */ 223:
                    message.dlong = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dlong);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dshort */ 224:
                    message.dshort = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dshort);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dlong_min */ 225:
                    message.dlongMin = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dlongMin);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dshort_min */ 226:
                    message.dshortMin = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dshortMin);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment */ 231:
                    message.minPriceIncrement = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.minPriceIncrement);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue strike_price */ 241:
                    message.strikePrice = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.strikePrice);
                    break;
                case /* google.protobuf.Timestamp expiration_date */ 301:
                    message.expirationDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expirationDate);
                    break;
                case /* google.protobuf.Timestamp first_trade_date */ 311:
                    message.firstTradeDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.firstTradeDate);
                    break;
                case /* google.protobuf.Timestamp last_trade_date */ 312:
                    message.lastTradeDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastTradeDate);
                    break;
                case /* google.protobuf.Timestamp first_1min_candle_date = 321 [json_name = "first1minCandleDate"];*/ 321:
                    message.first1MinCandleDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.first1MinCandleDate);
                    break;
                case /* google.protobuf.Timestamp first_1day_candle_date = 322 [json_name = "first1dayCandleDate"];*/ 322:
                    message.first1DayCandleDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.first1DayCandleDate);
                    break;
                case /* bool short_enabled_flag */ 401:
                    message.shortEnabledFlag = reader.bool();
                    break;
                case /* bool for_iis_flag */ 402:
                    message.forIisFlag = reader.bool();
                    break;
                case /* bool otc_flag */ 403:
                    message.otcFlag = reader.bool();
                    break;
                case /* bool buy_available_flag */ 404:
                    message.buyAvailableFlag = reader.bool();
                    break;
                case /* bool sell_available_flag */ 405:
                    message.sellAvailableFlag = reader.bool();
                    break;
                case /* bool for_qual_investor_flag */ 406:
                    message.forQualInvestorFlag = reader.bool();
                    break;
                case /* bool weekend_flag */ 407:
                    message.weekendFlag = reader.bool();
                    break;
                case /* bool blocked_tca_flag */ 408:
                    message.blockedTcaFlag = reader.bool();
                    break;
                case /* bool api_trade_available_flag */ 409:
                    message.apiTradeAvailableFlag = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Option, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uid = 1; */
        if (message.uid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uid);
        /* string position_uid = 2; */
        if (message.positionUid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.positionUid);
        /* string ticker = 3; */
        if (message.ticker !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.ticker);
        /* string class_code = 4; */
        if (message.classCode !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.classCode);
        /* string basic_asset_position_uid = 5; */
        if (message.basicAssetPositionUid !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.basicAssetPositionUid);
        /* tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status = 21; */
        if (message.tradingStatus !== 0)
            writer.tag(21, WireType.Varint).int32(message.tradingStatus);
        /* tinkoff.public.invest.api.contract.v1.RealExchange real_exchange = 31; */
        if (message.realExchange !== 0)
            writer.tag(31, WireType.Varint).int32(message.realExchange);
        /* tinkoff.public.invest.api.contract.v1.OptionDirection direction = 41; */
        if (message.direction !== 0)
            writer.tag(41, WireType.Varint).int32(message.direction);
        /* tinkoff.public.invest.api.contract.v1.OptionPaymentType payment_type = 42; */
        if (message.paymentType !== 0)
            writer.tag(42, WireType.Varint).int32(message.paymentType);
        /* tinkoff.public.invest.api.contract.v1.OptionStyle style = 43; */
        if (message.style !== 0)
            writer.tag(43, WireType.Varint).int32(message.style);
        /* tinkoff.public.invest.api.contract.v1.OptionSettlementType settlement_type = 44; */
        if (message.settlementType !== 0)
            writer.tag(44, WireType.Varint).int32(message.settlementType);
        /* string name = 101; */
        if (message.name !== "")
            writer.tag(101, WireType.LengthDelimited).string(message.name);
        /* string currency = 111; */
        if (message.currency !== "")
            writer.tag(111, WireType.LengthDelimited).string(message.currency);
        /* string settlement_currency = 112; */
        if (message.settlementCurrency !== "")
            writer.tag(112, WireType.LengthDelimited).string(message.settlementCurrency);
        /* string asset_type = 131; */
        if (message.assetType !== "")
            writer.tag(131, WireType.LengthDelimited).string(message.assetType);
        /* string basic_asset = 132; */
        if (message.basicAsset !== "")
            writer.tag(132, WireType.LengthDelimited).string(message.basicAsset);
        /* string exchange = 141; */
        if (message.exchange !== "")
            writer.tag(141, WireType.LengthDelimited).string(message.exchange);
        /* string country_of_risk = 151; */
        if (message.countryOfRisk !== "")
            writer.tag(151, WireType.LengthDelimited).string(message.countryOfRisk);
        /* string country_of_risk_name = 152; */
        if (message.countryOfRiskName !== "")
            writer.tag(152, WireType.LengthDelimited).string(message.countryOfRiskName);
        /* string sector = 161; */
        if (message.sector !== "")
            writer.tag(161, WireType.LengthDelimited).string(message.sector);
        /* int32 lot = 201; */
        if (message.lot !== 0)
            writer.tag(201, WireType.Varint).int32(message.lot);
        /* tinkoff.public.invest.api.contract.v1.Quotation basic_asset_size = 211; */
        if (message.basicAssetSize)
            Quotation.internalBinaryWrite(message.basicAssetSize, writer.tag(211, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation klong = 221; */
        if (message.klong)
            Quotation.internalBinaryWrite(message.klong, writer.tag(221, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation kshort = 222; */
        if (message.kshort)
            Quotation.internalBinaryWrite(message.kshort, writer.tag(222, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation dlong = 223; */
        if (message.dlong)
            Quotation.internalBinaryWrite(message.dlong, writer.tag(223, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation dshort = 224; */
        if (message.dshort)
            Quotation.internalBinaryWrite(message.dshort, writer.tag(224, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation dlong_min = 225; */
        if (message.dlongMin)
            Quotation.internalBinaryWrite(message.dlongMin, writer.tag(225, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation dshort_min = 226; */
        if (message.dshortMin)
            Quotation.internalBinaryWrite(message.dshortMin, writer.tag(226, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment = 231; */
        if (message.minPriceIncrement)
            Quotation.internalBinaryWrite(message.minPriceIncrement, writer.tag(231, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue strike_price = 241; */
        if (message.strikePrice)
            MoneyValue.internalBinaryWrite(message.strikePrice, writer.tag(241, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp expiration_date = 301; */
        if (message.expirationDate)
            Timestamp.internalBinaryWrite(message.expirationDate, writer.tag(301, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp first_trade_date = 311; */
        if (message.firstTradeDate)
            Timestamp.internalBinaryWrite(message.firstTradeDate, writer.tag(311, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_trade_date = 312; */
        if (message.lastTradeDate)
            Timestamp.internalBinaryWrite(message.lastTradeDate, writer.tag(312, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp first_1min_candle_date = 321 [json_name = "first1minCandleDate"]; */
        if (message.first1MinCandleDate)
            Timestamp.internalBinaryWrite(message.first1MinCandleDate, writer.tag(321, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp first_1day_candle_date = 322 [json_name = "first1dayCandleDate"]; */
        if (message.first1DayCandleDate)
            Timestamp.internalBinaryWrite(message.first1DayCandleDate, writer.tag(322, WireType.LengthDelimited).fork(), options).join();
        /* bool short_enabled_flag = 401; */
        if (message.shortEnabledFlag !== false)
            writer.tag(401, WireType.Varint).bool(message.shortEnabledFlag);
        /* bool for_iis_flag = 402; */
        if (message.forIisFlag !== false)
            writer.tag(402, WireType.Varint).bool(message.forIisFlag);
        /* bool otc_flag = 403; */
        if (message.otcFlag !== false)
            writer.tag(403, WireType.Varint).bool(message.otcFlag);
        /* bool buy_available_flag = 404; */
        if (message.buyAvailableFlag !== false)
            writer.tag(404, WireType.Varint).bool(message.buyAvailableFlag);
        /* bool sell_available_flag = 405; */
        if (message.sellAvailableFlag !== false)
            writer.tag(405, WireType.Varint).bool(message.sellAvailableFlag);
        /* bool for_qual_investor_flag = 406; */
        if (message.forQualInvestorFlag !== false)
            writer.tag(406, WireType.Varint).bool(message.forQualInvestorFlag);
        /* bool weekend_flag = 407; */
        if (message.weekendFlag !== false)
            writer.tag(407, WireType.Varint).bool(message.weekendFlag);
        /* bool blocked_tca_flag = 408; */
        if (message.blockedTcaFlag !== false)
            writer.tag(408, WireType.Varint).bool(message.blockedTcaFlag);
        /* bool api_trade_available_flag = 409; */
        if (message.apiTradeAvailableFlag !== false)
            writer.tag(409, WireType.Varint).bool(message.apiTradeAvailableFlag);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.Option
 */
export const Option = new Option$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShareResponse$Type extends MessageType<ShareResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.ShareResponse", [
            { no: 1, name: "instrument", kind: "message", T: () => Share }
        ]);
    }
    create(value?: PartialMessage<ShareResponse>): ShareResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ShareResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShareResponse): ShareResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.Share instrument */ 1:
                    message.instrument = Share.internalBinaryRead(reader, reader.uint32(), options, message.instrument);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShareResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.Share instrument = 1; */
        if (message.instrument)
            Share.internalBinaryWrite(message.instrument, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.ShareResponse
 */
export const ShareResponse = new ShareResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SharesResponse$Type extends MessageType<SharesResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.SharesResponse", [
            { no: 1, name: "instruments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Share }
        ]);
    }
    create(value?: PartialMessage<SharesResponse>): SharesResponse {
        const message = { instruments: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SharesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SharesResponse): SharesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.Share instruments */ 1:
                    message.instruments.push(Share.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SharesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.Share instruments = 1; */
        for (let i = 0; i < message.instruments.length; i++)
            Share.internalBinaryWrite(message.instruments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.SharesResponse
 */
export const SharesResponse = new SharesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Bond$Type extends MessageType<Bond> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.Bond", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "class_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "isin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "lot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "currency", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "klong", kind: "message", T: () => Quotation },
            { no: 8, name: "kshort", kind: "message", T: () => Quotation },
            { no: 9, name: "dlong", kind: "message", T: () => Quotation },
            { no: 10, name: "dshort", kind: "message", T: () => Quotation },
            { no: 11, name: "dlong_min", kind: "message", T: () => Quotation },
            { no: 12, name: "dshort_min", kind: "message", T: () => Quotation },
            { no: 13, name: "short_enabled_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "exchange", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "coupon_quantity_per_year", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 18, name: "maturity_date", kind: "message", T: () => Timestamp },
            { no: 19, name: "nominal", kind: "message", T: () => MoneyValue },
            { no: 20, name: "initial_nominal", kind: "message", T: () => MoneyValue },
            { no: 21, name: "state_reg_date", kind: "message", T: () => Timestamp },
            { no: 22, name: "placement_date", kind: "message", T: () => Timestamp },
            { no: 23, name: "placement_price", kind: "message", T: () => MoneyValue },
            { no: 24, name: "aci_value", kind: "message", T: () => MoneyValue },
            { no: 25, name: "country_of_risk", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 26, name: "country_of_risk_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 27, name: "sector", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 28, name: "issue_kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 29, name: "issue_size", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 30, name: "issue_size_plan", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 31, name: "trading_status", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.SecurityTradingStatus", SecurityTradingStatus, "SECURITY_TRADING_STATUS_"] },
            { no: 32, name: "otc_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 33, name: "buy_available_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 34, name: "sell_available_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 35, name: "floating_coupon_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 36, name: "perpetual_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 37, name: "amortization_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 38, name: "min_price_increment", kind: "message", T: () => Quotation },
            { no: 39, name: "api_trade_available_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 40, name: "uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 41, name: "real_exchange", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.RealExchange", RealExchange, "REAL_EXCHANGE_"] },
            { no: 42, name: "position_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 51, name: "for_iis_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 52, name: "for_qual_investor_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 53, name: "weekend_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 54, name: "blocked_tca_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 55, name: "subordinated_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 61, name: "first_1min_candle_date", kind: "message", jsonName: "first1minCandleDate", T: () => Timestamp },
            { no: 62, name: "first_1day_candle_date", kind: "message", jsonName: "first1dayCandleDate", T: () => Timestamp },
            { no: 63, name: "risk_level", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.RiskLevel", RiskLevel, "RISK_LEVEL_"] }
        ]);
    }
    create(value?: PartialMessage<Bond>): Bond {
        const message = { figi: "", ticker: "", classCode: "", isin: "", lot: 0, currency: "", shortEnabledFlag: false, name: "", exchange: "", couponQuantityPerYear: 0, countryOfRisk: "", countryOfRiskName: "", sector: "", issueKind: "", issueSize: "0", issueSizePlan: "0", tradingStatus: 0, otcFlag: false, buyAvailableFlag: false, sellAvailableFlag: false, floatingCouponFlag: false, perpetualFlag: false, amortizationFlag: false, apiTradeAvailableFlag: false, uid: "", realExchange: 0, positionUid: "", forIisFlag: false, forQualInvestorFlag: false, weekendFlag: false, blockedTcaFlag: false, subordinatedFlag: false, riskLevel: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Bond>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Bond): Bond {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* string ticker */ 2:
                    message.ticker = reader.string();
                    break;
                case /* string class_code */ 3:
                    message.classCode = reader.string();
                    break;
                case /* string isin */ 4:
                    message.isin = reader.string();
                    break;
                case /* int32 lot */ 5:
                    message.lot = reader.int32();
                    break;
                case /* string currency */ 6:
                    message.currency = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation klong */ 7:
                    message.klong = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.klong);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation kshort */ 8:
                    message.kshort = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.kshort);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dlong */ 9:
                    message.dlong = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dlong);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dshort */ 10:
                    message.dshort = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dshort);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dlong_min */ 11:
                    message.dlongMin = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dlongMin);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dshort_min */ 12:
                    message.dshortMin = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dshortMin);
                    break;
                case /* bool short_enabled_flag */ 13:
                    message.shortEnabledFlag = reader.bool();
                    break;
                case /* string name */ 15:
                    message.name = reader.string();
                    break;
                case /* string exchange */ 16:
                    message.exchange = reader.string();
                    break;
                case /* int32 coupon_quantity_per_year */ 17:
                    message.couponQuantityPerYear = reader.int32();
                    break;
                case /* google.protobuf.Timestamp maturity_date */ 18:
                    message.maturityDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.maturityDate);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue nominal */ 19:
                    message.nominal = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.nominal);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue initial_nominal */ 20:
                    message.initialNominal = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.initialNominal);
                    break;
                case /* google.protobuf.Timestamp state_reg_date */ 21:
                    message.stateRegDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.stateRegDate);
                    break;
                case /* google.protobuf.Timestamp placement_date */ 22:
                    message.placementDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.placementDate);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue placement_price */ 23:
                    message.placementPrice = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.placementPrice);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue aci_value */ 24:
                    message.aciValue = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.aciValue);
                    break;
                case /* string country_of_risk */ 25:
                    message.countryOfRisk = reader.string();
                    break;
                case /* string country_of_risk_name */ 26:
                    message.countryOfRiskName = reader.string();
                    break;
                case /* string sector */ 27:
                    message.sector = reader.string();
                    break;
                case /* string issue_kind */ 28:
                    message.issueKind = reader.string();
                    break;
                case /* int64 issue_size */ 29:
                    message.issueSize = reader.int64().toString();
                    break;
                case /* int64 issue_size_plan */ 30:
                    message.issueSizePlan = reader.int64().toString();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status */ 31:
                    message.tradingStatus = reader.int32();
                    break;
                case /* bool otc_flag */ 32:
                    message.otcFlag = reader.bool();
                    break;
                case /* bool buy_available_flag */ 33:
                    message.buyAvailableFlag = reader.bool();
                    break;
                case /* bool sell_available_flag */ 34:
                    message.sellAvailableFlag = reader.bool();
                    break;
                case /* bool floating_coupon_flag */ 35:
                    message.floatingCouponFlag = reader.bool();
                    break;
                case /* bool perpetual_flag */ 36:
                    message.perpetualFlag = reader.bool();
                    break;
                case /* bool amortization_flag */ 37:
                    message.amortizationFlag = reader.bool();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment */ 38:
                    message.minPriceIncrement = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.minPriceIncrement);
                    break;
                case /* bool api_trade_available_flag */ 39:
                    message.apiTradeAvailableFlag = reader.bool();
                    break;
                case /* string uid */ 40:
                    message.uid = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.RealExchange real_exchange */ 41:
                    message.realExchange = reader.int32();
                    break;
                case /* string position_uid */ 42:
                    message.positionUid = reader.string();
                    break;
                case /* bool for_iis_flag */ 51:
                    message.forIisFlag = reader.bool();
                    break;
                case /* bool for_qual_investor_flag */ 52:
                    message.forQualInvestorFlag = reader.bool();
                    break;
                case /* bool weekend_flag */ 53:
                    message.weekendFlag = reader.bool();
                    break;
                case /* bool blocked_tca_flag */ 54:
                    message.blockedTcaFlag = reader.bool();
                    break;
                case /* bool subordinated_flag */ 55:
                    message.subordinatedFlag = reader.bool();
                    break;
                case /* google.protobuf.Timestamp first_1min_candle_date = 61 [json_name = "first1minCandleDate"];*/ 61:
                    message.first1MinCandleDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.first1MinCandleDate);
                    break;
                case /* google.protobuf.Timestamp first_1day_candle_date = 62 [json_name = "first1dayCandleDate"];*/ 62:
                    message.first1DayCandleDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.first1DayCandleDate);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.RiskLevel risk_level */ 63:
                    message.riskLevel = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Bond, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* string ticker = 2; */
        if (message.ticker !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ticker);
        /* string class_code = 3; */
        if (message.classCode !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.classCode);
        /* string isin = 4; */
        if (message.isin !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.isin);
        /* int32 lot = 5; */
        if (message.lot !== 0)
            writer.tag(5, WireType.Varint).int32(message.lot);
        /* string currency = 6; */
        if (message.currency !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.currency);
        /* tinkoff.public.invest.api.contract.v1.Quotation klong = 7; */
        if (message.klong)
            Quotation.internalBinaryWrite(message.klong, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation kshort = 8; */
        if (message.kshort)
            Quotation.internalBinaryWrite(message.kshort, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation dlong = 9; */
        if (message.dlong)
            Quotation.internalBinaryWrite(message.dlong, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation dshort = 10; */
        if (message.dshort)
            Quotation.internalBinaryWrite(message.dshort, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation dlong_min = 11; */
        if (message.dlongMin)
            Quotation.internalBinaryWrite(message.dlongMin, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation dshort_min = 12; */
        if (message.dshortMin)
            Quotation.internalBinaryWrite(message.dshortMin, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* bool short_enabled_flag = 13; */
        if (message.shortEnabledFlag !== false)
            writer.tag(13, WireType.Varint).bool(message.shortEnabledFlag);
        /* string name = 15; */
        if (message.name !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.name);
        /* string exchange = 16; */
        if (message.exchange !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.exchange);
        /* int32 coupon_quantity_per_year = 17; */
        if (message.couponQuantityPerYear !== 0)
            writer.tag(17, WireType.Varint).int32(message.couponQuantityPerYear);
        /* google.protobuf.Timestamp maturity_date = 18; */
        if (message.maturityDate)
            Timestamp.internalBinaryWrite(message.maturityDate, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue nominal = 19; */
        if (message.nominal)
            MoneyValue.internalBinaryWrite(message.nominal, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue initial_nominal = 20; */
        if (message.initialNominal)
            MoneyValue.internalBinaryWrite(message.initialNominal, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp state_reg_date = 21; */
        if (message.stateRegDate)
            Timestamp.internalBinaryWrite(message.stateRegDate, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp placement_date = 22; */
        if (message.placementDate)
            Timestamp.internalBinaryWrite(message.placementDate, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue placement_price = 23; */
        if (message.placementPrice)
            MoneyValue.internalBinaryWrite(message.placementPrice, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue aci_value = 24; */
        if (message.aciValue)
            MoneyValue.internalBinaryWrite(message.aciValue, writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* string country_of_risk = 25; */
        if (message.countryOfRisk !== "")
            writer.tag(25, WireType.LengthDelimited).string(message.countryOfRisk);
        /* string country_of_risk_name = 26; */
        if (message.countryOfRiskName !== "")
            writer.tag(26, WireType.LengthDelimited).string(message.countryOfRiskName);
        /* string sector = 27; */
        if (message.sector !== "")
            writer.tag(27, WireType.LengthDelimited).string(message.sector);
        /* string issue_kind = 28; */
        if (message.issueKind !== "")
            writer.tag(28, WireType.LengthDelimited).string(message.issueKind);
        /* int64 issue_size = 29; */
        if (message.issueSize !== "0")
            writer.tag(29, WireType.Varint).int64(message.issueSize);
        /* int64 issue_size_plan = 30; */
        if (message.issueSizePlan !== "0")
            writer.tag(30, WireType.Varint).int64(message.issueSizePlan);
        /* tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status = 31; */
        if (message.tradingStatus !== 0)
            writer.tag(31, WireType.Varint).int32(message.tradingStatus);
        /* bool otc_flag = 32; */
        if (message.otcFlag !== false)
            writer.tag(32, WireType.Varint).bool(message.otcFlag);
        /* bool buy_available_flag = 33; */
        if (message.buyAvailableFlag !== false)
            writer.tag(33, WireType.Varint).bool(message.buyAvailableFlag);
        /* bool sell_available_flag = 34; */
        if (message.sellAvailableFlag !== false)
            writer.tag(34, WireType.Varint).bool(message.sellAvailableFlag);
        /* bool floating_coupon_flag = 35; */
        if (message.floatingCouponFlag !== false)
            writer.tag(35, WireType.Varint).bool(message.floatingCouponFlag);
        /* bool perpetual_flag = 36; */
        if (message.perpetualFlag !== false)
            writer.tag(36, WireType.Varint).bool(message.perpetualFlag);
        /* bool amortization_flag = 37; */
        if (message.amortizationFlag !== false)
            writer.tag(37, WireType.Varint).bool(message.amortizationFlag);
        /* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment = 38; */
        if (message.minPriceIncrement)
            Quotation.internalBinaryWrite(message.minPriceIncrement, writer.tag(38, WireType.LengthDelimited).fork(), options).join();
        /* bool api_trade_available_flag = 39; */
        if (message.apiTradeAvailableFlag !== false)
            writer.tag(39, WireType.Varint).bool(message.apiTradeAvailableFlag);
        /* string uid = 40; */
        if (message.uid !== "")
            writer.tag(40, WireType.LengthDelimited).string(message.uid);
        /* tinkoff.public.invest.api.contract.v1.RealExchange real_exchange = 41; */
        if (message.realExchange !== 0)
            writer.tag(41, WireType.Varint).int32(message.realExchange);
        /* string position_uid = 42; */
        if (message.positionUid !== "")
            writer.tag(42, WireType.LengthDelimited).string(message.positionUid);
        /* bool for_iis_flag = 51; */
        if (message.forIisFlag !== false)
            writer.tag(51, WireType.Varint).bool(message.forIisFlag);
        /* bool for_qual_investor_flag = 52; */
        if (message.forQualInvestorFlag !== false)
            writer.tag(52, WireType.Varint).bool(message.forQualInvestorFlag);
        /* bool weekend_flag = 53; */
        if (message.weekendFlag !== false)
            writer.tag(53, WireType.Varint).bool(message.weekendFlag);
        /* bool blocked_tca_flag = 54; */
        if (message.blockedTcaFlag !== false)
            writer.tag(54, WireType.Varint).bool(message.blockedTcaFlag);
        /* bool subordinated_flag = 55; */
        if (message.subordinatedFlag !== false)
            writer.tag(55, WireType.Varint).bool(message.subordinatedFlag);
        /* google.protobuf.Timestamp first_1min_candle_date = 61 [json_name = "first1minCandleDate"]; */
        if (message.first1MinCandleDate)
            Timestamp.internalBinaryWrite(message.first1MinCandleDate, writer.tag(61, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp first_1day_candle_date = 62 [json_name = "first1dayCandleDate"]; */
        if (message.first1DayCandleDate)
            Timestamp.internalBinaryWrite(message.first1DayCandleDate, writer.tag(62, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.RiskLevel risk_level = 63; */
        if (message.riskLevel !== 0)
            writer.tag(63, WireType.Varint).int32(message.riskLevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.Bond
 */
export const Bond = new Bond$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Currency$Type extends MessageType<Currency> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.Currency", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "class_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "isin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "lot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "currency", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "klong", kind: "message", T: () => Quotation },
            { no: 8, name: "kshort", kind: "message", T: () => Quotation },
            { no: 9, name: "dlong", kind: "message", T: () => Quotation },
            { no: 10, name: "dshort", kind: "message", T: () => Quotation },
            { no: 11, name: "dlong_min", kind: "message", T: () => Quotation },
            { no: 12, name: "dshort_min", kind: "message", T: () => Quotation },
            { no: 13, name: "short_enabled_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "exchange", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "nominal", kind: "message", T: () => MoneyValue },
            { no: 18, name: "country_of_risk", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "country_of_risk_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "trading_status", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.SecurityTradingStatus", SecurityTradingStatus, "SECURITY_TRADING_STATUS_"] },
            { no: 21, name: "otc_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 22, name: "buy_available_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 23, name: "sell_available_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 24, name: "iso_currency_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 25, name: "min_price_increment", kind: "message", T: () => Quotation },
            { no: 26, name: "api_trade_available_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 27, name: "uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 28, name: "real_exchange", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.RealExchange", RealExchange, "REAL_EXCHANGE_"] },
            { no: 29, name: "position_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 41, name: "for_iis_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 52, name: "for_qual_investor_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 53, name: "weekend_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 54, name: "blocked_tca_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 56, name: "first_1min_candle_date", kind: "message", jsonName: "first1minCandleDate", T: () => Timestamp },
            { no: 57, name: "first_1day_candle_date", kind: "message", jsonName: "first1dayCandleDate", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<Currency>): Currency {
        const message = { figi: "", ticker: "", classCode: "", isin: "", lot: 0, currency: "", shortEnabledFlag: false, name: "", exchange: "", countryOfRisk: "", countryOfRiskName: "", tradingStatus: 0, otcFlag: false, buyAvailableFlag: false, sellAvailableFlag: false, isoCurrencyName: "", apiTradeAvailableFlag: false, uid: "", realExchange: 0, positionUid: "", forIisFlag: false, forQualInvestorFlag: false, weekendFlag: false, blockedTcaFlag: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Currency>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Currency): Currency {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* string ticker */ 2:
                    message.ticker = reader.string();
                    break;
                case /* string class_code */ 3:
                    message.classCode = reader.string();
                    break;
                case /* string isin */ 4:
                    message.isin = reader.string();
                    break;
                case /* int32 lot */ 5:
                    message.lot = reader.int32();
                    break;
                case /* string currency */ 6:
                    message.currency = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation klong */ 7:
                    message.klong = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.klong);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation kshort */ 8:
                    message.kshort = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.kshort);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dlong */ 9:
                    message.dlong = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dlong);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dshort */ 10:
                    message.dshort = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dshort);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dlong_min */ 11:
                    message.dlongMin = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dlongMin);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dshort_min */ 12:
                    message.dshortMin = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dshortMin);
                    break;
                case /* bool short_enabled_flag */ 13:
                    message.shortEnabledFlag = reader.bool();
                    break;
                case /* string name */ 15:
                    message.name = reader.string();
                    break;
                case /* string exchange */ 16:
                    message.exchange = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue nominal */ 17:
                    message.nominal = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.nominal);
                    break;
                case /* string country_of_risk */ 18:
                    message.countryOfRisk = reader.string();
                    break;
                case /* string country_of_risk_name */ 19:
                    message.countryOfRiskName = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status */ 20:
                    message.tradingStatus = reader.int32();
                    break;
                case /* bool otc_flag */ 21:
                    message.otcFlag = reader.bool();
                    break;
                case /* bool buy_available_flag */ 22:
                    message.buyAvailableFlag = reader.bool();
                    break;
                case /* bool sell_available_flag */ 23:
                    message.sellAvailableFlag = reader.bool();
                    break;
                case /* string iso_currency_name */ 24:
                    message.isoCurrencyName = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment */ 25:
                    message.minPriceIncrement = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.minPriceIncrement);
                    break;
                case /* bool api_trade_available_flag */ 26:
                    message.apiTradeAvailableFlag = reader.bool();
                    break;
                case /* string uid */ 27:
                    message.uid = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.RealExchange real_exchange */ 28:
                    message.realExchange = reader.int32();
                    break;
                case /* string position_uid */ 29:
                    message.positionUid = reader.string();
                    break;
                case /* bool for_iis_flag */ 41:
                    message.forIisFlag = reader.bool();
                    break;
                case /* bool for_qual_investor_flag */ 52:
                    message.forQualInvestorFlag = reader.bool();
                    break;
                case /* bool weekend_flag */ 53:
                    message.weekendFlag = reader.bool();
                    break;
                case /* bool blocked_tca_flag */ 54:
                    message.blockedTcaFlag = reader.bool();
                    break;
                case /* google.protobuf.Timestamp first_1min_candle_date = 56 [json_name = "first1minCandleDate"];*/ 56:
                    message.first1MinCandleDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.first1MinCandleDate);
                    break;
                case /* google.protobuf.Timestamp first_1day_candle_date = 57 [json_name = "first1dayCandleDate"];*/ 57:
                    message.first1DayCandleDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.first1DayCandleDate);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Currency, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* string ticker = 2; */
        if (message.ticker !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ticker);
        /* string class_code = 3; */
        if (message.classCode !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.classCode);
        /* string isin = 4; */
        if (message.isin !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.isin);
        /* int32 lot = 5; */
        if (message.lot !== 0)
            writer.tag(5, WireType.Varint).int32(message.lot);
        /* string currency = 6; */
        if (message.currency !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.currency);
        /* tinkoff.public.invest.api.contract.v1.Quotation klong = 7; */
        if (message.klong)
            Quotation.internalBinaryWrite(message.klong, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation kshort = 8; */
        if (message.kshort)
            Quotation.internalBinaryWrite(message.kshort, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation dlong = 9; */
        if (message.dlong)
            Quotation.internalBinaryWrite(message.dlong, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation dshort = 10; */
        if (message.dshort)
            Quotation.internalBinaryWrite(message.dshort, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation dlong_min = 11; */
        if (message.dlongMin)
            Quotation.internalBinaryWrite(message.dlongMin, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation dshort_min = 12; */
        if (message.dshortMin)
            Quotation.internalBinaryWrite(message.dshortMin, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* bool short_enabled_flag = 13; */
        if (message.shortEnabledFlag !== false)
            writer.tag(13, WireType.Varint).bool(message.shortEnabledFlag);
        /* string name = 15; */
        if (message.name !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.name);
        /* string exchange = 16; */
        if (message.exchange !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.exchange);
        /* tinkoff.public.invest.api.contract.v1.MoneyValue nominal = 17; */
        if (message.nominal)
            MoneyValue.internalBinaryWrite(message.nominal, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* string country_of_risk = 18; */
        if (message.countryOfRisk !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.countryOfRisk);
        /* string country_of_risk_name = 19; */
        if (message.countryOfRiskName !== "")
            writer.tag(19, WireType.LengthDelimited).string(message.countryOfRiskName);
        /* tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status = 20; */
        if (message.tradingStatus !== 0)
            writer.tag(20, WireType.Varint).int32(message.tradingStatus);
        /* bool otc_flag = 21; */
        if (message.otcFlag !== false)
            writer.tag(21, WireType.Varint).bool(message.otcFlag);
        /* bool buy_available_flag = 22; */
        if (message.buyAvailableFlag !== false)
            writer.tag(22, WireType.Varint).bool(message.buyAvailableFlag);
        /* bool sell_available_flag = 23; */
        if (message.sellAvailableFlag !== false)
            writer.tag(23, WireType.Varint).bool(message.sellAvailableFlag);
        /* string iso_currency_name = 24; */
        if (message.isoCurrencyName !== "")
            writer.tag(24, WireType.LengthDelimited).string(message.isoCurrencyName);
        /* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment = 25; */
        if (message.minPriceIncrement)
            Quotation.internalBinaryWrite(message.minPriceIncrement, writer.tag(25, WireType.LengthDelimited).fork(), options).join();
        /* bool api_trade_available_flag = 26; */
        if (message.apiTradeAvailableFlag !== false)
            writer.tag(26, WireType.Varint).bool(message.apiTradeAvailableFlag);
        /* string uid = 27; */
        if (message.uid !== "")
            writer.tag(27, WireType.LengthDelimited).string(message.uid);
        /* tinkoff.public.invest.api.contract.v1.RealExchange real_exchange = 28; */
        if (message.realExchange !== 0)
            writer.tag(28, WireType.Varint).int32(message.realExchange);
        /* string position_uid = 29; */
        if (message.positionUid !== "")
            writer.tag(29, WireType.LengthDelimited).string(message.positionUid);
        /* bool for_iis_flag = 41; */
        if (message.forIisFlag !== false)
            writer.tag(41, WireType.Varint).bool(message.forIisFlag);
        /* bool for_qual_investor_flag = 52; */
        if (message.forQualInvestorFlag !== false)
            writer.tag(52, WireType.Varint).bool(message.forQualInvestorFlag);
        /* bool weekend_flag = 53; */
        if (message.weekendFlag !== false)
            writer.tag(53, WireType.Varint).bool(message.weekendFlag);
        /* bool blocked_tca_flag = 54; */
        if (message.blockedTcaFlag !== false)
            writer.tag(54, WireType.Varint).bool(message.blockedTcaFlag);
        /* google.protobuf.Timestamp first_1min_candle_date = 56 [json_name = "first1minCandleDate"]; */
        if (message.first1MinCandleDate)
            Timestamp.internalBinaryWrite(message.first1MinCandleDate, writer.tag(56, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp first_1day_candle_date = 57 [json_name = "first1dayCandleDate"]; */
        if (message.first1DayCandleDate)
            Timestamp.internalBinaryWrite(message.first1DayCandleDate, writer.tag(57, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.Currency
 */
export const Currency = new Currency$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Etf$Type extends MessageType<Etf> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.Etf", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "class_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "isin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "lot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "currency", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "klong", kind: "message", T: () => Quotation },
            { no: 8, name: "kshort", kind: "message", T: () => Quotation },
            { no: 9, name: "dlong", kind: "message", T: () => Quotation },
            { no: 10, name: "dshort", kind: "message", T: () => Quotation },
            { no: 11, name: "dlong_min", kind: "message", T: () => Quotation },
            { no: 12, name: "dshort_min", kind: "message", T: () => Quotation },
            { no: 13, name: "short_enabled_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "exchange", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "fixed_commission", kind: "message", T: () => Quotation },
            { no: 18, name: "focus_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "released_date", kind: "message", T: () => Timestamp },
            { no: 20, name: "num_shares", kind: "message", T: () => Quotation },
            { no: 21, name: "country_of_risk", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 22, name: "country_of_risk_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 23, name: "sector", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 24, name: "rebalancing_freq", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 25, name: "trading_status", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.SecurityTradingStatus", SecurityTradingStatus, "SECURITY_TRADING_STATUS_"] },
            { no: 26, name: "otc_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 27, name: "buy_available_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 28, name: "sell_available_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 29, name: "min_price_increment", kind: "message", T: () => Quotation },
            { no: 30, name: "api_trade_available_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 31, name: "uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 32, name: "real_exchange", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.RealExchange", RealExchange, "REAL_EXCHANGE_"] },
            { no: 33, name: "position_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 41, name: "for_iis_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 42, name: "for_qual_investor_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 43, name: "weekend_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 44, name: "blocked_tca_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 56, name: "first_1min_candle_date", kind: "message", jsonName: "first1minCandleDate", T: () => Timestamp },
            { no: 57, name: "first_1day_candle_date", kind: "message", jsonName: "first1dayCandleDate", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<Etf>): Etf {
        const message = { figi: "", ticker: "", classCode: "", isin: "", lot: 0, currency: "", shortEnabledFlag: false, name: "", exchange: "", focusType: "", countryOfRisk: "", countryOfRiskName: "", sector: "", rebalancingFreq: "", tradingStatus: 0, otcFlag: false, buyAvailableFlag: false, sellAvailableFlag: false, apiTradeAvailableFlag: false, uid: "", realExchange: 0, positionUid: "", forIisFlag: false, forQualInvestorFlag: false, weekendFlag: false, blockedTcaFlag: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Etf>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Etf): Etf {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* string ticker */ 2:
                    message.ticker = reader.string();
                    break;
                case /* string class_code */ 3:
                    message.classCode = reader.string();
                    break;
                case /* string isin */ 4:
                    message.isin = reader.string();
                    break;
                case /* int32 lot */ 5:
                    message.lot = reader.int32();
                    break;
                case /* string currency */ 6:
                    message.currency = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation klong */ 7:
                    message.klong = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.klong);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation kshort */ 8:
                    message.kshort = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.kshort);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dlong */ 9:
                    message.dlong = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dlong);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dshort */ 10:
                    message.dshort = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dshort);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dlong_min */ 11:
                    message.dlongMin = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dlongMin);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dshort_min */ 12:
                    message.dshortMin = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dshortMin);
                    break;
                case /* bool short_enabled_flag */ 13:
                    message.shortEnabledFlag = reader.bool();
                    break;
                case /* string name */ 15:
                    message.name = reader.string();
                    break;
                case /* string exchange */ 16:
                    message.exchange = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation fixed_commission */ 17:
                    message.fixedCommission = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.fixedCommission);
                    break;
                case /* string focus_type */ 18:
                    message.focusType = reader.string();
                    break;
                case /* google.protobuf.Timestamp released_date */ 19:
                    message.releasedDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.releasedDate);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation num_shares */ 20:
                    message.numShares = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.numShares);
                    break;
                case /* string country_of_risk */ 21:
                    message.countryOfRisk = reader.string();
                    break;
                case /* string country_of_risk_name */ 22:
                    message.countryOfRiskName = reader.string();
                    break;
                case /* string sector */ 23:
                    message.sector = reader.string();
                    break;
                case /* string rebalancing_freq */ 24:
                    message.rebalancingFreq = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status */ 25:
                    message.tradingStatus = reader.int32();
                    break;
                case /* bool otc_flag */ 26:
                    message.otcFlag = reader.bool();
                    break;
                case /* bool buy_available_flag */ 27:
                    message.buyAvailableFlag = reader.bool();
                    break;
                case /* bool sell_available_flag */ 28:
                    message.sellAvailableFlag = reader.bool();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment */ 29:
                    message.minPriceIncrement = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.minPriceIncrement);
                    break;
                case /* bool api_trade_available_flag */ 30:
                    message.apiTradeAvailableFlag = reader.bool();
                    break;
                case /* string uid */ 31:
                    message.uid = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.RealExchange real_exchange */ 32:
                    message.realExchange = reader.int32();
                    break;
                case /* string position_uid */ 33:
                    message.positionUid = reader.string();
                    break;
                case /* bool for_iis_flag */ 41:
                    message.forIisFlag = reader.bool();
                    break;
                case /* bool for_qual_investor_flag */ 42:
                    message.forQualInvestorFlag = reader.bool();
                    break;
                case /* bool weekend_flag */ 43:
                    message.weekendFlag = reader.bool();
                    break;
                case /* bool blocked_tca_flag */ 44:
                    message.blockedTcaFlag = reader.bool();
                    break;
                case /* google.protobuf.Timestamp first_1min_candle_date = 56 [json_name = "first1minCandleDate"];*/ 56:
                    message.first1MinCandleDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.first1MinCandleDate);
                    break;
                case /* google.protobuf.Timestamp first_1day_candle_date = 57 [json_name = "first1dayCandleDate"];*/ 57:
                    message.first1DayCandleDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.first1DayCandleDate);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Etf, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* string ticker = 2; */
        if (message.ticker !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ticker);
        /* string class_code = 3; */
        if (message.classCode !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.classCode);
        /* string isin = 4; */
        if (message.isin !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.isin);
        /* int32 lot = 5; */
        if (message.lot !== 0)
            writer.tag(5, WireType.Varint).int32(message.lot);
        /* string currency = 6; */
        if (message.currency !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.currency);
        /* tinkoff.public.invest.api.contract.v1.Quotation klong = 7; */
        if (message.klong)
            Quotation.internalBinaryWrite(message.klong, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation kshort = 8; */
        if (message.kshort)
            Quotation.internalBinaryWrite(message.kshort, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation dlong = 9; */
        if (message.dlong)
            Quotation.internalBinaryWrite(message.dlong, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation dshort = 10; */
        if (message.dshort)
            Quotation.internalBinaryWrite(message.dshort, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation dlong_min = 11; */
        if (message.dlongMin)
            Quotation.internalBinaryWrite(message.dlongMin, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation dshort_min = 12; */
        if (message.dshortMin)
            Quotation.internalBinaryWrite(message.dshortMin, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* bool short_enabled_flag = 13; */
        if (message.shortEnabledFlag !== false)
            writer.tag(13, WireType.Varint).bool(message.shortEnabledFlag);
        /* string name = 15; */
        if (message.name !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.name);
        /* string exchange = 16; */
        if (message.exchange !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.exchange);
        /* tinkoff.public.invest.api.contract.v1.Quotation fixed_commission = 17; */
        if (message.fixedCommission)
            Quotation.internalBinaryWrite(message.fixedCommission, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* string focus_type = 18; */
        if (message.focusType !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.focusType);
        /* google.protobuf.Timestamp released_date = 19; */
        if (message.releasedDate)
            Timestamp.internalBinaryWrite(message.releasedDate, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation num_shares = 20; */
        if (message.numShares)
            Quotation.internalBinaryWrite(message.numShares, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* string country_of_risk = 21; */
        if (message.countryOfRisk !== "")
            writer.tag(21, WireType.LengthDelimited).string(message.countryOfRisk);
        /* string country_of_risk_name = 22; */
        if (message.countryOfRiskName !== "")
            writer.tag(22, WireType.LengthDelimited).string(message.countryOfRiskName);
        /* string sector = 23; */
        if (message.sector !== "")
            writer.tag(23, WireType.LengthDelimited).string(message.sector);
        /* string rebalancing_freq = 24; */
        if (message.rebalancingFreq !== "")
            writer.tag(24, WireType.LengthDelimited).string(message.rebalancingFreq);
        /* tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status = 25; */
        if (message.tradingStatus !== 0)
            writer.tag(25, WireType.Varint).int32(message.tradingStatus);
        /* bool otc_flag = 26; */
        if (message.otcFlag !== false)
            writer.tag(26, WireType.Varint).bool(message.otcFlag);
        /* bool buy_available_flag = 27; */
        if (message.buyAvailableFlag !== false)
            writer.tag(27, WireType.Varint).bool(message.buyAvailableFlag);
        /* bool sell_available_flag = 28; */
        if (message.sellAvailableFlag !== false)
            writer.tag(28, WireType.Varint).bool(message.sellAvailableFlag);
        /* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment = 29; */
        if (message.minPriceIncrement)
            Quotation.internalBinaryWrite(message.minPriceIncrement, writer.tag(29, WireType.LengthDelimited).fork(), options).join();
        /* bool api_trade_available_flag = 30; */
        if (message.apiTradeAvailableFlag !== false)
            writer.tag(30, WireType.Varint).bool(message.apiTradeAvailableFlag);
        /* string uid = 31; */
        if (message.uid !== "")
            writer.tag(31, WireType.LengthDelimited).string(message.uid);
        /* tinkoff.public.invest.api.contract.v1.RealExchange real_exchange = 32; */
        if (message.realExchange !== 0)
            writer.tag(32, WireType.Varint).int32(message.realExchange);
        /* string position_uid = 33; */
        if (message.positionUid !== "")
            writer.tag(33, WireType.LengthDelimited).string(message.positionUid);
        /* bool for_iis_flag = 41; */
        if (message.forIisFlag !== false)
            writer.tag(41, WireType.Varint).bool(message.forIisFlag);
        /* bool for_qual_investor_flag = 42; */
        if (message.forQualInvestorFlag !== false)
            writer.tag(42, WireType.Varint).bool(message.forQualInvestorFlag);
        /* bool weekend_flag = 43; */
        if (message.weekendFlag !== false)
            writer.tag(43, WireType.Varint).bool(message.weekendFlag);
        /* bool blocked_tca_flag = 44; */
        if (message.blockedTcaFlag !== false)
            writer.tag(44, WireType.Varint).bool(message.blockedTcaFlag);
        /* google.protobuf.Timestamp first_1min_candle_date = 56 [json_name = "first1minCandleDate"]; */
        if (message.first1MinCandleDate)
            Timestamp.internalBinaryWrite(message.first1MinCandleDate, writer.tag(56, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp first_1day_candle_date = 57 [json_name = "first1dayCandleDate"]; */
        if (message.first1DayCandleDate)
            Timestamp.internalBinaryWrite(message.first1DayCandleDate, writer.tag(57, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.Etf
 */
export const Etf = new Etf$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Future$Type extends MessageType<Future> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.Future", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "class_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "lot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "currency", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "klong", kind: "message", T: () => Quotation },
            { no: 7, name: "kshort", kind: "message", T: () => Quotation },
            { no: 8, name: "dlong", kind: "message", T: () => Quotation },
            { no: 9, name: "dshort", kind: "message", T: () => Quotation },
            { no: 10, name: "dlong_min", kind: "message", T: () => Quotation },
            { no: 11, name: "dshort_min", kind: "message", T: () => Quotation },
            { no: 12, name: "short_enabled_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "exchange", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "first_trade_date", kind: "message", T: () => Timestamp },
            { no: 16, name: "last_trade_date", kind: "message", T: () => Timestamp },
            { no: 17, name: "futures_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "asset_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "basic_asset", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "basic_asset_size", kind: "message", T: () => Quotation },
            { no: 21, name: "country_of_risk", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 22, name: "country_of_risk_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 23, name: "sector", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 24, name: "expiration_date", kind: "message", T: () => Timestamp },
            { no: 25, name: "trading_status", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.SecurityTradingStatus", SecurityTradingStatus, "SECURITY_TRADING_STATUS_"] },
            { no: 26, name: "otc_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 27, name: "buy_available_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 28, name: "sell_available_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 29, name: "min_price_increment", kind: "message", T: () => Quotation },
            { no: 30, name: "api_trade_available_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 31, name: "uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 32, name: "real_exchange", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.RealExchange", RealExchange, "REAL_EXCHANGE_"] },
            { no: 33, name: "position_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 34, name: "basic_asset_position_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 41, name: "for_iis_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 42, name: "for_qual_investor_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 43, name: "weekend_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 44, name: "blocked_tca_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 56, name: "first_1min_candle_date", kind: "message", jsonName: "first1minCandleDate", T: () => Timestamp },
            { no: 57, name: "first_1day_candle_date", kind: "message", jsonName: "first1dayCandleDate", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<Future>): Future {
        const message = { figi: "", ticker: "", classCode: "", lot: 0, currency: "", shortEnabledFlag: false, name: "", exchange: "", futuresType: "", assetType: "", basicAsset: "", countryOfRisk: "", countryOfRiskName: "", sector: "", tradingStatus: 0, otcFlag: false, buyAvailableFlag: false, sellAvailableFlag: false, apiTradeAvailableFlag: false, uid: "", realExchange: 0, positionUid: "", basicAssetPositionUid: "", forIisFlag: false, forQualInvestorFlag: false, weekendFlag: false, blockedTcaFlag: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Future>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Future): Future {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* string ticker */ 2:
                    message.ticker = reader.string();
                    break;
                case /* string class_code */ 3:
                    message.classCode = reader.string();
                    break;
                case /* int32 lot */ 4:
                    message.lot = reader.int32();
                    break;
                case /* string currency */ 5:
                    message.currency = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation klong */ 6:
                    message.klong = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.klong);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation kshort */ 7:
                    message.kshort = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.kshort);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dlong */ 8:
                    message.dlong = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dlong);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dshort */ 9:
                    message.dshort = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dshort);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dlong_min */ 10:
                    message.dlongMin = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dlongMin);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dshort_min */ 11:
                    message.dshortMin = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dshortMin);
                    break;
                case /* bool short_enabled_flag */ 12:
                    message.shortEnabledFlag = reader.bool();
                    break;
                case /* string name */ 13:
                    message.name = reader.string();
                    break;
                case /* string exchange */ 14:
                    message.exchange = reader.string();
                    break;
                case /* google.protobuf.Timestamp first_trade_date */ 15:
                    message.firstTradeDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.firstTradeDate);
                    break;
                case /* google.protobuf.Timestamp last_trade_date */ 16:
                    message.lastTradeDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastTradeDate);
                    break;
                case /* string futures_type */ 17:
                    message.futuresType = reader.string();
                    break;
                case /* string asset_type */ 18:
                    message.assetType = reader.string();
                    break;
                case /* string basic_asset */ 19:
                    message.basicAsset = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation basic_asset_size */ 20:
                    message.basicAssetSize = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.basicAssetSize);
                    break;
                case /* string country_of_risk */ 21:
                    message.countryOfRisk = reader.string();
                    break;
                case /* string country_of_risk_name */ 22:
                    message.countryOfRiskName = reader.string();
                    break;
                case /* string sector */ 23:
                    message.sector = reader.string();
                    break;
                case /* google.protobuf.Timestamp expiration_date */ 24:
                    message.expirationDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expirationDate);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status */ 25:
                    message.tradingStatus = reader.int32();
                    break;
                case /* bool otc_flag */ 26:
                    message.otcFlag = reader.bool();
                    break;
                case /* bool buy_available_flag */ 27:
                    message.buyAvailableFlag = reader.bool();
                    break;
                case /* bool sell_available_flag */ 28:
                    message.sellAvailableFlag = reader.bool();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment */ 29:
                    message.minPriceIncrement = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.minPriceIncrement);
                    break;
                case /* bool api_trade_available_flag */ 30:
                    message.apiTradeAvailableFlag = reader.bool();
                    break;
                case /* string uid */ 31:
                    message.uid = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.RealExchange real_exchange */ 32:
                    message.realExchange = reader.int32();
                    break;
                case /* string position_uid */ 33:
                    message.positionUid = reader.string();
                    break;
                case /* string basic_asset_position_uid */ 34:
                    message.basicAssetPositionUid = reader.string();
                    break;
                case /* bool for_iis_flag */ 41:
                    message.forIisFlag = reader.bool();
                    break;
                case /* bool for_qual_investor_flag */ 42:
                    message.forQualInvestorFlag = reader.bool();
                    break;
                case /* bool weekend_flag */ 43:
                    message.weekendFlag = reader.bool();
                    break;
                case /* bool blocked_tca_flag */ 44:
                    message.blockedTcaFlag = reader.bool();
                    break;
                case /* google.protobuf.Timestamp first_1min_candle_date = 56 [json_name = "first1minCandleDate"];*/ 56:
                    message.first1MinCandleDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.first1MinCandleDate);
                    break;
                case /* google.protobuf.Timestamp first_1day_candle_date = 57 [json_name = "first1dayCandleDate"];*/ 57:
                    message.first1DayCandleDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.first1DayCandleDate);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Future, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* string ticker = 2; */
        if (message.ticker !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ticker);
        /* string class_code = 3; */
        if (message.classCode !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.classCode);
        /* int32 lot = 4; */
        if (message.lot !== 0)
            writer.tag(4, WireType.Varint).int32(message.lot);
        /* string currency = 5; */
        if (message.currency !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.currency);
        /* tinkoff.public.invest.api.contract.v1.Quotation klong = 6; */
        if (message.klong)
            Quotation.internalBinaryWrite(message.klong, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation kshort = 7; */
        if (message.kshort)
            Quotation.internalBinaryWrite(message.kshort, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation dlong = 8; */
        if (message.dlong)
            Quotation.internalBinaryWrite(message.dlong, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation dshort = 9; */
        if (message.dshort)
            Quotation.internalBinaryWrite(message.dshort, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation dlong_min = 10; */
        if (message.dlongMin)
            Quotation.internalBinaryWrite(message.dlongMin, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation dshort_min = 11; */
        if (message.dshortMin)
            Quotation.internalBinaryWrite(message.dshortMin, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* bool short_enabled_flag = 12; */
        if (message.shortEnabledFlag !== false)
            writer.tag(12, WireType.Varint).bool(message.shortEnabledFlag);
        /* string name = 13; */
        if (message.name !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.name);
        /* string exchange = 14; */
        if (message.exchange !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.exchange);
        /* google.protobuf.Timestamp first_trade_date = 15; */
        if (message.firstTradeDate)
            Timestamp.internalBinaryWrite(message.firstTradeDate, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_trade_date = 16; */
        if (message.lastTradeDate)
            Timestamp.internalBinaryWrite(message.lastTradeDate, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* string futures_type = 17; */
        if (message.futuresType !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.futuresType);
        /* string asset_type = 18; */
        if (message.assetType !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.assetType);
        /* string basic_asset = 19; */
        if (message.basicAsset !== "")
            writer.tag(19, WireType.LengthDelimited).string(message.basicAsset);
        /* tinkoff.public.invest.api.contract.v1.Quotation basic_asset_size = 20; */
        if (message.basicAssetSize)
            Quotation.internalBinaryWrite(message.basicAssetSize, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* string country_of_risk = 21; */
        if (message.countryOfRisk !== "")
            writer.tag(21, WireType.LengthDelimited).string(message.countryOfRisk);
        /* string country_of_risk_name = 22; */
        if (message.countryOfRiskName !== "")
            writer.tag(22, WireType.LengthDelimited).string(message.countryOfRiskName);
        /* string sector = 23; */
        if (message.sector !== "")
            writer.tag(23, WireType.LengthDelimited).string(message.sector);
        /* google.protobuf.Timestamp expiration_date = 24; */
        if (message.expirationDate)
            Timestamp.internalBinaryWrite(message.expirationDate, writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status = 25; */
        if (message.tradingStatus !== 0)
            writer.tag(25, WireType.Varint).int32(message.tradingStatus);
        /* bool otc_flag = 26; */
        if (message.otcFlag !== false)
            writer.tag(26, WireType.Varint).bool(message.otcFlag);
        /* bool buy_available_flag = 27; */
        if (message.buyAvailableFlag !== false)
            writer.tag(27, WireType.Varint).bool(message.buyAvailableFlag);
        /* bool sell_available_flag = 28; */
        if (message.sellAvailableFlag !== false)
            writer.tag(28, WireType.Varint).bool(message.sellAvailableFlag);
        /* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment = 29; */
        if (message.minPriceIncrement)
            Quotation.internalBinaryWrite(message.minPriceIncrement, writer.tag(29, WireType.LengthDelimited).fork(), options).join();
        /* bool api_trade_available_flag = 30; */
        if (message.apiTradeAvailableFlag !== false)
            writer.tag(30, WireType.Varint).bool(message.apiTradeAvailableFlag);
        /* string uid = 31; */
        if (message.uid !== "")
            writer.tag(31, WireType.LengthDelimited).string(message.uid);
        /* tinkoff.public.invest.api.contract.v1.RealExchange real_exchange = 32; */
        if (message.realExchange !== 0)
            writer.tag(32, WireType.Varint).int32(message.realExchange);
        /* string position_uid = 33; */
        if (message.positionUid !== "")
            writer.tag(33, WireType.LengthDelimited).string(message.positionUid);
        /* string basic_asset_position_uid = 34; */
        if (message.basicAssetPositionUid !== "")
            writer.tag(34, WireType.LengthDelimited).string(message.basicAssetPositionUid);
        /* bool for_iis_flag = 41; */
        if (message.forIisFlag !== false)
            writer.tag(41, WireType.Varint).bool(message.forIisFlag);
        /* bool for_qual_investor_flag = 42; */
        if (message.forQualInvestorFlag !== false)
            writer.tag(42, WireType.Varint).bool(message.forQualInvestorFlag);
        /* bool weekend_flag = 43; */
        if (message.weekendFlag !== false)
            writer.tag(43, WireType.Varint).bool(message.weekendFlag);
        /* bool blocked_tca_flag = 44; */
        if (message.blockedTcaFlag !== false)
            writer.tag(44, WireType.Varint).bool(message.blockedTcaFlag);
        /* google.protobuf.Timestamp first_1min_candle_date = 56 [json_name = "first1minCandleDate"]; */
        if (message.first1MinCandleDate)
            Timestamp.internalBinaryWrite(message.first1MinCandleDate, writer.tag(56, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp first_1day_candle_date = 57 [json_name = "first1dayCandleDate"]; */
        if (message.first1DayCandleDate)
            Timestamp.internalBinaryWrite(message.first1DayCandleDate, writer.tag(57, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.Future
 */
export const Future = new Future$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Share$Type extends MessageType<Share> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.Share", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "class_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "isin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "lot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "currency", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "klong", kind: "message", T: () => Quotation },
            { no: 8, name: "kshort", kind: "message", T: () => Quotation },
            { no: 9, name: "dlong", kind: "message", T: () => Quotation },
            { no: 10, name: "dshort", kind: "message", T: () => Quotation },
            { no: 11, name: "dlong_min", kind: "message", T: () => Quotation },
            { no: 12, name: "dshort_min", kind: "message", T: () => Quotation },
            { no: 13, name: "short_enabled_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "exchange", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "ipo_date", kind: "message", T: () => Timestamp },
            { no: 18, name: "issue_size", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 19, name: "country_of_risk", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "country_of_risk_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 21, name: "sector", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 22, name: "issue_size_plan", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 23, name: "nominal", kind: "message", T: () => MoneyValue },
            { no: 25, name: "trading_status", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.SecurityTradingStatus", SecurityTradingStatus, "SECURITY_TRADING_STATUS_"] },
            { no: 26, name: "otc_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 27, name: "buy_available_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 28, name: "sell_available_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 29, name: "div_yield_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 30, name: "share_type", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.ShareType", ShareType, "SHARE_TYPE_"] },
            { no: 31, name: "min_price_increment", kind: "message", T: () => Quotation },
            { no: 32, name: "api_trade_available_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 33, name: "uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 34, name: "real_exchange", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.RealExchange", RealExchange, "REAL_EXCHANGE_"] },
            { no: 35, name: "position_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 46, name: "for_iis_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 47, name: "for_qual_investor_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 48, name: "weekend_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 49, name: "blocked_tca_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 56, name: "first_1min_candle_date", kind: "message", jsonName: "first1minCandleDate", T: () => Timestamp },
            { no: 57, name: "first_1day_candle_date", kind: "message", jsonName: "first1dayCandleDate", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<Share>): Share {
        const message = { figi: "", ticker: "", classCode: "", isin: "", lot: 0, currency: "", shortEnabledFlag: false, name: "", exchange: "", issueSize: "0", countryOfRisk: "", countryOfRiskName: "", sector: "", issueSizePlan: "0", tradingStatus: 0, otcFlag: false, buyAvailableFlag: false, sellAvailableFlag: false, divYieldFlag: false, shareType: 0, apiTradeAvailableFlag: false, uid: "", realExchange: 0, positionUid: "", forIisFlag: false, forQualInvestorFlag: false, weekendFlag: false, blockedTcaFlag: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Share>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Share): Share {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* string ticker */ 2:
                    message.ticker = reader.string();
                    break;
                case /* string class_code */ 3:
                    message.classCode = reader.string();
                    break;
                case /* string isin */ 4:
                    message.isin = reader.string();
                    break;
                case /* int32 lot */ 5:
                    message.lot = reader.int32();
                    break;
                case /* string currency */ 6:
                    message.currency = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation klong */ 7:
                    message.klong = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.klong);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation kshort */ 8:
                    message.kshort = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.kshort);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dlong */ 9:
                    message.dlong = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dlong);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dshort */ 10:
                    message.dshort = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dshort);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dlong_min */ 11:
                    message.dlongMin = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dlongMin);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dshort_min */ 12:
                    message.dshortMin = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dshortMin);
                    break;
                case /* bool short_enabled_flag */ 13:
                    message.shortEnabledFlag = reader.bool();
                    break;
                case /* string name */ 15:
                    message.name = reader.string();
                    break;
                case /* string exchange */ 16:
                    message.exchange = reader.string();
                    break;
                case /* google.protobuf.Timestamp ipo_date */ 17:
                    message.ipoDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.ipoDate);
                    break;
                case /* int64 issue_size */ 18:
                    message.issueSize = reader.int64().toString();
                    break;
                case /* string country_of_risk */ 19:
                    message.countryOfRisk = reader.string();
                    break;
                case /* string country_of_risk_name */ 20:
                    message.countryOfRiskName = reader.string();
                    break;
                case /* string sector */ 21:
                    message.sector = reader.string();
                    break;
                case /* int64 issue_size_plan */ 22:
                    message.issueSizePlan = reader.int64().toString();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue nominal */ 23:
                    message.nominal = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.nominal);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status */ 25:
                    message.tradingStatus = reader.int32();
                    break;
                case /* bool otc_flag */ 26:
                    message.otcFlag = reader.bool();
                    break;
                case /* bool buy_available_flag */ 27:
                    message.buyAvailableFlag = reader.bool();
                    break;
                case /* bool sell_available_flag */ 28:
                    message.sellAvailableFlag = reader.bool();
                    break;
                case /* bool div_yield_flag */ 29:
                    message.divYieldFlag = reader.bool();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.ShareType share_type */ 30:
                    message.shareType = reader.int32();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment */ 31:
                    message.minPriceIncrement = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.minPriceIncrement);
                    break;
                case /* bool api_trade_available_flag */ 32:
                    message.apiTradeAvailableFlag = reader.bool();
                    break;
                case /* string uid */ 33:
                    message.uid = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.RealExchange real_exchange */ 34:
                    message.realExchange = reader.int32();
                    break;
                case /* string position_uid */ 35:
                    message.positionUid = reader.string();
                    break;
                case /* bool for_iis_flag */ 46:
                    message.forIisFlag = reader.bool();
                    break;
                case /* bool for_qual_investor_flag */ 47:
                    message.forQualInvestorFlag = reader.bool();
                    break;
                case /* bool weekend_flag */ 48:
                    message.weekendFlag = reader.bool();
                    break;
                case /* bool blocked_tca_flag */ 49:
                    message.blockedTcaFlag = reader.bool();
                    break;
                case /* google.protobuf.Timestamp first_1min_candle_date = 56 [json_name = "first1minCandleDate"];*/ 56:
                    message.first1MinCandleDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.first1MinCandleDate);
                    break;
                case /* google.protobuf.Timestamp first_1day_candle_date = 57 [json_name = "first1dayCandleDate"];*/ 57:
                    message.first1DayCandleDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.first1DayCandleDate);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Share, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* string ticker = 2; */
        if (message.ticker !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ticker);
        /* string class_code = 3; */
        if (message.classCode !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.classCode);
        /* string isin = 4; */
        if (message.isin !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.isin);
        /* int32 lot = 5; */
        if (message.lot !== 0)
            writer.tag(5, WireType.Varint).int32(message.lot);
        /* string currency = 6; */
        if (message.currency !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.currency);
        /* tinkoff.public.invest.api.contract.v1.Quotation klong = 7; */
        if (message.klong)
            Quotation.internalBinaryWrite(message.klong, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation kshort = 8; */
        if (message.kshort)
            Quotation.internalBinaryWrite(message.kshort, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation dlong = 9; */
        if (message.dlong)
            Quotation.internalBinaryWrite(message.dlong, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation dshort = 10; */
        if (message.dshort)
            Quotation.internalBinaryWrite(message.dshort, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation dlong_min = 11; */
        if (message.dlongMin)
            Quotation.internalBinaryWrite(message.dlongMin, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation dshort_min = 12; */
        if (message.dshortMin)
            Quotation.internalBinaryWrite(message.dshortMin, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* bool short_enabled_flag = 13; */
        if (message.shortEnabledFlag !== false)
            writer.tag(13, WireType.Varint).bool(message.shortEnabledFlag);
        /* string name = 15; */
        if (message.name !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.name);
        /* string exchange = 16; */
        if (message.exchange !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.exchange);
        /* google.protobuf.Timestamp ipo_date = 17; */
        if (message.ipoDate)
            Timestamp.internalBinaryWrite(message.ipoDate, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* int64 issue_size = 18; */
        if (message.issueSize !== "0")
            writer.tag(18, WireType.Varint).int64(message.issueSize);
        /* string country_of_risk = 19; */
        if (message.countryOfRisk !== "")
            writer.tag(19, WireType.LengthDelimited).string(message.countryOfRisk);
        /* string country_of_risk_name = 20; */
        if (message.countryOfRiskName !== "")
            writer.tag(20, WireType.LengthDelimited).string(message.countryOfRiskName);
        /* string sector = 21; */
        if (message.sector !== "")
            writer.tag(21, WireType.LengthDelimited).string(message.sector);
        /* int64 issue_size_plan = 22; */
        if (message.issueSizePlan !== "0")
            writer.tag(22, WireType.Varint).int64(message.issueSizePlan);
        /* tinkoff.public.invest.api.contract.v1.MoneyValue nominal = 23; */
        if (message.nominal)
            MoneyValue.internalBinaryWrite(message.nominal, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status = 25; */
        if (message.tradingStatus !== 0)
            writer.tag(25, WireType.Varint).int32(message.tradingStatus);
        /* bool otc_flag = 26; */
        if (message.otcFlag !== false)
            writer.tag(26, WireType.Varint).bool(message.otcFlag);
        /* bool buy_available_flag = 27; */
        if (message.buyAvailableFlag !== false)
            writer.tag(27, WireType.Varint).bool(message.buyAvailableFlag);
        /* bool sell_available_flag = 28; */
        if (message.sellAvailableFlag !== false)
            writer.tag(28, WireType.Varint).bool(message.sellAvailableFlag);
        /* bool div_yield_flag = 29; */
        if (message.divYieldFlag !== false)
            writer.tag(29, WireType.Varint).bool(message.divYieldFlag);
        /* tinkoff.public.invest.api.contract.v1.ShareType share_type = 30; */
        if (message.shareType !== 0)
            writer.tag(30, WireType.Varint).int32(message.shareType);
        /* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment = 31; */
        if (message.minPriceIncrement)
            Quotation.internalBinaryWrite(message.minPriceIncrement, writer.tag(31, WireType.LengthDelimited).fork(), options).join();
        /* bool api_trade_available_flag = 32; */
        if (message.apiTradeAvailableFlag !== false)
            writer.tag(32, WireType.Varint).bool(message.apiTradeAvailableFlag);
        /* string uid = 33; */
        if (message.uid !== "")
            writer.tag(33, WireType.LengthDelimited).string(message.uid);
        /* tinkoff.public.invest.api.contract.v1.RealExchange real_exchange = 34; */
        if (message.realExchange !== 0)
            writer.tag(34, WireType.Varint).int32(message.realExchange);
        /* string position_uid = 35; */
        if (message.positionUid !== "")
            writer.tag(35, WireType.LengthDelimited).string(message.positionUid);
        /* bool for_iis_flag = 46; */
        if (message.forIisFlag !== false)
            writer.tag(46, WireType.Varint).bool(message.forIisFlag);
        /* bool for_qual_investor_flag = 47; */
        if (message.forQualInvestorFlag !== false)
            writer.tag(47, WireType.Varint).bool(message.forQualInvestorFlag);
        /* bool weekend_flag = 48; */
        if (message.weekendFlag !== false)
            writer.tag(48, WireType.Varint).bool(message.weekendFlag);
        /* bool blocked_tca_flag = 49; */
        if (message.blockedTcaFlag !== false)
            writer.tag(49, WireType.Varint).bool(message.blockedTcaFlag);
        /* google.protobuf.Timestamp first_1min_candle_date = 56 [json_name = "first1minCandleDate"]; */
        if (message.first1MinCandleDate)
            Timestamp.internalBinaryWrite(message.first1MinCandleDate, writer.tag(56, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp first_1day_candle_date = 57 [json_name = "first1dayCandleDate"]; */
        if (message.first1DayCandleDate)
            Timestamp.internalBinaryWrite(message.first1DayCandleDate, writer.tag(57, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.Share
 */
export const Share = new Share$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAccruedInterestsRequest$Type extends MessageType<GetAccruedInterestsRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetAccruedInterestsRequest", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "from", kind: "message", T: () => Timestamp },
            { no: 3, name: "to", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<GetAccruedInterestsRequest>): GetAccruedInterestsRequest {
        const message = { figi: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetAccruedInterestsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAccruedInterestsRequest): GetAccruedInterestsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* google.protobuf.Timestamp from */ 2:
                    message.from = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.from);
                    break;
                case /* google.protobuf.Timestamp to */ 3:
                    message.to = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.to);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAccruedInterestsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* google.protobuf.Timestamp from = 2; */
        if (message.from)
            Timestamp.internalBinaryWrite(message.from, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp to = 3; */
        if (message.to)
            Timestamp.internalBinaryWrite(message.to, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetAccruedInterestsRequest
 */
export const GetAccruedInterestsRequest = new GetAccruedInterestsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAccruedInterestsResponse$Type extends MessageType<GetAccruedInterestsResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetAccruedInterestsResponse", [
            { no: 1, name: "accrued_interests", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AccruedInterest }
        ]);
    }
    create(value?: PartialMessage<GetAccruedInterestsResponse>): GetAccruedInterestsResponse {
        const message = { accruedInterests: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetAccruedInterestsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAccruedInterestsResponse): GetAccruedInterestsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.AccruedInterest accrued_interests */ 1:
                    message.accruedInterests.push(AccruedInterest.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAccruedInterestsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.AccruedInterest accrued_interests = 1; */
        for (let i = 0; i < message.accruedInterests.length; i++)
            AccruedInterest.internalBinaryWrite(message.accruedInterests[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetAccruedInterestsResponse
 */
export const GetAccruedInterestsResponse = new GetAccruedInterestsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccruedInterest$Type extends MessageType<AccruedInterest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.AccruedInterest", [
            { no: 1, name: "date", kind: "message", T: () => Timestamp },
            { no: 2, name: "value", kind: "message", T: () => Quotation },
            { no: 3, name: "value_percent", kind: "message", T: () => Quotation },
            { no: 4, name: "nominal", kind: "message", T: () => Quotation }
        ]);
    }
    create(value?: PartialMessage<AccruedInterest>): AccruedInterest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccruedInterest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccruedInterest): AccruedInterest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp date */ 1:
                    message.date = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.date);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation value */ 2:
                    message.value = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation value_percent */ 3:
                    message.valuePercent = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.valuePercent);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation nominal */ 4:
                    message.nominal = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.nominal);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccruedInterest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp date = 1; */
        if (message.date)
            Timestamp.internalBinaryWrite(message.date, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation value = 2; */
        if (message.value)
            Quotation.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation value_percent = 3; */
        if (message.valuePercent)
            Quotation.internalBinaryWrite(message.valuePercent, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation nominal = 4; */
        if (message.nominal)
            Quotation.internalBinaryWrite(message.nominal, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.AccruedInterest
 */
export const AccruedInterest = new AccruedInterest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFuturesMarginRequest$Type extends MessageType<GetFuturesMarginRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetFuturesMarginRequest", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetFuturesMarginRequest>): GetFuturesMarginRequest {
        const message = { figi: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetFuturesMarginRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFuturesMarginRequest): GetFuturesMarginRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFuturesMarginRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetFuturesMarginRequest
 */
export const GetFuturesMarginRequest = new GetFuturesMarginRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFuturesMarginResponse$Type extends MessageType<GetFuturesMarginResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetFuturesMarginResponse", [
            { no: 1, name: "initial_margin_on_buy", kind: "message", T: () => MoneyValue },
            { no: 2, name: "initial_margin_on_sell", kind: "message", T: () => MoneyValue },
            { no: 3, name: "min_price_increment", kind: "message", T: () => Quotation },
            { no: 4, name: "min_price_increment_amount", kind: "message", T: () => Quotation }
        ]);
    }
    create(value?: PartialMessage<GetFuturesMarginResponse>): GetFuturesMarginResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetFuturesMarginResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFuturesMarginResponse): GetFuturesMarginResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue initial_margin_on_buy */ 1:
                    message.initialMarginOnBuy = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.initialMarginOnBuy);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue initial_margin_on_sell */ 2:
                    message.initialMarginOnSell = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.initialMarginOnSell);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment */ 3:
                    message.minPriceIncrement = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.minPriceIncrement);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment_amount */ 4:
                    message.minPriceIncrementAmount = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.minPriceIncrementAmount);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFuturesMarginResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.MoneyValue initial_margin_on_buy = 1; */
        if (message.initialMarginOnBuy)
            MoneyValue.internalBinaryWrite(message.initialMarginOnBuy, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue initial_margin_on_sell = 2; */
        if (message.initialMarginOnSell)
            MoneyValue.internalBinaryWrite(message.initialMarginOnSell, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment = 3; */
        if (message.minPriceIncrement)
            Quotation.internalBinaryWrite(message.minPriceIncrement, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment_amount = 4; */
        if (message.minPriceIncrementAmount)
            Quotation.internalBinaryWrite(message.minPriceIncrementAmount, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetFuturesMarginResponse
 */
export const GetFuturesMarginResponse = new GetFuturesMarginResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstrumentResponse$Type extends MessageType<InstrumentResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.InstrumentResponse", [
            { no: 1, name: "instrument", kind: "message", T: () => Instrument }
        ]);
    }
    create(value?: PartialMessage<InstrumentResponse>): InstrumentResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InstrumentResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstrumentResponse): InstrumentResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.Instrument instrument */ 1:
                    message.instrument = Instrument.internalBinaryRead(reader, reader.uint32(), options, message.instrument);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InstrumentResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.Instrument instrument = 1; */
        if (message.instrument)
            Instrument.internalBinaryWrite(message.instrument, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.InstrumentResponse
 */
export const InstrumentResponse = new InstrumentResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Instrument$Type extends MessageType<Instrument> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.Instrument", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "class_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "isin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "lot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "currency", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "klong", kind: "message", T: () => Quotation },
            { no: 8, name: "kshort", kind: "message", T: () => Quotation },
            { no: 9, name: "dlong", kind: "message", T: () => Quotation },
            { no: 10, name: "dshort", kind: "message", T: () => Quotation },
            { no: 11, name: "dlong_min", kind: "message", T: () => Quotation },
            { no: 12, name: "dshort_min", kind: "message", T: () => Quotation },
            { no: 13, name: "short_enabled_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "exchange", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "country_of_risk", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "country_of_risk_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "instrument_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "trading_status", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.SecurityTradingStatus", SecurityTradingStatus, "SECURITY_TRADING_STATUS_"] },
            { no: 20, name: "otc_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "buy_available_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 22, name: "sell_available_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 23, name: "min_price_increment", kind: "message", T: () => Quotation },
            { no: 24, name: "api_trade_available_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 25, name: "uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 26, name: "real_exchange", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.RealExchange", RealExchange, "REAL_EXCHANGE_"] },
            { no: 27, name: "position_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 36, name: "for_iis_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 37, name: "for_qual_investor_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 38, name: "weekend_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 39, name: "blocked_tca_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 40, name: "instrument_kind", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.InstrumentType", InstrumentType, "INSTRUMENT_TYPE_"] },
            { no: 56, name: "first_1min_candle_date", kind: "message", jsonName: "first1minCandleDate", T: () => Timestamp },
            { no: 57, name: "first_1day_candle_date", kind: "message", jsonName: "first1dayCandleDate", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<Instrument>): Instrument {
        const message = { figi: "", ticker: "", classCode: "", isin: "", lot: 0, currency: "", shortEnabledFlag: false, name: "", exchange: "", countryOfRisk: "", countryOfRiskName: "", instrumentType: "", tradingStatus: 0, otcFlag: false, buyAvailableFlag: false, sellAvailableFlag: false, apiTradeAvailableFlag: false, uid: "", realExchange: 0, positionUid: "", forIisFlag: false, forQualInvestorFlag: false, weekendFlag: false, blockedTcaFlag: false, instrumentKind: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Instrument>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Instrument): Instrument {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* string ticker */ 2:
                    message.ticker = reader.string();
                    break;
                case /* string class_code */ 3:
                    message.classCode = reader.string();
                    break;
                case /* string isin */ 4:
                    message.isin = reader.string();
                    break;
                case /* int32 lot */ 5:
                    message.lot = reader.int32();
                    break;
                case /* string currency */ 6:
                    message.currency = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation klong */ 7:
                    message.klong = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.klong);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation kshort */ 8:
                    message.kshort = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.kshort);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dlong */ 9:
                    message.dlong = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dlong);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dshort */ 10:
                    message.dshort = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dshort);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dlong_min */ 11:
                    message.dlongMin = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dlongMin);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dshort_min */ 12:
                    message.dshortMin = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dshortMin);
                    break;
                case /* bool short_enabled_flag */ 13:
                    message.shortEnabledFlag = reader.bool();
                    break;
                case /* string name */ 14:
                    message.name = reader.string();
                    break;
                case /* string exchange */ 15:
                    message.exchange = reader.string();
                    break;
                case /* string country_of_risk */ 16:
                    message.countryOfRisk = reader.string();
                    break;
                case /* string country_of_risk_name */ 17:
                    message.countryOfRiskName = reader.string();
                    break;
                case /* string instrument_type */ 18:
                    message.instrumentType = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status */ 19:
                    message.tradingStatus = reader.int32();
                    break;
                case /* bool otc_flag */ 20:
                    message.otcFlag = reader.bool();
                    break;
                case /* bool buy_available_flag */ 21:
                    message.buyAvailableFlag = reader.bool();
                    break;
                case /* bool sell_available_flag */ 22:
                    message.sellAvailableFlag = reader.bool();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment */ 23:
                    message.minPriceIncrement = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.minPriceIncrement);
                    break;
                case /* bool api_trade_available_flag */ 24:
                    message.apiTradeAvailableFlag = reader.bool();
                    break;
                case /* string uid */ 25:
                    message.uid = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.RealExchange real_exchange */ 26:
                    message.realExchange = reader.int32();
                    break;
                case /* string position_uid */ 27:
                    message.positionUid = reader.string();
                    break;
                case /* bool for_iis_flag */ 36:
                    message.forIisFlag = reader.bool();
                    break;
                case /* bool for_qual_investor_flag */ 37:
                    message.forQualInvestorFlag = reader.bool();
                    break;
                case /* bool weekend_flag */ 38:
                    message.weekendFlag = reader.bool();
                    break;
                case /* bool blocked_tca_flag */ 39:
                    message.blockedTcaFlag = reader.bool();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.InstrumentType instrument_kind */ 40:
                    message.instrumentKind = reader.int32();
                    break;
                case /* google.protobuf.Timestamp first_1min_candle_date = 56 [json_name = "first1minCandleDate"];*/ 56:
                    message.first1MinCandleDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.first1MinCandleDate);
                    break;
                case /* google.protobuf.Timestamp first_1day_candle_date = 57 [json_name = "first1dayCandleDate"];*/ 57:
                    message.first1DayCandleDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.first1DayCandleDate);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Instrument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* string ticker = 2; */
        if (message.ticker !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ticker);
        /* string class_code = 3; */
        if (message.classCode !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.classCode);
        /* string isin = 4; */
        if (message.isin !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.isin);
        /* int32 lot = 5; */
        if (message.lot !== 0)
            writer.tag(5, WireType.Varint).int32(message.lot);
        /* string currency = 6; */
        if (message.currency !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.currency);
        /* tinkoff.public.invest.api.contract.v1.Quotation klong = 7; */
        if (message.klong)
            Quotation.internalBinaryWrite(message.klong, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation kshort = 8; */
        if (message.kshort)
            Quotation.internalBinaryWrite(message.kshort, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation dlong = 9; */
        if (message.dlong)
            Quotation.internalBinaryWrite(message.dlong, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation dshort = 10; */
        if (message.dshort)
            Quotation.internalBinaryWrite(message.dshort, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation dlong_min = 11; */
        if (message.dlongMin)
            Quotation.internalBinaryWrite(message.dlongMin, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation dshort_min = 12; */
        if (message.dshortMin)
            Quotation.internalBinaryWrite(message.dshortMin, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* bool short_enabled_flag = 13; */
        if (message.shortEnabledFlag !== false)
            writer.tag(13, WireType.Varint).bool(message.shortEnabledFlag);
        /* string name = 14; */
        if (message.name !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.name);
        /* string exchange = 15; */
        if (message.exchange !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.exchange);
        /* string country_of_risk = 16; */
        if (message.countryOfRisk !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.countryOfRisk);
        /* string country_of_risk_name = 17; */
        if (message.countryOfRiskName !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.countryOfRiskName);
        /* string instrument_type = 18; */
        if (message.instrumentType !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.instrumentType);
        /* tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status = 19; */
        if (message.tradingStatus !== 0)
            writer.tag(19, WireType.Varint).int32(message.tradingStatus);
        /* bool otc_flag = 20; */
        if (message.otcFlag !== false)
            writer.tag(20, WireType.Varint).bool(message.otcFlag);
        /* bool buy_available_flag = 21; */
        if (message.buyAvailableFlag !== false)
            writer.tag(21, WireType.Varint).bool(message.buyAvailableFlag);
        /* bool sell_available_flag = 22; */
        if (message.sellAvailableFlag !== false)
            writer.tag(22, WireType.Varint).bool(message.sellAvailableFlag);
        /* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment = 23; */
        if (message.minPriceIncrement)
            Quotation.internalBinaryWrite(message.minPriceIncrement, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        /* bool api_trade_available_flag = 24; */
        if (message.apiTradeAvailableFlag !== false)
            writer.tag(24, WireType.Varint).bool(message.apiTradeAvailableFlag);
        /* string uid = 25; */
        if (message.uid !== "")
            writer.tag(25, WireType.LengthDelimited).string(message.uid);
        /* tinkoff.public.invest.api.contract.v1.RealExchange real_exchange = 26; */
        if (message.realExchange !== 0)
            writer.tag(26, WireType.Varint).int32(message.realExchange);
        /* string position_uid = 27; */
        if (message.positionUid !== "")
            writer.tag(27, WireType.LengthDelimited).string(message.positionUid);
        /* bool for_iis_flag = 36; */
        if (message.forIisFlag !== false)
            writer.tag(36, WireType.Varint).bool(message.forIisFlag);
        /* bool for_qual_investor_flag = 37; */
        if (message.forQualInvestorFlag !== false)
            writer.tag(37, WireType.Varint).bool(message.forQualInvestorFlag);
        /* bool weekend_flag = 38; */
        if (message.weekendFlag !== false)
            writer.tag(38, WireType.Varint).bool(message.weekendFlag);
        /* bool blocked_tca_flag = 39; */
        if (message.blockedTcaFlag !== false)
            writer.tag(39, WireType.Varint).bool(message.blockedTcaFlag);
        /* tinkoff.public.invest.api.contract.v1.InstrumentType instrument_kind = 40; */
        if (message.instrumentKind !== 0)
            writer.tag(40, WireType.Varint).int32(message.instrumentKind);
        /* google.protobuf.Timestamp first_1min_candle_date = 56 [json_name = "first1minCandleDate"]; */
        if (message.first1MinCandleDate)
            Timestamp.internalBinaryWrite(message.first1MinCandleDate, writer.tag(56, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp first_1day_candle_date = 57 [json_name = "first1dayCandleDate"]; */
        if (message.first1DayCandleDate)
            Timestamp.internalBinaryWrite(message.first1DayCandleDate, writer.tag(57, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.Instrument
 */
export const Instrument = new Instrument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDividendsRequest$Type extends MessageType<GetDividendsRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetDividendsRequest", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "from", kind: "message", T: () => Timestamp },
            { no: 3, name: "to", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<GetDividendsRequest>): GetDividendsRequest {
        const message = { figi: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetDividendsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDividendsRequest): GetDividendsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* google.protobuf.Timestamp from */ 2:
                    message.from = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.from);
                    break;
                case /* google.protobuf.Timestamp to */ 3:
                    message.to = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.to);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDividendsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* google.protobuf.Timestamp from = 2; */
        if (message.from)
            Timestamp.internalBinaryWrite(message.from, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp to = 3; */
        if (message.to)
            Timestamp.internalBinaryWrite(message.to, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetDividendsRequest
 */
export const GetDividendsRequest = new GetDividendsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDividendsResponse$Type extends MessageType<GetDividendsResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetDividendsResponse", [
            { no: 1, name: "dividends", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Dividend }
        ]);
    }
    create(value?: PartialMessage<GetDividendsResponse>): GetDividendsResponse {
        const message = { dividends: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetDividendsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDividendsResponse): GetDividendsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.Dividend dividends */ 1:
                    message.dividends.push(Dividend.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDividendsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.Dividend dividends = 1; */
        for (let i = 0; i < message.dividends.length; i++)
            Dividend.internalBinaryWrite(message.dividends[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetDividendsResponse
 */
export const GetDividendsResponse = new GetDividendsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Dividend$Type extends MessageType<Dividend> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.Dividend", [
            { no: 1, name: "dividend_net", kind: "message", T: () => MoneyValue },
            { no: 2, name: "payment_date", kind: "message", T: () => Timestamp },
            { no: 3, name: "declared_date", kind: "message", T: () => Timestamp },
            { no: 4, name: "last_buy_date", kind: "message", T: () => Timestamp },
            { no: 5, name: "dividend_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "record_date", kind: "message", T: () => Timestamp },
            { no: 7, name: "regularity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "close_price", kind: "message", T: () => MoneyValue },
            { no: 9, name: "yield_value", kind: "message", T: () => Quotation },
            { no: 10, name: "created_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<Dividend>): Dividend {
        const message = { dividendType: "", regularity: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Dividend>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Dividend): Dividend {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue dividend_net */ 1:
                    message.dividendNet = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.dividendNet);
                    break;
                case /* google.protobuf.Timestamp payment_date */ 2:
                    message.paymentDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.paymentDate);
                    break;
                case /* google.protobuf.Timestamp declared_date */ 3:
                    message.declaredDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.declaredDate);
                    break;
                case /* google.protobuf.Timestamp last_buy_date */ 4:
                    message.lastBuyDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastBuyDate);
                    break;
                case /* string dividend_type */ 5:
                    message.dividendType = reader.string();
                    break;
                case /* google.protobuf.Timestamp record_date */ 6:
                    message.recordDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.recordDate);
                    break;
                case /* string regularity */ 7:
                    message.regularity = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue close_price */ 8:
                    message.closePrice = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.closePrice);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation yield_value */ 9:
                    message.yieldValue = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.yieldValue);
                    break;
                case /* google.protobuf.Timestamp created_at */ 10:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Dividend, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.MoneyValue dividend_net = 1; */
        if (message.dividendNet)
            MoneyValue.internalBinaryWrite(message.dividendNet, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp payment_date = 2; */
        if (message.paymentDate)
            Timestamp.internalBinaryWrite(message.paymentDate, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp declared_date = 3; */
        if (message.declaredDate)
            Timestamp.internalBinaryWrite(message.declaredDate, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_buy_date = 4; */
        if (message.lastBuyDate)
            Timestamp.internalBinaryWrite(message.lastBuyDate, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string dividend_type = 5; */
        if (message.dividendType !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.dividendType);
        /* google.protobuf.Timestamp record_date = 6; */
        if (message.recordDate)
            Timestamp.internalBinaryWrite(message.recordDate, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string regularity = 7; */
        if (message.regularity !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.regularity);
        /* tinkoff.public.invest.api.contract.v1.MoneyValue close_price = 8; */
        if (message.closePrice)
            MoneyValue.internalBinaryWrite(message.closePrice, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation yield_value = 9; */
        if (message.yieldValue)
            Quotation.internalBinaryWrite(message.yieldValue, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp created_at = 10; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.Dividend
 */
export const Dividend = new Dividend$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AssetRequest$Type extends MessageType<AssetRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.AssetRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AssetRequest>): AssetRequest {
        const message = { id: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AssetRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AssetRequest): AssetRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AssetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.AssetRequest
 */
export const AssetRequest = new AssetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AssetResponse$Type extends MessageType<AssetResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.AssetResponse", [
            { no: 1, name: "asset", kind: "message", T: () => AssetFull }
        ]);
    }
    create(value?: PartialMessage<AssetResponse>): AssetResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AssetResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AssetResponse): AssetResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.AssetFull asset */ 1:
                    message.asset = AssetFull.internalBinaryRead(reader, reader.uint32(), options, message.asset);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AssetResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.AssetFull asset = 1; */
        if (message.asset)
            AssetFull.internalBinaryWrite(message.asset, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.AssetResponse
 */
export const AssetResponse = new AssetResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AssetsRequest$Type extends MessageType<AssetsRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.AssetsRequest", []);
    }
    create(value?: PartialMessage<AssetsRequest>): AssetsRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AssetsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AssetsRequest): AssetsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: AssetsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.AssetsRequest
 */
export const AssetsRequest = new AssetsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AssetsResponse$Type extends MessageType<AssetsResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.AssetsResponse", [
            { no: 1, name: "assets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Asset }
        ]);
    }
    create(value?: PartialMessage<AssetsResponse>): AssetsResponse {
        const message = { assets: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AssetsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AssetsResponse): AssetsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.Asset assets */ 1:
                    message.assets.push(Asset.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AssetsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.Asset assets = 1; */
        for (let i = 0; i < message.assets.length; i++)
            Asset.internalBinaryWrite(message.assets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.AssetsResponse
 */
export const AssetsResponse = new AssetsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AssetFull$Type extends MessageType<AssetFull> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.AssetFull", [
            { no: 1, name: "uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.AssetType", AssetType, "ASSET_TYPE_"] },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "name_brief", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "deleted_at", kind: "message", T: () => Timestamp },
            { no: 7, name: "required_tests", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "currency", kind: "message", oneof: "ext", T: () => AssetCurrency },
            { no: 9, name: "security", kind: "message", oneof: "ext", T: () => AssetSecurity },
            { no: 10, name: "gos_reg_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "cfi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "code_nsd", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "brand", kind: "message", T: () => Brand },
            { no: 15, name: "updated_at", kind: "message", T: () => Timestamp },
            { no: 16, name: "br_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "br_code_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "instruments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AssetInstrument }
        ]);
    }
    create(value?: PartialMessage<AssetFull>): AssetFull {
        const message = { uid: "", type: 0, name: "", nameBrief: "", description: "", requiredTests: [], ext: { oneofKind: undefined }, gosRegCode: "", cfi: "", codeNsd: "", status: "", brCode: "", brCodeName: "", instruments: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AssetFull>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AssetFull): AssetFull {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uid */ 1:
                    message.uid = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.AssetType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string name_brief */ 4:
                    message.nameBrief = reader.string();
                    break;
                case /* string description */ 5:
                    message.description = reader.string();
                    break;
                case /* google.protobuf.Timestamp deleted_at */ 6:
                    message.deletedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.deletedAt);
                    break;
                case /* repeated string required_tests */ 7:
                    message.requiredTests.push(reader.string());
                    break;
                case /* tinkoff.public.invest.api.contract.v1.AssetCurrency currency */ 8:
                    message.ext = {
                        oneofKind: "currency",
                        currency: AssetCurrency.internalBinaryRead(reader, reader.uint32(), options, (message.ext as any).currency)
                    };
                    break;
                case /* tinkoff.public.invest.api.contract.v1.AssetSecurity security */ 9:
                    message.ext = {
                        oneofKind: "security",
                        security: AssetSecurity.internalBinaryRead(reader, reader.uint32(), options, (message.ext as any).security)
                    };
                    break;
                case /* string gos_reg_code */ 10:
                    message.gosRegCode = reader.string();
                    break;
                case /* string cfi */ 11:
                    message.cfi = reader.string();
                    break;
                case /* string code_nsd */ 12:
                    message.codeNsd = reader.string();
                    break;
                case /* string status */ 13:
                    message.status = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Brand brand */ 14:
                    message.brand = Brand.internalBinaryRead(reader, reader.uint32(), options, message.brand);
                    break;
                case /* google.protobuf.Timestamp updated_at */ 15:
                    message.updatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updatedAt);
                    break;
                case /* string br_code */ 16:
                    message.brCode = reader.string();
                    break;
                case /* string br_code_name */ 17:
                    message.brCodeName = reader.string();
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.AssetInstrument instruments */ 18:
                    message.instruments.push(AssetInstrument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AssetFull, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uid = 1; */
        if (message.uid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uid);
        /* tinkoff.public.invest.api.contract.v1.AssetType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string name_brief = 4; */
        if (message.nameBrief !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.nameBrief);
        /* string description = 5; */
        if (message.description !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.description);
        /* google.protobuf.Timestamp deleted_at = 6; */
        if (message.deletedAt)
            Timestamp.internalBinaryWrite(message.deletedAt, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated string required_tests = 7; */
        for (let i = 0; i < message.requiredTests.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.requiredTests[i]);
        /* tinkoff.public.invest.api.contract.v1.AssetCurrency currency = 8; */
        if (message.ext.oneofKind === "currency")
            AssetCurrency.internalBinaryWrite(message.ext.currency, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.AssetSecurity security = 9; */
        if (message.ext.oneofKind === "security")
            AssetSecurity.internalBinaryWrite(message.ext.security, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* string gos_reg_code = 10; */
        if (message.gosRegCode !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.gosRegCode);
        /* string cfi = 11; */
        if (message.cfi !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.cfi);
        /* string code_nsd = 12; */
        if (message.codeNsd !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.codeNsd);
        /* string status = 13; */
        if (message.status !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.status);
        /* tinkoff.public.invest.api.contract.v1.Brand brand = 14; */
        if (message.brand)
            Brand.internalBinaryWrite(message.brand, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp updated_at = 15; */
        if (message.updatedAt)
            Timestamp.internalBinaryWrite(message.updatedAt, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* string br_code = 16; */
        if (message.brCode !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.brCode);
        /* string br_code_name = 17; */
        if (message.brCodeName !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.brCodeName);
        /* repeated tinkoff.public.invest.api.contract.v1.AssetInstrument instruments = 18; */
        for (let i = 0; i < message.instruments.length; i++)
            AssetInstrument.internalBinaryWrite(message.instruments[i], writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.AssetFull
 */
export const AssetFull = new AssetFull$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Asset$Type extends MessageType<Asset> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.Asset", [
            { no: 1, name: "uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.AssetType", AssetType, "ASSET_TYPE_"] },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "instruments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AssetInstrument }
        ]);
    }
    create(value?: PartialMessage<Asset>): Asset {
        const message = { uid: "", type: 0, name: "", instruments: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Asset>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Asset): Asset {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uid */ 1:
                    message.uid = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.AssetType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.AssetInstrument instruments */ 4:
                    message.instruments.push(AssetInstrument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Asset, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uid = 1; */
        if (message.uid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uid);
        /* tinkoff.public.invest.api.contract.v1.AssetType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* repeated tinkoff.public.invest.api.contract.v1.AssetInstrument instruments = 4; */
        for (let i = 0; i < message.instruments.length; i++)
            AssetInstrument.internalBinaryWrite(message.instruments[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.Asset
 */
export const Asset = new Asset$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AssetCurrency$Type extends MessageType<AssetCurrency> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.AssetCurrency", [
            { no: 1, name: "base_currency", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AssetCurrency>): AssetCurrency {
        const message = { baseCurrency: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AssetCurrency>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AssetCurrency): AssetCurrency {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string base_currency */ 1:
                    message.baseCurrency = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AssetCurrency, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string base_currency = 1; */
        if (message.baseCurrency !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.baseCurrency);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.AssetCurrency
 */
export const AssetCurrency = new AssetCurrency$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AssetSecurity$Type extends MessageType<AssetSecurity> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.AssetSecurity", [
            { no: 1, name: "isin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "instrument_kind", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.InstrumentType", InstrumentType, "INSTRUMENT_TYPE_"] },
            { no: 3, name: "share", kind: "message", oneof: "ext", T: () => AssetShare },
            { no: 4, name: "bond", kind: "message", oneof: "ext", T: () => AssetBond },
            { no: 5, name: "sp", kind: "message", oneof: "ext", T: () => AssetStructuredProduct },
            { no: 6, name: "etf", kind: "message", oneof: "ext", T: () => AssetEtf },
            { no: 7, name: "clearing_certificate", kind: "message", oneof: "ext", T: () => AssetClearingCertificate }
        ]);
    }
    create(value?: PartialMessage<AssetSecurity>): AssetSecurity {
        const message = { isin: "", type: "", instrumentKind: 0, ext: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AssetSecurity>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AssetSecurity): AssetSecurity {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string isin */ 1:
                    message.isin = reader.string();
                    break;
                case /* string type */ 2:
                    message.type = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.InstrumentType instrument_kind */ 10:
                    message.instrumentKind = reader.int32();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.AssetShare share */ 3:
                    message.ext = {
                        oneofKind: "share",
                        share: AssetShare.internalBinaryRead(reader, reader.uint32(), options, (message.ext as any).share)
                    };
                    break;
                case /* tinkoff.public.invest.api.contract.v1.AssetBond bond */ 4:
                    message.ext = {
                        oneofKind: "bond",
                        bond: AssetBond.internalBinaryRead(reader, reader.uint32(), options, (message.ext as any).bond)
                    };
                    break;
                case /* tinkoff.public.invest.api.contract.v1.AssetStructuredProduct sp */ 5:
                    message.ext = {
                        oneofKind: "sp",
                        sp: AssetStructuredProduct.internalBinaryRead(reader, reader.uint32(), options, (message.ext as any).sp)
                    };
                    break;
                case /* tinkoff.public.invest.api.contract.v1.AssetEtf etf */ 6:
                    message.ext = {
                        oneofKind: "etf",
                        etf: AssetEtf.internalBinaryRead(reader, reader.uint32(), options, (message.ext as any).etf)
                    };
                    break;
                case /* tinkoff.public.invest.api.contract.v1.AssetClearingCertificate clearing_certificate */ 7:
                    message.ext = {
                        oneofKind: "clearingCertificate",
                        clearingCertificate: AssetClearingCertificate.internalBinaryRead(reader, reader.uint32(), options, (message.ext as any).clearingCertificate)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AssetSecurity, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string isin = 1; */
        if (message.isin !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.isin);
        /* string type = 2; */
        if (message.type !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        /* tinkoff.public.invest.api.contract.v1.InstrumentType instrument_kind = 10; */
        if (message.instrumentKind !== 0)
            writer.tag(10, WireType.Varint).int32(message.instrumentKind);
        /* tinkoff.public.invest.api.contract.v1.AssetShare share = 3; */
        if (message.ext.oneofKind === "share")
            AssetShare.internalBinaryWrite(message.ext.share, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.AssetBond bond = 4; */
        if (message.ext.oneofKind === "bond")
            AssetBond.internalBinaryWrite(message.ext.bond, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.AssetStructuredProduct sp = 5; */
        if (message.ext.oneofKind === "sp")
            AssetStructuredProduct.internalBinaryWrite(message.ext.sp, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.AssetEtf etf = 6; */
        if (message.ext.oneofKind === "etf")
            AssetEtf.internalBinaryWrite(message.ext.etf, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.AssetClearingCertificate clearing_certificate = 7; */
        if (message.ext.oneofKind === "clearingCertificate")
            AssetClearingCertificate.internalBinaryWrite(message.ext.clearingCertificate, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.AssetSecurity
 */
export const AssetSecurity = new AssetSecurity$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AssetShare$Type extends MessageType<AssetShare> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.AssetShare", [
            { no: 1, name: "type", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.ShareType", ShareType, "SHARE_TYPE_"] },
            { no: 2, name: "issue_size", kind: "message", T: () => Quotation },
            { no: 3, name: "nominal", kind: "message", T: () => Quotation },
            { no: 4, name: "nominal_currency", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "primary_index", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "dividend_rate", kind: "message", T: () => Quotation },
            { no: 7, name: "preferred_share_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "ipo_date", kind: "message", T: () => Timestamp },
            { no: 9, name: "registry_date", kind: "message", T: () => Timestamp },
            { no: 10, name: "div_yield_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "issue_kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "placement_date", kind: "message", T: () => Timestamp },
            { no: 13, name: "repres_isin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "issue_size_plan", kind: "message", T: () => Quotation },
            { no: 15, name: "total_float", kind: "message", T: () => Quotation }
        ]);
    }
    create(value?: PartialMessage<AssetShare>): AssetShare {
        const message = { type: 0, nominalCurrency: "", primaryIndex: "", preferredShareType: "", divYieldFlag: false, issueKind: "", represIsin: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AssetShare>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AssetShare): AssetShare {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.ShareType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation issue_size */ 2:
                    message.issueSize = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.issueSize);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation nominal */ 3:
                    message.nominal = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.nominal);
                    break;
                case /* string nominal_currency */ 4:
                    message.nominalCurrency = reader.string();
                    break;
                case /* string primary_index */ 5:
                    message.primaryIndex = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dividend_rate */ 6:
                    message.dividendRate = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dividendRate);
                    break;
                case /* string preferred_share_type */ 7:
                    message.preferredShareType = reader.string();
                    break;
                case /* google.protobuf.Timestamp ipo_date */ 8:
                    message.ipoDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.ipoDate);
                    break;
                case /* google.protobuf.Timestamp registry_date */ 9:
                    message.registryDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.registryDate);
                    break;
                case /* bool div_yield_flag */ 10:
                    message.divYieldFlag = reader.bool();
                    break;
                case /* string issue_kind */ 11:
                    message.issueKind = reader.string();
                    break;
                case /* google.protobuf.Timestamp placement_date */ 12:
                    message.placementDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.placementDate);
                    break;
                case /* string repres_isin */ 13:
                    message.represIsin = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation issue_size_plan */ 14:
                    message.issueSizePlan = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.issueSizePlan);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation total_float */ 15:
                    message.totalFloat = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.totalFloat);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AssetShare, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.ShareType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* tinkoff.public.invest.api.contract.v1.Quotation issue_size = 2; */
        if (message.issueSize)
            Quotation.internalBinaryWrite(message.issueSize, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation nominal = 3; */
        if (message.nominal)
            Quotation.internalBinaryWrite(message.nominal, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string nominal_currency = 4; */
        if (message.nominalCurrency !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.nominalCurrency);
        /* string primary_index = 5; */
        if (message.primaryIndex !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.primaryIndex);
        /* tinkoff.public.invest.api.contract.v1.Quotation dividend_rate = 6; */
        if (message.dividendRate)
            Quotation.internalBinaryWrite(message.dividendRate, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string preferred_share_type = 7; */
        if (message.preferredShareType !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.preferredShareType);
        /* google.protobuf.Timestamp ipo_date = 8; */
        if (message.ipoDate)
            Timestamp.internalBinaryWrite(message.ipoDate, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp registry_date = 9; */
        if (message.registryDate)
            Timestamp.internalBinaryWrite(message.registryDate, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* bool div_yield_flag = 10; */
        if (message.divYieldFlag !== false)
            writer.tag(10, WireType.Varint).bool(message.divYieldFlag);
        /* string issue_kind = 11; */
        if (message.issueKind !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.issueKind);
        /* google.protobuf.Timestamp placement_date = 12; */
        if (message.placementDate)
            Timestamp.internalBinaryWrite(message.placementDate, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* string repres_isin = 13; */
        if (message.represIsin !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.represIsin);
        /* tinkoff.public.invest.api.contract.v1.Quotation issue_size_plan = 14; */
        if (message.issueSizePlan)
            Quotation.internalBinaryWrite(message.issueSizePlan, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation total_float = 15; */
        if (message.totalFloat)
            Quotation.internalBinaryWrite(message.totalFloat, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.AssetShare
 */
export const AssetShare = new AssetShare$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AssetBond$Type extends MessageType<AssetBond> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.AssetBond", [
            { no: 1, name: "current_nominal", kind: "message", T: () => Quotation },
            { no: 2, name: "borrow_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "issue_size", kind: "message", T: () => Quotation },
            { no: 4, name: "nominal", kind: "message", T: () => Quotation },
            { no: 5, name: "nominal_currency", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "issue_kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "interest_kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "coupon_quantity_per_year", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "indexed_nominal_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "subordinated_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "collateral_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "tax_free_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "amortization_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "floating_coupon_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "perpetual_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "maturity_date", kind: "message", T: () => Timestamp },
            { no: 17, name: "return_condition", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "state_reg_date", kind: "message", T: () => Timestamp },
            { no: 19, name: "placement_date", kind: "message", T: () => Timestamp },
            { no: 20, name: "placement_price", kind: "message", T: () => Quotation },
            { no: 21, name: "issue_size_plan", kind: "message", T: () => Quotation }
        ]);
    }
    create(value?: PartialMessage<AssetBond>): AssetBond {
        const message = { borrowName: "", nominalCurrency: "", issueKind: "", interestKind: "", couponQuantityPerYear: 0, indexedNominalFlag: false, subordinatedFlag: false, collateralFlag: false, taxFreeFlag: false, amortizationFlag: false, floatingCouponFlag: false, perpetualFlag: false, returnCondition: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AssetBond>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AssetBond): AssetBond {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.Quotation current_nominal */ 1:
                    message.currentNominal = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.currentNominal);
                    break;
                case /* string borrow_name */ 2:
                    message.borrowName = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation issue_size */ 3:
                    message.issueSize = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.issueSize);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation nominal */ 4:
                    message.nominal = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.nominal);
                    break;
                case /* string nominal_currency */ 5:
                    message.nominalCurrency = reader.string();
                    break;
                case /* string issue_kind */ 6:
                    message.issueKind = reader.string();
                    break;
                case /* string interest_kind */ 7:
                    message.interestKind = reader.string();
                    break;
                case /* int32 coupon_quantity_per_year */ 8:
                    message.couponQuantityPerYear = reader.int32();
                    break;
                case /* bool indexed_nominal_flag */ 9:
                    message.indexedNominalFlag = reader.bool();
                    break;
                case /* bool subordinated_flag */ 10:
                    message.subordinatedFlag = reader.bool();
                    break;
                case /* bool collateral_flag */ 11:
                    message.collateralFlag = reader.bool();
                    break;
                case /* bool tax_free_flag */ 12:
                    message.taxFreeFlag = reader.bool();
                    break;
                case /* bool amortization_flag */ 13:
                    message.amortizationFlag = reader.bool();
                    break;
                case /* bool floating_coupon_flag */ 14:
                    message.floatingCouponFlag = reader.bool();
                    break;
                case /* bool perpetual_flag */ 15:
                    message.perpetualFlag = reader.bool();
                    break;
                case /* google.protobuf.Timestamp maturity_date */ 16:
                    message.maturityDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.maturityDate);
                    break;
                case /* string return_condition */ 17:
                    message.returnCondition = reader.string();
                    break;
                case /* google.protobuf.Timestamp state_reg_date */ 18:
                    message.stateRegDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.stateRegDate);
                    break;
                case /* google.protobuf.Timestamp placement_date */ 19:
                    message.placementDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.placementDate);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation placement_price */ 20:
                    message.placementPrice = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.placementPrice);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation issue_size_plan */ 21:
                    message.issueSizePlan = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.issueSizePlan);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AssetBond, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.Quotation current_nominal = 1; */
        if (message.currentNominal)
            Quotation.internalBinaryWrite(message.currentNominal, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string borrow_name = 2; */
        if (message.borrowName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.borrowName);
        /* tinkoff.public.invest.api.contract.v1.Quotation issue_size = 3; */
        if (message.issueSize)
            Quotation.internalBinaryWrite(message.issueSize, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation nominal = 4; */
        if (message.nominal)
            Quotation.internalBinaryWrite(message.nominal, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string nominal_currency = 5; */
        if (message.nominalCurrency !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.nominalCurrency);
        /* string issue_kind = 6; */
        if (message.issueKind !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.issueKind);
        /* string interest_kind = 7; */
        if (message.interestKind !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.interestKind);
        /* int32 coupon_quantity_per_year = 8; */
        if (message.couponQuantityPerYear !== 0)
            writer.tag(8, WireType.Varint).int32(message.couponQuantityPerYear);
        /* bool indexed_nominal_flag = 9; */
        if (message.indexedNominalFlag !== false)
            writer.tag(9, WireType.Varint).bool(message.indexedNominalFlag);
        /* bool subordinated_flag = 10; */
        if (message.subordinatedFlag !== false)
            writer.tag(10, WireType.Varint).bool(message.subordinatedFlag);
        /* bool collateral_flag = 11; */
        if (message.collateralFlag !== false)
            writer.tag(11, WireType.Varint).bool(message.collateralFlag);
        /* bool tax_free_flag = 12; */
        if (message.taxFreeFlag !== false)
            writer.tag(12, WireType.Varint).bool(message.taxFreeFlag);
        /* bool amortization_flag = 13; */
        if (message.amortizationFlag !== false)
            writer.tag(13, WireType.Varint).bool(message.amortizationFlag);
        /* bool floating_coupon_flag = 14; */
        if (message.floatingCouponFlag !== false)
            writer.tag(14, WireType.Varint).bool(message.floatingCouponFlag);
        /* bool perpetual_flag = 15; */
        if (message.perpetualFlag !== false)
            writer.tag(15, WireType.Varint).bool(message.perpetualFlag);
        /* google.protobuf.Timestamp maturity_date = 16; */
        if (message.maturityDate)
            Timestamp.internalBinaryWrite(message.maturityDate, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* string return_condition = 17; */
        if (message.returnCondition !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.returnCondition);
        /* google.protobuf.Timestamp state_reg_date = 18; */
        if (message.stateRegDate)
            Timestamp.internalBinaryWrite(message.stateRegDate, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp placement_date = 19; */
        if (message.placementDate)
            Timestamp.internalBinaryWrite(message.placementDate, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation placement_price = 20; */
        if (message.placementPrice)
            Quotation.internalBinaryWrite(message.placementPrice, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation issue_size_plan = 21; */
        if (message.issueSizePlan)
            Quotation.internalBinaryWrite(message.issueSizePlan, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.AssetBond
 */
export const AssetBond = new AssetBond$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AssetStructuredProduct$Type extends MessageType<AssetStructuredProduct> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.AssetStructuredProduct", [
            { no: 1, name: "borrow_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "nominal", kind: "message", T: () => Quotation },
            { no: 3, name: "nominal_currency", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "type", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.StructuredProductType", StructuredProductType] },
            { no: 5, name: "logic_portfolio", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "asset_type", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.AssetType", AssetType, "ASSET_TYPE_"] },
            { no: 7, name: "basic_asset", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "safety_barrier", kind: "message", T: () => Quotation },
            { no: 9, name: "maturity_date", kind: "message", T: () => Timestamp },
            { no: 10, name: "issue_size_plan", kind: "message", T: () => Quotation },
            { no: 11, name: "issue_size", kind: "message", T: () => Quotation },
            { no: 12, name: "placement_date", kind: "message", T: () => Timestamp },
            { no: 13, name: "issue_kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AssetStructuredProduct>): AssetStructuredProduct {
        const message = { borrowName: "", nominalCurrency: "", type: 0, logicPortfolio: "", assetType: 0, basicAsset: "", issueKind: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AssetStructuredProduct>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AssetStructuredProduct): AssetStructuredProduct {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string borrow_name */ 1:
                    message.borrowName = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation nominal */ 2:
                    message.nominal = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.nominal);
                    break;
                case /* string nominal_currency */ 3:
                    message.nominalCurrency = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.StructuredProductType type */ 4:
                    message.type = reader.int32();
                    break;
                case /* string logic_portfolio */ 5:
                    message.logicPortfolio = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.AssetType asset_type */ 6:
                    message.assetType = reader.int32();
                    break;
                case /* string basic_asset */ 7:
                    message.basicAsset = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation safety_barrier */ 8:
                    message.safetyBarrier = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.safetyBarrier);
                    break;
                case /* google.protobuf.Timestamp maturity_date */ 9:
                    message.maturityDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.maturityDate);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation issue_size_plan */ 10:
                    message.issueSizePlan = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.issueSizePlan);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation issue_size */ 11:
                    message.issueSize = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.issueSize);
                    break;
                case /* google.protobuf.Timestamp placement_date */ 12:
                    message.placementDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.placementDate);
                    break;
                case /* string issue_kind */ 13:
                    message.issueKind = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AssetStructuredProduct, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string borrow_name = 1; */
        if (message.borrowName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.borrowName);
        /* tinkoff.public.invest.api.contract.v1.Quotation nominal = 2; */
        if (message.nominal)
            Quotation.internalBinaryWrite(message.nominal, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string nominal_currency = 3; */
        if (message.nominalCurrency !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.nominalCurrency);
        /* tinkoff.public.invest.api.contract.v1.StructuredProductType type = 4; */
        if (message.type !== 0)
            writer.tag(4, WireType.Varint).int32(message.type);
        /* string logic_portfolio = 5; */
        if (message.logicPortfolio !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.logicPortfolio);
        /* tinkoff.public.invest.api.contract.v1.AssetType asset_type = 6; */
        if (message.assetType !== 0)
            writer.tag(6, WireType.Varint).int32(message.assetType);
        /* string basic_asset = 7; */
        if (message.basicAsset !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.basicAsset);
        /* tinkoff.public.invest.api.contract.v1.Quotation safety_barrier = 8; */
        if (message.safetyBarrier)
            Quotation.internalBinaryWrite(message.safetyBarrier, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp maturity_date = 9; */
        if (message.maturityDate)
            Timestamp.internalBinaryWrite(message.maturityDate, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation issue_size_plan = 10; */
        if (message.issueSizePlan)
            Quotation.internalBinaryWrite(message.issueSizePlan, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation issue_size = 11; */
        if (message.issueSize)
            Quotation.internalBinaryWrite(message.issueSize, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp placement_date = 12; */
        if (message.placementDate)
            Timestamp.internalBinaryWrite(message.placementDate, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* string issue_kind = 13; */
        if (message.issueKind !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.issueKind);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.AssetStructuredProduct
 */
export const AssetStructuredProduct = new AssetStructuredProduct$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AssetEtf$Type extends MessageType<AssetEtf> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.AssetEtf", [
            { no: 1, name: "total_expense", kind: "message", T: () => Quotation },
            { no: 2, name: "hurdle_rate", kind: "message", T: () => Quotation },
            { no: 3, name: "performance_fee", kind: "message", T: () => Quotation },
            { no: 4, name: "fixed_commission", kind: "message", T: () => Quotation },
            { no: 5, name: "payment_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "watermark_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "buy_premium", kind: "message", T: () => Quotation },
            { no: 8, name: "sell_discount", kind: "message", T: () => Quotation },
            { no: 9, name: "rebalancing_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "rebalancing_freq", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "management_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "primary_index", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "focus_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "leveraged_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "num_share", kind: "message", T: () => Quotation },
            { no: 16, name: "ucits_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "released_date", kind: "message", T: () => Timestamp },
            { no: 18, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "primary_index_description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "primary_index_company", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 21, name: "index_recovery_period", kind: "message", T: () => Quotation },
            { no: 22, name: "inav_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 23, name: "div_yield_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 24, name: "expense_commission", kind: "message", T: () => Quotation },
            { no: 25, name: "primary_index_tracking_error", kind: "message", T: () => Quotation },
            { no: 26, name: "rebalancing_plan", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 27, name: "tax_rate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 28, name: "rebalancing_dates", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Timestamp },
            { no: 29, name: "issue_kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 30, name: "nominal", kind: "message", T: () => Quotation },
            { no: 31, name: "nominal_currency", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AssetEtf>): AssetEtf {
        const message = { paymentType: "", watermarkFlag: false, rebalancingFlag: false, rebalancingFreq: "", managementType: "", primaryIndex: "", focusType: "", leveragedFlag: false, ucitsFlag: false, description: "", primaryIndexDescription: "", primaryIndexCompany: "", inavCode: "", divYieldFlag: false, rebalancingPlan: "", taxRate: "", rebalancingDates: [], issueKind: "", nominalCurrency: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AssetEtf>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AssetEtf): AssetEtf {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.Quotation total_expense */ 1:
                    message.totalExpense = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.totalExpense);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation hurdle_rate */ 2:
                    message.hurdleRate = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.hurdleRate);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation performance_fee */ 3:
                    message.performanceFee = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.performanceFee);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation fixed_commission */ 4:
                    message.fixedCommission = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.fixedCommission);
                    break;
                case /* string payment_type */ 5:
                    message.paymentType = reader.string();
                    break;
                case /* bool watermark_flag */ 6:
                    message.watermarkFlag = reader.bool();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation buy_premium */ 7:
                    message.buyPremium = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.buyPremium);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation sell_discount */ 8:
                    message.sellDiscount = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.sellDiscount);
                    break;
                case /* bool rebalancing_flag */ 9:
                    message.rebalancingFlag = reader.bool();
                    break;
                case /* string rebalancing_freq */ 10:
                    message.rebalancingFreq = reader.string();
                    break;
                case /* string management_type */ 11:
                    message.managementType = reader.string();
                    break;
                case /* string primary_index */ 12:
                    message.primaryIndex = reader.string();
                    break;
                case /* string focus_type */ 13:
                    message.focusType = reader.string();
                    break;
                case /* bool leveraged_flag */ 14:
                    message.leveragedFlag = reader.bool();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation num_share */ 15:
                    message.numShare = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.numShare);
                    break;
                case /* bool ucits_flag */ 16:
                    message.ucitsFlag = reader.bool();
                    break;
                case /* google.protobuf.Timestamp released_date */ 17:
                    message.releasedDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.releasedDate);
                    break;
                case /* string description */ 18:
                    message.description = reader.string();
                    break;
                case /* string primary_index_description */ 19:
                    message.primaryIndexDescription = reader.string();
                    break;
                case /* string primary_index_company */ 20:
                    message.primaryIndexCompany = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation index_recovery_period */ 21:
                    message.indexRecoveryPeriod = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.indexRecoveryPeriod);
                    break;
                case /* string inav_code */ 22:
                    message.inavCode = reader.string();
                    break;
                case /* bool div_yield_flag */ 23:
                    message.divYieldFlag = reader.bool();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation expense_commission */ 24:
                    message.expenseCommission = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.expenseCommission);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation primary_index_tracking_error */ 25:
                    message.primaryIndexTrackingError = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.primaryIndexTrackingError);
                    break;
                case /* string rebalancing_plan */ 26:
                    message.rebalancingPlan = reader.string();
                    break;
                case /* string tax_rate */ 27:
                    message.taxRate = reader.string();
                    break;
                case /* repeated google.protobuf.Timestamp rebalancing_dates */ 28:
                    message.rebalancingDates.push(Timestamp.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string issue_kind */ 29:
                    message.issueKind = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation nominal */ 30:
                    message.nominal = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.nominal);
                    break;
                case /* string nominal_currency */ 31:
                    message.nominalCurrency = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AssetEtf, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.Quotation total_expense = 1; */
        if (message.totalExpense)
            Quotation.internalBinaryWrite(message.totalExpense, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation hurdle_rate = 2; */
        if (message.hurdleRate)
            Quotation.internalBinaryWrite(message.hurdleRate, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation performance_fee = 3; */
        if (message.performanceFee)
            Quotation.internalBinaryWrite(message.performanceFee, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation fixed_commission = 4; */
        if (message.fixedCommission)
            Quotation.internalBinaryWrite(message.fixedCommission, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string payment_type = 5; */
        if (message.paymentType !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.paymentType);
        /* bool watermark_flag = 6; */
        if (message.watermarkFlag !== false)
            writer.tag(6, WireType.Varint).bool(message.watermarkFlag);
        /* tinkoff.public.invest.api.contract.v1.Quotation buy_premium = 7; */
        if (message.buyPremium)
            Quotation.internalBinaryWrite(message.buyPremium, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation sell_discount = 8; */
        if (message.sellDiscount)
            Quotation.internalBinaryWrite(message.sellDiscount, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* bool rebalancing_flag = 9; */
        if (message.rebalancingFlag !== false)
            writer.tag(9, WireType.Varint).bool(message.rebalancingFlag);
        /* string rebalancing_freq = 10; */
        if (message.rebalancingFreq !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.rebalancingFreq);
        /* string management_type = 11; */
        if (message.managementType !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.managementType);
        /* string primary_index = 12; */
        if (message.primaryIndex !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.primaryIndex);
        /* string focus_type = 13; */
        if (message.focusType !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.focusType);
        /* bool leveraged_flag = 14; */
        if (message.leveragedFlag !== false)
            writer.tag(14, WireType.Varint).bool(message.leveragedFlag);
        /* tinkoff.public.invest.api.contract.v1.Quotation num_share = 15; */
        if (message.numShare)
            Quotation.internalBinaryWrite(message.numShare, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* bool ucits_flag = 16; */
        if (message.ucitsFlag !== false)
            writer.tag(16, WireType.Varint).bool(message.ucitsFlag);
        /* google.protobuf.Timestamp released_date = 17; */
        if (message.releasedDate)
            Timestamp.internalBinaryWrite(message.releasedDate, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* string description = 18; */
        if (message.description !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.description);
        /* string primary_index_description = 19; */
        if (message.primaryIndexDescription !== "")
            writer.tag(19, WireType.LengthDelimited).string(message.primaryIndexDescription);
        /* string primary_index_company = 20; */
        if (message.primaryIndexCompany !== "")
            writer.tag(20, WireType.LengthDelimited).string(message.primaryIndexCompany);
        /* tinkoff.public.invest.api.contract.v1.Quotation index_recovery_period = 21; */
        if (message.indexRecoveryPeriod)
            Quotation.internalBinaryWrite(message.indexRecoveryPeriod, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* string inav_code = 22; */
        if (message.inavCode !== "")
            writer.tag(22, WireType.LengthDelimited).string(message.inavCode);
        /* bool div_yield_flag = 23; */
        if (message.divYieldFlag !== false)
            writer.tag(23, WireType.Varint).bool(message.divYieldFlag);
        /* tinkoff.public.invest.api.contract.v1.Quotation expense_commission = 24; */
        if (message.expenseCommission)
            Quotation.internalBinaryWrite(message.expenseCommission, writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation primary_index_tracking_error = 25; */
        if (message.primaryIndexTrackingError)
            Quotation.internalBinaryWrite(message.primaryIndexTrackingError, writer.tag(25, WireType.LengthDelimited).fork(), options).join();
        /* string rebalancing_plan = 26; */
        if (message.rebalancingPlan !== "")
            writer.tag(26, WireType.LengthDelimited).string(message.rebalancingPlan);
        /* string tax_rate = 27; */
        if (message.taxRate !== "")
            writer.tag(27, WireType.LengthDelimited).string(message.taxRate);
        /* repeated google.protobuf.Timestamp rebalancing_dates = 28; */
        for (let i = 0; i < message.rebalancingDates.length; i++)
            Timestamp.internalBinaryWrite(message.rebalancingDates[i], writer.tag(28, WireType.LengthDelimited).fork(), options).join();
        /* string issue_kind = 29; */
        if (message.issueKind !== "")
            writer.tag(29, WireType.LengthDelimited).string(message.issueKind);
        /* tinkoff.public.invest.api.contract.v1.Quotation nominal = 30; */
        if (message.nominal)
            Quotation.internalBinaryWrite(message.nominal, writer.tag(30, WireType.LengthDelimited).fork(), options).join();
        /* string nominal_currency = 31; */
        if (message.nominalCurrency !== "")
            writer.tag(31, WireType.LengthDelimited).string(message.nominalCurrency);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.AssetEtf
 */
export const AssetEtf = new AssetEtf$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AssetClearingCertificate$Type extends MessageType<AssetClearingCertificate> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.AssetClearingCertificate", [
            { no: 1, name: "nominal", kind: "message", T: () => Quotation },
            { no: 2, name: "nominal_currency", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AssetClearingCertificate>): AssetClearingCertificate {
        const message = { nominalCurrency: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AssetClearingCertificate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AssetClearingCertificate): AssetClearingCertificate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.Quotation nominal */ 1:
                    message.nominal = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.nominal);
                    break;
                case /* string nominal_currency */ 2:
                    message.nominalCurrency = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AssetClearingCertificate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.Quotation nominal = 1; */
        if (message.nominal)
            Quotation.internalBinaryWrite(message.nominal, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string nominal_currency = 2; */
        if (message.nominalCurrency !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nominalCurrency);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.AssetClearingCertificate
 */
export const AssetClearingCertificate = new AssetClearingCertificate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Brand$Type extends MessageType<Brand> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.Brand", [
            { no: 1, name: "uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "company", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "sector", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "country_of_risk", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "country_of_risk_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Brand>): Brand {
        const message = { uid: "", name: "", description: "", info: "", company: "", sector: "", countryOfRisk: "", countryOfRiskName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Brand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Brand): Brand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uid */ 1:
                    message.uid = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* string info */ 4:
                    message.info = reader.string();
                    break;
                case /* string company */ 5:
                    message.company = reader.string();
                    break;
                case /* string sector */ 6:
                    message.sector = reader.string();
                    break;
                case /* string country_of_risk */ 7:
                    message.countryOfRisk = reader.string();
                    break;
                case /* string country_of_risk_name */ 8:
                    message.countryOfRiskName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Brand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uid = 1; */
        if (message.uid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uid);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* string info = 4; */
        if (message.info !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.info);
        /* string company = 5; */
        if (message.company !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.company);
        /* string sector = 6; */
        if (message.sector !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.sector);
        /* string country_of_risk = 7; */
        if (message.countryOfRisk !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.countryOfRisk);
        /* string country_of_risk_name = 8; */
        if (message.countryOfRiskName !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.countryOfRiskName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.Brand
 */
export const Brand = new Brand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AssetInstrument$Type extends MessageType<AssetInstrument> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.AssetInstrument", [
            { no: 1, name: "uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "instrument_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "class_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "links", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => InstrumentLink },
            { no: 10, name: "instrument_kind", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.InstrumentType", InstrumentType, "INSTRUMENT_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<AssetInstrument>): AssetInstrument {
        const message = { uid: "", figi: "", instrumentType: "", ticker: "", classCode: "", links: [], instrumentKind: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AssetInstrument>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AssetInstrument): AssetInstrument {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uid */ 1:
                    message.uid = reader.string();
                    break;
                case /* string figi */ 2:
                    message.figi = reader.string();
                    break;
                case /* string instrument_type */ 3:
                    message.instrumentType = reader.string();
                    break;
                case /* string ticker */ 4:
                    message.ticker = reader.string();
                    break;
                case /* string class_code */ 5:
                    message.classCode = reader.string();
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.InstrumentLink links */ 6:
                    message.links.push(InstrumentLink.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* tinkoff.public.invest.api.contract.v1.InstrumentType instrument_kind */ 10:
                    message.instrumentKind = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AssetInstrument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uid = 1; */
        if (message.uid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uid);
        /* string figi = 2; */
        if (message.figi !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.figi);
        /* string instrument_type = 3; */
        if (message.instrumentType !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.instrumentType);
        /* string ticker = 4; */
        if (message.ticker !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.ticker);
        /* string class_code = 5; */
        if (message.classCode !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.classCode);
        /* repeated tinkoff.public.invest.api.contract.v1.InstrumentLink links = 6; */
        for (let i = 0; i < message.links.length; i++)
            InstrumentLink.internalBinaryWrite(message.links[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.InstrumentType instrument_kind = 10; */
        if (message.instrumentKind !== 0)
            writer.tag(10, WireType.Varint).int32(message.instrumentKind);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.AssetInstrument
 */
export const AssetInstrument = new AssetInstrument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstrumentLink$Type extends MessageType<InstrumentLink> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.InstrumentLink", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "instrument_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<InstrumentLink>): InstrumentLink {
        const message = { type: "", instrumentUid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InstrumentLink>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstrumentLink): InstrumentLink {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string instrument_uid */ 2:
                    message.instrumentUid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InstrumentLink, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string instrument_uid = 2; */
        if (message.instrumentUid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.instrumentUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.InstrumentLink
 */
export const InstrumentLink = new InstrumentLink$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFavoritesRequest$Type extends MessageType<GetFavoritesRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetFavoritesRequest", []);
    }
    create(value?: PartialMessage<GetFavoritesRequest>): GetFavoritesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetFavoritesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFavoritesRequest): GetFavoritesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetFavoritesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetFavoritesRequest
 */
export const GetFavoritesRequest = new GetFavoritesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFavoritesResponse$Type extends MessageType<GetFavoritesResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetFavoritesResponse", [
            { no: 1, name: "favorite_instruments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FavoriteInstrument }
        ]);
    }
    create(value?: PartialMessage<GetFavoritesResponse>): GetFavoritesResponse {
        const message = { favoriteInstruments: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetFavoritesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFavoritesResponse): GetFavoritesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.FavoriteInstrument favorite_instruments */ 1:
                    message.favoriteInstruments.push(FavoriteInstrument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFavoritesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.FavoriteInstrument favorite_instruments = 1; */
        for (let i = 0; i < message.favoriteInstruments.length; i++)
            FavoriteInstrument.internalBinaryWrite(message.favoriteInstruments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetFavoritesResponse
 */
export const GetFavoritesResponse = new GetFavoritesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FavoriteInstrument$Type extends MessageType<FavoriteInstrument> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.FavoriteInstrument", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "class_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "isin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "instrument_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "otc_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "api_trade_available_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "instrument_kind", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.InstrumentType", InstrumentType, "INSTRUMENT_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<FavoriteInstrument>): FavoriteInstrument {
        const message = { figi: "", ticker: "", classCode: "", isin: "", instrumentType: "", otcFlag: false, apiTradeAvailableFlag: false, instrumentKind: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FavoriteInstrument>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FavoriteInstrument): FavoriteInstrument {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* string ticker */ 2:
                    message.ticker = reader.string();
                    break;
                case /* string class_code */ 3:
                    message.classCode = reader.string();
                    break;
                case /* string isin */ 4:
                    message.isin = reader.string();
                    break;
                case /* string instrument_type */ 11:
                    message.instrumentType = reader.string();
                    break;
                case /* bool otc_flag */ 16:
                    message.otcFlag = reader.bool();
                    break;
                case /* bool api_trade_available_flag */ 17:
                    message.apiTradeAvailableFlag = reader.bool();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.InstrumentType instrument_kind */ 18:
                    message.instrumentKind = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FavoriteInstrument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* string ticker = 2; */
        if (message.ticker !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ticker);
        /* string class_code = 3; */
        if (message.classCode !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.classCode);
        /* string isin = 4; */
        if (message.isin !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.isin);
        /* string instrument_type = 11; */
        if (message.instrumentType !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.instrumentType);
        /* bool otc_flag = 16; */
        if (message.otcFlag !== false)
            writer.tag(16, WireType.Varint).bool(message.otcFlag);
        /* bool api_trade_available_flag = 17; */
        if (message.apiTradeAvailableFlag !== false)
            writer.tag(17, WireType.Varint).bool(message.apiTradeAvailableFlag);
        /* tinkoff.public.invest.api.contract.v1.InstrumentType instrument_kind = 18; */
        if (message.instrumentKind !== 0)
            writer.tag(18, WireType.Varint).int32(message.instrumentKind);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.FavoriteInstrument
 */
export const FavoriteInstrument = new FavoriteInstrument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EditFavoritesRequest$Type extends MessageType<EditFavoritesRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.EditFavoritesRequest", [
            { no: 1, name: "instruments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EditFavoritesRequestInstrument },
            { no: 6, name: "action_type", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.EditFavoritesActionType", EditFavoritesActionType, "EDIT_FAVORITES_ACTION_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<EditFavoritesRequest>): EditFavoritesRequest {
        const message = { instruments: [], actionType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EditFavoritesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EditFavoritesRequest): EditFavoritesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.EditFavoritesRequestInstrument instruments */ 1:
                    message.instruments.push(EditFavoritesRequestInstrument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* tinkoff.public.invest.api.contract.v1.EditFavoritesActionType action_type */ 6:
                    message.actionType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EditFavoritesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.EditFavoritesRequestInstrument instruments = 1; */
        for (let i = 0; i < message.instruments.length; i++)
            EditFavoritesRequestInstrument.internalBinaryWrite(message.instruments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.EditFavoritesActionType action_type = 6; */
        if (message.actionType !== 0)
            writer.tag(6, WireType.Varint).int32(message.actionType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.EditFavoritesRequest
 */
export const EditFavoritesRequest = new EditFavoritesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EditFavoritesRequestInstrument$Type extends MessageType<EditFavoritesRequestInstrument> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.EditFavoritesRequestInstrument", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EditFavoritesRequestInstrument>): EditFavoritesRequestInstrument {
        const message = { figi: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EditFavoritesRequestInstrument>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EditFavoritesRequestInstrument): EditFavoritesRequestInstrument {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EditFavoritesRequestInstrument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.EditFavoritesRequestInstrument
 */
export const EditFavoritesRequestInstrument = new EditFavoritesRequestInstrument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EditFavoritesResponse$Type extends MessageType<EditFavoritesResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.EditFavoritesResponse", [
            { no: 1, name: "favorite_instruments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FavoriteInstrument }
        ]);
    }
    create(value?: PartialMessage<EditFavoritesResponse>): EditFavoritesResponse {
        const message = { favoriteInstruments: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EditFavoritesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EditFavoritesResponse): EditFavoritesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.FavoriteInstrument favorite_instruments */ 1:
                    message.favoriteInstruments.push(FavoriteInstrument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EditFavoritesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.FavoriteInstrument favorite_instruments = 1; */
        for (let i = 0; i < message.favoriteInstruments.length; i++)
            FavoriteInstrument.internalBinaryWrite(message.favoriteInstruments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.EditFavoritesResponse
 */
export const EditFavoritesResponse = new EditFavoritesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCountriesRequest$Type extends MessageType<GetCountriesRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetCountriesRequest", []);
    }
    create(value?: PartialMessage<GetCountriesRequest>): GetCountriesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetCountriesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCountriesRequest): GetCountriesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetCountriesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetCountriesRequest
 */
export const GetCountriesRequest = new GetCountriesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCountriesResponse$Type extends MessageType<GetCountriesResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetCountriesResponse", [
            { no: 1, name: "countries", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CountryResponse }
        ]);
    }
    create(value?: PartialMessage<GetCountriesResponse>): GetCountriesResponse {
        const message = { countries: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetCountriesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCountriesResponse): GetCountriesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.CountryResponse countries */ 1:
                    message.countries.push(CountryResponse.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCountriesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.CountryResponse countries = 1; */
        for (let i = 0; i < message.countries.length; i++)
            CountryResponse.internalBinaryWrite(message.countries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetCountriesResponse
 */
export const GetCountriesResponse = new GetCountriesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CountryResponse$Type extends MessageType<CountryResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.CountryResponse", [
            { no: 1, name: "alfa_two", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "alfa_three", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "name_brief", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CountryResponse>): CountryResponse {
        const message = { alfaTwo: "", alfaThree: "", name: "", nameBrief: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CountryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CountryResponse): CountryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string alfa_two */ 1:
                    message.alfaTwo = reader.string();
                    break;
                case /* string alfa_three */ 2:
                    message.alfaThree = reader.string();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string name_brief */ 4:
                    message.nameBrief = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CountryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string alfa_two = 1; */
        if (message.alfaTwo !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.alfaTwo);
        /* string alfa_three = 2; */
        if (message.alfaThree !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.alfaThree);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string name_brief = 4; */
        if (message.nameBrief !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.nameBrief);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.CountryResponse
 */
export const CountryResponse = new CountryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FindInstrumentRequest$Type extends MessageType<FindInstrumentRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.FindInstrumentRequest", [
            { no: 1, name: "query", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FindInstrumentRequest>): FindInstrumentRequest {
        const message = { query: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FindInstrumentRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FindInstrumentRequest): FindInstrumentRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string query */ 1:
                    message.query = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FindInstrumentRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string query = 1; */
        if (message.query !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.query);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.FindInstrumentRequest
 */
export const FindInstrumentRequest = new FindInstrumentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FindInstrumentResponse$Type extends MessageType<FindInstrumentResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.FindInstrumentResponse", [
            { no: 1, name: "instruments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => InstrumentShort }
        ]);
    }
    create(value?: PartialMessage<FindInstrumentResponse>): FindInstrumentResponse {
        const message = { instruments: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FindInstrumentResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FindInstrumentResponse): FindInstrumentResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.InstrumentShort instruments */ 1:
                    message.instruments.push(InstrumentShort.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FindInstrumentResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.InstrumentShort instruments = 1; */
        for (let i = 0; i < message.instruments.length; i++)
            InstrumentShort.internalBinaryWrite(message.instruments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.FindInstrumentResponse
 */
export const FindInstrumentResponse = new FindInstrumentResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstrumentShort$Type extends MessageType<InstrumentShort> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.InstrumentShort", [
            { no: 1, name: "isin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "class_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "instrument_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "position_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "instrument_kind", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.InstrumentType", InstrumentType, "INSTRUMENT_TYPE_"] },
            { no: 11, name: "api_trade_available_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "for_iis_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 26, name: "first_1min_candle_date", kind: "message", jsonName: "first1minCandleDate", T: () => Timestamp },
            { no: 27, name: "first_1day_candle_date", kind: "message", jsonName: "first1dayCandleDate", T: () => Timestamp },
            { no: 28, name: "for_qual_investor_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 29, name: "weekend_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 30, name: "blocked_tca_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<InstrumentShort>): InstrumentShort {
        const message = { isin: "", figi: "", ticker: "", classCode: "", instrumentType: "", name: "", uid: "", positionUid: "", instrumentKind: 0, apiTradeAvailableFlag: false, forIisFlag: false, forQualInvestorFlag: false, weekendFlag: false, blockedTcaFlag: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InstrumentShort>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstrumentShort): InstrumentShort {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string isin */ 1:
                    message.isin = reader.string();
                    break;
                case /* string figi */ 2:
                    message.figi = reader.string();
                    break;
                case /* string ticker */ 3:
                    message.ticker = reader.string();
                    break;
                case /* string class_code */ 4:
                    message.classCode = reader.string();
                    break;
                case /* string instrument_type */ 5:
                    message.instrumentType = reader.string();
                    break;
                case /* string name */ 6:
                    message.name = reader.string();
                    break;
                case /* string uid */ 7:
                    message.uid = reader.string();
                    break;
                case /* string position_uid */ 8:
                    message.positionUid = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.InstrumentType instrument_kind */ 10:
                    message.instrumentKind = reader.int32();
                    break;
                case /* bool api_trade_available_flag */ 11:
                    message.apiTradeAvailableFlag = reader.bool();
                    break;
                case /* bool for_iis_flag */ 12:
                    message.forIisFlag = reader.bool();
                    break;
                case /* google.protobuf.Timestamp first_1min_candle_date = 26 [json_name = "first1minCandleDate"];*/ 26:
                    message.first1MinCandleDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.first1MinCandleDate);
                    break;
                case /* google.protobuf.Timestamp first_1day_candle_date = 27 [json_name = "first1dayCandleDate"];*/ 27:
                    message.first1DayCandleDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.first1DayCandleDate);
                    break;
                case /* bool for_qual_investor_flag */ 28:
                    message.forQualInvestorFlag = reader.bool();
                    break;
                case /* bool weekend_flag */ 29:
                    message.weekendFlag = reader.bool();
                    break;
                case /* bool blocked_tca_flag */ 30:
                    message.blockedTcaFlag = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InstrumentShort, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string isin = 1; */
        if (message.isin !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.isin);
        /* string figi = 2; */
        if (message.figi !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.figi);
        /* string ticker = 3; */
        if (message.ticker !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.ticker);
        /* string class_code = 4; */
        if (message.classCode !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.classCode);
        /* string instrument_type = 5; */
        if (message.instrumentType !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.instrumentType);
        /* string name = 6; */
        if (message.name !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.name);
        /* string uid = 7; */
        if (message.uid !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.uid);
        /* string position_uid = 8; */
        if (message.positionUid !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.positionUid);
        /* tinkoff.public.invest.api.contract.v1.InstrumentType instrument_kind = 10; */
        if (message.instrumentKind !== 0)
            writer.tag(10, WireType.Varint).int32(message.instrumentKind);
        /* bool api_trade_available_flag = 11; */
        if (message.apiTradeAvailableFlag !== false)
            writer.tag(11, WireType.Varint).bool(message.apiTradeAvailableFlag);
        /* bool for_iis_flag = 12; */
        if (message.forIisFlag !== false)
            writer.tag(12, WireType.Varint).bool(message.forIisFlag);
        /* google.protobuf.Timestamp first_1min_candle_date = 26 [json_name = "first1minCandleDate"]; */
        if (message.first1MinCandleDate)
            Timestamp.internalBinaryWrite(message.first1MinCandleDate, writer.tag(26, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp first_1day_candle_date = 27 [json_name = "first1dayCandleDate"]; */
        if (message.first1DayCandleDate)
            Timestamp.internalBinaryWrite(message.first1DayCandleDate, writer.tag(27, WireType.LengthDelimited).fork(), options).join();
        /* bool for_qual_investor_flag = 28; */
        if (message.forQualInvestorFlag !== false)
            writer.tag(28, WireType.Varint).bool(message.forQualInvestorFlag);
        /* bool weekend_flag = 29; */
        if (message.weekendFlag !== false)
            writer.tag(29, WireType.Varint).bool(message.weekendFlag);
        /* bool blocked_tca_flag = 30; */
        if (message.blockedTcaFlag !== false)
            writer.tag(30, WireType.Varint).bool(message.blockedTcaFlag);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.InstrumentShort
 */
export const InstrumentShort = new InstrumentShort$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBrandsRequest$Type extends MessageType<GetBrandsRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetBrandsRequest", []);
    }
    create(value?: PartialMessage<GetBrandsRequest>): GetBrandsRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetBrandsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBrandsRequest): GetBrandsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetBrandsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetBrandsRequest
 */
export const GetBrandsRequest = new GetBrandsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBrandRequest$Type extends MessageType<GetBrandRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetBrandRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetBrandRequest>): GetBrandRequest {
        const message = { id: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetBrandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBrandRequest): GetBrandRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBrandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetBrandRequest
 */
export const GetBrandRequest = new GetBrandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBrandsResponse$Type extends MessageType<GetBrandsResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetBrandsResponse", [
            { no: 1, name: "brands", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Brand }
        ]);
    }
    create(value?: PartialMessage<GetBrandsResponse>): GetBrandsResponse {
        const message = { brands: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetBrandsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBrandsResponse): GetBrandsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.Brand brands */ 1:
                    message.brands.push(Brand.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBrandsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.Brand brands = 1; */
        for (let i = 0; i < message.brands.length; i++)
            Brand.internalBinaryWrite(message.brands[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetBrandsResponse
 */
export const GetBrandsResponse = new GetBrandsResponse$Type();
/**
 * @generated ServiceType for protobuf service tinkoff.public.invest.api.contract.v1.InstrumentsService
 */
export const InstrumentsService = new ServiceType("tinkoff.public.invest.api.contract.v1.InstrumentsService", [
    { name: "TradingSchedules", options: {}, I: TradingSchedulesRequest, O: TradingSchedulesResponse },
    { name: "BondBy", options: {}, I: InstrumentRequest, O: BondResponse },
    { name: "Bonds", options: {}, I: InstrumentsRequest, O: BondsResponse },
    { name: "GetBondCoupons", options: {}, I: GetBondCouponsRequest, O: GetBondCouponsResponse },
    { name: "CurrencyBy", options: {}, I: InstrumentRequest, O: CurrencyResponse },
    { name: "Currencies", options: {}, I: InstrumentsRequest, O: CurrenciesResponse },
    { name: "EtfBy", options: {}, I: InstrumentRequest, O: EtfResponse },
    { name: "Etfs", options: {}, I: InstrumentsRequest, O: EtfsResponse },
    { name: "FutureBy", options: {}, I: InstrumentRequest, O: FutureResponse },
    { name: "Futures", options: {}, I: InstrumentsRequest, O: FuturesResponse },
    { name: "OptionBy", options: {}, I: InstrumentRequest, O: OptionResponse },
    { name: "Options", localName: "options$", options: {}, I: InstrumentsRequest, O: OptionsResponse },
    { name: "ShareBy", options: {}, I: InstrumentRequest, O: ShareResponse },
    { name: "Shares", options: {}, I: InstrumentsRequest, O: SharesResponse },
    { name: "GetAccruedInterests", options: {}, I: GetAccruedInterestsRequest, O: GetAccruedInterestsResponse },
    { name: "GetFuturesMargin", options: {}, I: GetFuturesMarginRequest, O: GetFuturesMarginResponse },
    { name: "GetInstrumentBy", options: {}, I: InstrumentRequest, O: InstrumentResponse },
    { name: "GetDividends", options: {}, I: GetDividendsRequest, O: GetDividendsResponse },
    { name: "GetAssetBy", options: {}, I: AssetRequest, O: AssetResponse },
    { name: "GetAssets", options: {}, I: AssetsRequest, O: AssetsResponse },
    { name: "GetFavorites", options: {}, I: GetFavoritesRequest, O: GetFavoritesResponse },
    { name: "EditFavorites", options: {}, I: EditFavoritesRequest, O: EditFavoritesResponse },
    { name: "GetCountries", options: {}, I: GetCountriesRequest, O: GetCountriesResponse },
    { name: "FindInstrument", options: {}, I: FindInstrumentRequest, O: FindInstrumentResponse },
    { name: "GetBrands", options: {}, I: GetBrandsRequest, O: GetBrandsResponse },
    { name: "GetBrandBy", options: {}, I: GetBrandRequest, O: Brand }
]);
