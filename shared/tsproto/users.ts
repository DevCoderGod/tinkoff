// @generated by protobuf-ts 2.8.2
// @generated from protobuf file "users.proto" (package "tinkoff.public.invest.api.contract.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Quotation } from "./common";
import { MoneyValue } from "./common";
import { Timestamp } from "./google/protobuf/timestamp";
/**
 * Запрос получения счетов пользователя.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetAccountsRequest
 */
export interface GetAccountsRequest {
}
/**
 * Список счетов пользователя.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetAccountsResponse
 */
export interface GetAccountsResponse {
    /**
     * Массив счетов клиента.
     *
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.Account accounts = 1;
     */
    accounts: Account[];
}
/**
 * Информация о счёте.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.Account
 */
export interface Account {
    /**
     * Идентификатор счёта.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * Тип счёта.
     *
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.AccountType type = 2;
     */
    type: AccountType;
    /**
     * Название счёта.
     *
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * Статус счёта.
     *
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.AccountStatus status = 4;
     */
    status: AccountStatus;
    /**
     * Дата открытия счёта в часовом поясе UTC.
     *
     * @generated from protobuf field: google.protobuf.Timestamp opened_date = 5;
     */
    openedDate?: Timestamp;
    /**
     * Дата закрытия счёта в часовом поясе UTC.
     *
     * @generated from protobuf field: google.protobuf.Timestamp closed_date = 6;
     */
    closedDate?: Timestamp;
    /**
     * Уровень доступа к текущему счёту (определяется токеном).
     *
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.AccessLevel access_level = 7;
     */
    accessLevel: AccessLevel;
}
/**
 * Запрос маржинальных показателей по счёту
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetMarginAttributesRequest
 */
export interface GetMarginAttributesRequest {
    /**
     * Идентификатор счёта пользователя.
     *
     * @generated from protobuf field: string account_id = 1;
     */
    accountId: string;
}
/**
 * Маржинальные показатели по счёту.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetMarginAttributesResponse
 */
export interface GetMarginAttributesResponse {
    /**
     * Ликвидная стоимость портфеля. Подробнее: [что такое ликвидный портфель?](https://help.tinkoff.ru/margin-trade/short/liquid-portfolio/).
     *
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue liquid_portfolio = 1;
     */
    liquidPortfolio?: MoneyValue;
    /**
     * Начальная маржа — начальное обеспечение для совершения новой сделки. Подробнее: [начальная и минимальная маржа](https://help.tinkoff.ru/margin-trade/short/initial-and-maintenance-margin/).
     *
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue starting_margin = 2;
     */
    startingMargin?: MoneyValue;
    /**
     * Минимальная маржа — это минимальное обеспечение для поддержания позиции, которую вы уже открыли. Подробнее: [начальная и минимальная маржа](https://help.tinkoff.ru/margin-trade/short/initial-and-maintenance-margin/).
     *
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue minimal_margin = 3;
     */
    minimalMargin?: MoneyValue;
    /**
     * Уровень достаточности средств. Соотношение стоимости ликвидного портфеля к начальной марже.
     *
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation funds_sufficiency_level = 4;
     */
    fundsSufficiencyLevel?: Quotation;
    /**
     * Объем недостающих средств. Разница между стартовой маржой и ликвидной стоимости портфеля.
     *
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue amount_of_missing_funds = 5;
     */
    amountOfMissingFunds?: MoneyValue;
    /**
     * Скорректированная маржа.Начальная маржа, в которой плановые позиции рассчитываются с учётом активных заявок на покупку позиций лонг или продажу позиций шорт.
     *
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue corrected_margin = 6;
     */
    correctedMargin?: MoneyValue;
}
/**
 * Запрос текущих лимитов пользователя.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetUserTariffRequest
 */
export interface GetUserTariffRequest {
}
/**
 * Текущие лимиты пользователя.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetUserTariffResponse
 */
export interface GetUserTariffResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.UnaryLimit unary_limits = 1;
     */
    unaryLimits: UnaryLimit[]; // Массив лимитов пользователя по unary-запросам
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.StreamLimit stream_limits = 2;
     */
    streamLimits: StreamLimit[]; // Массив лимитов пользователей для stream-соединений
}
/**
 * Лимит unary-методов.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.UnaryLimit
 */
export interface UnaryLimit {
    /**
     * @generated from protobuf field: int32 limit_per_minute = 1;
     */
    limitPerMinute: number; // Количество unary-запросов в минуту
    /**
     * @generated from protobuf field: repeated string methods = 2;
     */
    methods: string[]; // Названия методов
}
/**
 * Лимит stream-соединений.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.StreamLimit
 */
export interface StreamLimit {
    /**
     * @generated from protobuf field: int32 limit = 1;
     */
    limit: number; // Максимальное количество stream-соединений
    /**
     * @generated from protobuf field: repeated string streams = 2;
     */
    streams: string[]; // Названия stream-методов
}
/**
 * Запрос информации о пользователе.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetInfoRequest
 */
export interface GetInfoRequest {
}
/**
 * Информация о пользователе.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetInfoResponse
 */
export interface GetInfoResponse {
    /**
     * @generated from protobuf field: bool prem_status = 1;
     */
    premStatus: boolean; // Признак премиум клиента.
    /**
     * @generated from protobuf field: bool qual_status = 2;
     */
    qualStatus: boolean; // Признак квалифицированного инвестора.
    /**
     * @generated from protobuf field: repeated string qualified_for_work_with = 3;
     */
    qualifiedForWorkWith: string[]; // Набор требующих тестирования инструментов и возможностей, с которыми может работать пользователь. [Подробнее](https://tinkoff.github.io/investAPI/faq_users/).
    /**
     * @generated from protobuf field: string tariff = 4;
     */
    tariff: string; // Наименование тарифа пользователя.
}
/**
 * Тип счёта.
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.AccountType
 */
export enum AccountType {
    /**
     * Тип аккаунта не определён.
     *
     * @generated from protobuf enum value: ACCOUNT_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Брокерский счёт Тинькофф.
     *
     * @generated from protobuf enum value: ACCOUNT_TYPE_TINKOFF = 1;
     */
    TINKOFF = 1,
    /**
     * ИИС счёт.
     *
     * @generated from protobuf enum value: ACCOUNT_TYPE_TINKOFF_IIS = 2;
     */
    TINKOFF_IIS = 2,
    /**
     * Инвесткопилка.
     *
     * @generated from protobuf enum value: ACCOUNT_TYPE_INVEST_BOX = 3;
     */
    INVEST_BOX = 3
}
/**
 * Статус счёта.
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.AccountStatus
 */
export enum AccountStatus {
    /**
     * Статус счёта не определён.
     *
     * @generated from protobuf enum value: ACCOUNT_STATUS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Новый, в процессе открытия.
     *
     * @generated from protobuf enum value: ACCOUNT_STATUS_NEW = 1;
     */
    NEW = 1,
    /**
     * Открытый и активный счёт.
     *
     * @generated from protobuf enum value: ACCOUNT_STATUS_OPEN = 2;
     */
    OPEN = 2,
    /**
     * Закрытый счёт.
     *
     * @generated from protobuf enum value: ACCOUNT_STATUS_CLOSED = 3;
     */
    CLOSED = 3
}
/**
 * Уровень доступа к счёту.
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.AccessLevel
 */
export enum AccessLevel {
    /**
     * Уровень доступа не определён.
     *
     * @generated from protobuf enum value: ACCOUNT_ACCESS_LEVEL_UNSPECIFIED = 0;
     */
    ACCOUNT_ACCESS_LEVEL_UNSPECIFIED = 0,
    /**
     * Полный доступ к счёту.
     *
     * @generated from protobuf enum value: ACCOUNT_ACCESS_LEVEL_FULL_ACCESS = 1;
     */
    ACCOUNT_ACCESS_LEVEL_FULL_ACCESS = 1,
    /**
     * Доступ с уровнем прав "только чтение".
     *
     * @generated from protobuf enum value: ACCOUNT_ACCESS_LEVEL_READ_ONLY = 2;
     */
    ACCOUNT_ACCESS_LEVEL_READ_ONLY = 2,
    /**
     * Доступ отсутствует.
     *
     * @generated from protobuf enum value: ACCOUNT_ACCESS_LEVEL_NO_ACCESS = 3;
     */
    ACCOUNT_ACCESS_LEVEL_NO_ACCESS = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class GetAccountsRequest$Type extends MessageType<GetAccountsRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetAccountsRequest", []);
    }
    create(value?: PartialMessage<GetAccountsRequest>): GetAccountsRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetAccountsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAccountsRequest): GetAccountsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetAccountsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetAccountsRequest
 */
export const GetAccountsRequest = new GetAccountsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAccountsResponse$Type extends MessageType<GetAccountsResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetAccountsResponse", [
            { no: 1, name: "accounts", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Account }
        ]);
    }
    create(value?: PartialMessage<GetAccountsResponse>): GetAccountsResponse {
        const message = { accounts: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetAccountsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAccountsResponse): GetAccountsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.Account accounts */ 1:
                    message.accounts.push(Account.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAccountsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.Account accounts = 1; */
        for (let i = 0; i < message.accounts.length; i++)
            Account.internalBinaryWrite(message.accounts[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetAccountsResponse
 */
export const GetAccountsResponse = new GetAccountsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Account$Type extends MessageType<Account> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.Account", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.AccountType", AccountType, "ACCOUNT_TYPE_"] },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "status", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.AccountStatus", AccountStatus, "ACCOUNT_STATUS_"] },
            { no: 5, name: "opened_date", kind: "message", T: () => Timestamp },
            { no: 6, name: "closed_date", kind: "message", T: () => Timestamp },
            { no: 7, name: "access_level", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.AccessLevel", AccessLevel] }
        ]);
    }
    create(value?: PartialMessage<Account>): Account {
        const message = { id: "", type: 0, name: "", status: 0, accessLevel: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Account>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Account): Account {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.AccountType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.AccountStatus status */ 4:
                    message.status = reader.int32();
                    break;
                case /* google.protobuf.Timestamp opened_date */ 5:
                    message.openedDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.openedDate);
                    break;
                case /* google.protobuf.Timestamp closed_date */ 6:
                    message.closedDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.closedDate);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.AccessLevel access_level */ 7:
                    message.accessLevel = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Account, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* tinkoff.public.invest.api.contract.v1.AccountType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* tinkoff.public.invest.api.contract.v1.AccountStatus status = 4; */
        if (message.status !== 0)
            writer.tag(4, WireType.Varint).int32(message.status);
        /* google.protobuf.Timestamp opened_date = 5; */
        if (message.openedDate)
            Timestamp.internalBinaryWrite(message.openedDate, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp closed_date = 6; */
        if (message.closedDate)
            Timestamp.internalBinaryWrite(message.closedDate, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.AccessLevel access_level = 7; */
        if (message.accessLevel !== 0)
            writer.tag(7, WireType.Varint).int32(message.accessLevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.Account
 */
export const Account = new Account$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMarginAttributesRequest$Type extends MessageType<GetMarginAttributesRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetMarginAttributesRequest", [
            { no: 1, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetMarginAttributesRequest>): GetMarginAttributesRequest {
        const message = { accountId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMarginAttributesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMarginAttributesRequest): GetMarginAttributesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_id */ 1:
                    message.accountId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMarginAttributesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_id = 1; */
        if (message.accountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetMarginAttributesRequest
 */
export const GetMarginAttributesRequest = new GetMarginAttributesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMarginAttributesResponse$Type extends MessageType<GetMarginAttributesResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetMarginAttributesResponse", [
            { no: 1, name: "liquid_portfolio", kind: "message", T: () => MoneyValue },
            { no: 2, name: "starting_margin", kind: "message", T: () => MoneyValue },
            { no: 3, name: "minimal_margin", kind: "message", T: () => MoneyValue },
            { no: 4, name: "funds_sufficiency_level", kind: "message", T: () => Quotation },
            { no: 5, name: "amount_of_missing_funds", kind: "message", T: () => MoneyValue },
            { no: 6, name: "corrected_margin", kind: "message", T: () => MoneyValue }
        ]);
    }
    create(value?: PartialMessage<GetMarginAttributesResponse>): GetMarginAttributesResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMarginAttributesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMarginAttributesResponse): GetMarginAttributesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue liquid_portfolio */ 1:
                    message.liquidPortfolio = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.liquidPortfolio);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue starting_margin */ 2:
                    message.startingMargin = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.startingMargin);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue minimal_margin */ 3:
                    message.minimalMargin = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.minimalMargin);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation funds_sufficiency_level */ 4:
                    message.fundsSufficiencyLevel = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.fundsSufficiencyLevel);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue amount_of_missing_funds */ 5:
                    message.amountOfMissingFunds = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.amountOfMissingFunds);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue corrected_margin */ 6:
                    message.correctedMargin = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.correctedMargin);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMarginAttributesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.MoneyValue liquid_portfolio = 1; */
        if (message.liquidPortfolio)
            MoneyValue.internalBinaryWrite(message.liquidPortfolio, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue starting_margin = 2; */
        if (message.startingMargin)
            MoneyValue.internalBinaryWrite(message.startingMargin, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue minimal_margin = 3; */
        if (message.minimalMargin)
            MoneyValue.internalBinaryWrite(message.minimalMargin, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation funds_sufficiency_level = 4; */
        if (message.fundsSufficiencyLevel)
            Quotation.internalBinaryWrite(message.fundsSufficiencyLevel, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue amount_of_missing_funds = 5; */
        if (message.amountOfMissingFunds)
            MoneyValue.internalBinaryWrite(message.amountOfMissingFunds, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue corrected_margin = 6; */
        if (message.correctedMargin)
            MoneyValue.internalBinaryWrite(message.correctedMargin, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetMarginAttributesResponse
 */
export const GetMarginAttributesResponse = new GetMarginAttributesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUserTariffRequest$Type extends MessageType<GetUserTariffRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetUserTariffRequest", []);
    }
    create(value?: PartialMessage<GetUserTariffRequest>): GetUserTariffRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetUserTariffRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUserTariffRequest): GetUserTariffRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetUserTariffRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetUserTariffRequest
 */
export const GetUserTariffRequest = new GetUserTariffRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUserTariffResponse$Type extends MessageType<GetUserTariffResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetUserTariffResponse", [
            { no: 1, name: "unary_limits", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UnaryLimit },
            { no: 2, name: "stream_limits", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => StreamLimit }
        ]);
    }
    create(value?: PartialMessage<GetUserTariffResponse>): GetUserTariffResponse {
        const message = { unaryLimits: [], streamLimits: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetUserTariffResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUserTariffResponse): GetUserTariffResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.UnaryLimit unary_limits */ 1:
                    message.unaryLimits.push(UnaryLimit.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.StreamLimit stream_limits */ 2:
                    message.streamLimits.push(StreamLimit.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUserTariffResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.UnaryLimit unary_limits = 1; */
        for (let i = 0; i < message.unaryLimits.length; i++)
            UnaryLimit.internalBinaryWrite(message.unaryLimits[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated tinkoff.public.invest.api.contract.v1.StreamLimit stream_limits = 2; */
        for (let i = 0; i < message.streamLimits.length; i++)
            StreamLimit.internalBinaryWrite(message.streamLimits[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetUserTariffResponse
 */
export const GetUserTariffResponse = new GetUserTariffResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnaryLimit$Type extends MessageType<UnaryLimit> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.UnaryLimit", [
            { no: 1, name: "limit_per_minute", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "methods", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UnaryLimit>): UnaryLimit {
        const message = { limitPerMinute: 0, methods: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UnaryLimit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnaryLimit): UnaryLimit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 limit_per_minute */ 1:
                    message.limitPerMinute = reader.int32();
                    break;
                case /* repeated string methods */ 2:
                    message.methods.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnaryLimit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 limit_per_minute = 1; */
        if (message.limitPerMinute !== 0)
            writer.tag(1, WireType.Varint).int32(message.limitPerMinute);
        /* repeated string methods = 2; */
        for (let i = 0; i < message.methods.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.methods[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.UnaryLimit
 */
export const UnaryLimit = new UnaryLimit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamLimit$Type extends MessageType<StreamLimit> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.StreamLimit", [
            { no: 1, name: "limit", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "streams", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamLimit>): StreamLimit {
        const message = { limit: 0, streams: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StreamLimit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamLimit): StreamLimit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 limit */ 1:
                    message.limit = reader.int32();
                    break;
                case /* repeated string streams */ 2:
                    message.streams.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamLimit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 limit = 1; */
        if (message.limit !== 0)
            writer.tag(1, WireType.Varint).int32(message.limit);
        /* repeated string streams = 2; */
        for (let i = 0; i < message.streams.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.streams[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.StreamLimit
 */
export const StreamLimit = new StreamLimit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetInfoRequest$Type extends MessageType<GetInfoRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetInfoRequest", []);
    }
    create(value?: PartialMessage<GetInfoRequest>): GetInfoRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetInfoRequest): GetInfoRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetInfoRequest
 */
export const GetInfoRequest = new GetInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetInfoResponse$Type extends MessageType<GetInfoResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetInfoResponse", [
            { no: 1, name: "prem_status", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "qual_status", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "qualified_for_work_with", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "tariff", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetInfoResponse>): GetInfoResponse {
        const message = { premStatus: false, qualStatus: false, qualifiedForWorkWith: [], tariff: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetInfoResponse): GetInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool prem_status */ 1:
                    message.premStatus = reader.bool();
                    break;
                case /* bool qual_status */ 2:
                    message.qualStatus = reader.bool();
                    break;
                case /* repeated string qualified_for_work_with */ 3:
                    message.qualifiedForWorkWith.push(reader.string());
                    break;
                case /* string tariff */ 4:
                    message.tariff = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool prem_status = 1; */
        if (message.premStatus !== false)
            writer.tag(1, WireType.Varint).bool(message.premStatus);
        /* bool qual_status = 2; */
        if (message.qualStatus !== false)
            writer.tag(2, WireType.Varint).bool(message.qualStatus);
        /* repeated string qualified_for_work_with = 3; */
        for (let i = 0; i < message.qualifiedForWorkWith.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.qualifiedForWorkWith[i]);
        /* string tariff = 4; */
        if (message.tariff !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.tariff);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetInfoResponse
 */
export const GetInfoResponse = new GetInfoResponse$Type();
/**
 * @generated ServiceType for protobuf service tinkoff.public.invest.api.contract.v1.UsersService
 */
export const UsersService = new ServiceType("tinkoff.public.invest.api.contract.v1.UsersService", [
    { name: "GetAccounts", options: {}, I: GetAccountsRequest, O: GetAccountsResponse },
    { name: "GetMarginAttributes", options: {}, I: GetMarginAttributesRequest, O: GetMarginAttributesResponse },
    { name: "GetUserTariff", options: {}, I: GetUserTariffRequest, O: GetUserTariffResponse },
    { name: "GetInfo", options: {}, I: GetInfoRequest, O: GetInfoResponse }
]);
