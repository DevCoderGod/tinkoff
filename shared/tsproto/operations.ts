// @generated by protobuf-ts 2.8.2
// @generated from protobuf file "operations.proto" (package "tinkoff.public.invest.api.contract.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Ping } from "./common";
import { Quotation } from "./common";
import { MoneyValue } from "./common";
import { Timestamp } from "./google/protobuf/timestamp";
/**
 * Запрос получения списка операций по счёту.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.OperationsRequest
 */
export interface OperationsRequest {
    /**
     * @generated from protobuf field: string account_id = 1;
     */
    accountId: string; // Идентификатор счёта клиента.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp from = 2;
     */
    from?: Timestamp; // Начало периода (по UTC).
    /**
     * @generated from protobuf field: google.protobuf.Timestamp to = 3;
     */
    to?: Timestamp; // Окончание периода (по UTC).
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.OperationState state = 4;
     */
    state: OperationState; // Статус запрашиваемых операций.
    /**
     * @generated from protobuf field: string figi = 5;
     */
    figi: string; // Figi-идентификатор инструмента для фильтрации.
}
/**
 * Список операций.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.OperationsResponse
 */
export interface OperationsResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.Operation operations = 1;
     */
    operations: Operation[]; // Массив операций.
}
/**
 * Данные по операции.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.Operation
 */
export interface Operation {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string; // Идентификатор операции.
    /**
     * @generated from protobuf field: string parent_operation_id = 2;
     */
    parentOperationId: string; // Идентификатор родительской операции.
    /**
     * @generated from protobuf field: string currency = 3;
     */
    currency: string; // Валюта операции.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue payment = 4;
     */
    payment?: MoneyValue; // Сумма операции.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue price = 5;
     */
    price?: MoneyValue; // Цена операции за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.OperationState state = 6;
     */
    state: OperationState; // Статус операции.
    /**
     * @generated from protobuf field: int64 quantity = 7;
     */
    quantity: bigint; // Количество единиц инструмента.
    /**
     * @generated from protobuf field: int64 quantity_rest = 8;
     */
    quantityRest: bigint; // Неисполненный остаток по сделке.
    /**
     * @generated from protobuf field: string figi = 9;
     */
    figi: string; // Figi-идентификатор инструмента, связанного с операцией.
    /**
     * @generated from protobuf field: string instrument_type = 10;
     */
    instrumentType: string; // Тип инструмента. Возможные значения: </br>**bond** — облигация; </br>**share** — акция; </br>**currency** — валюта; </br>**etf** — фонд; </br>**futures** — фьючерс.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp date = 11;
     */
    date?: Timestamp; // Дата и время операции в формате часовом поясе UTC.
    /**
     * @generated from protobuf field: string type = 12;
     */
    type: string; // Текстовое описание типа операции.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.OperationType operation_type = 13;
     */
    operationType: OperationType; // Тип операции.
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.OperationTrade trades = 14;
     */
    trades: OperationTrade[]; // Массив сделок.
    /**
     * @generated from protobuf field: string asset_uid = 16;
     */
    assetUid: string; // Идентификатор актива
}
/**
 * Сделка по операции.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.OperationTrade
 */
export interface OperationTrade {
    /**
     * @generated from protobuf field: string trade_id = 1;
     */
    tradeId: string; // Идентификатор сделки.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp date_time = 2;
     */
    dateTime?: Timestamp; // Дата и время сделки в часовом поясе UTC.
    /**
     * @generated from protobuf field: int64 quantity = 3;
     */
    quantity: bigint; // Количество инструментов.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue price = 4;
     */
    price?: MoneyValue; // Цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента.
}
/**
 * Запрос получения текущего портфеля по счёту.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.PortfolioRequest
 */
export interface PortfolioRequest {
    /**
     * @generated from protobuf field: string account_id = 1;
     */
    accountId: string; // Идентификатор счёта пользователя.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.PortfolioRequest.CurrencyRequest currency = 2;
     */
    currency: PortfolioRequest_CurrencyRequest; // Валюта, в которой требуется рассчитать портфель
}
/**
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.PortfolioRequest.CurrencyRequest
 */
export enum PortfolioRequest_CurrencyRequest {
    /**
     * Рубли
     *
     * @generated from protobuf enum value: RUB = 0;
     */
    RUB = 0,
    /**
     * Доллары
     *
     * @generated from protobuf enum value: USD = 1;
     */
    USD = 1,
    /**
     * Евро
     *
     * @generated from protobuf enum value: EUR = 2;
     */
    EUR = 2
}
/**
 * Текущий портфель по счёту.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.PortfolioResponse
 */
export interface PortfolioResponse {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_shares = 1;
     */
    totalAmountShares?: MoneyValue; // Общая стоимость акций в портфеле.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_bonds = 2;
     */
    totalAmountBonds?: MoneyValue; // Общая стоимость облигаций в портфеле.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_etf = 3;
     */
    totalAmountEtf?: MoneyValue; // Общая стоимость фондов в портфеле.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_currencies = 4;
     */
    totalAmountCurrencies?: MoneyValue; // Общая стоимость валют в портфеле.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_futures = 5;
     */
    totalAmountFutures?: MoneyValue; // Общая стоимость фьючерсов в портфеле.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation expected_yield = 6;
     */
    expectedYield?: Quotation; // Текущая относительная доходность портфеля, в %.
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.PortfolioPosition positions = 7;
     */
    positions: PortfolioPosition[]; // Список позиций портфеля.
    /**
     * @generated from protobuf field: string account_id = 8;
     */
    accountId: string; // Идентификатор счёта пользователя.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_options = 9;
     */
    totalAmountOptions?: MoneyValue; // Общая стоимость опционов в портфеле.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_sp = 10;
     */
    totalAmountSp?: MoneyValue; // Общая стоимость структурных нот в портфеле.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_portfolio = 11;
     */
    totalAmountPortfolio?: MoneyValue; // Общая стоимость портфеля.
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.VirtualPortfolioPosition virtual_positions = 12;
     */
    virtualPositions: VirtualPortfolioPosition[]; // Массив виртуальных позиций портфеля.
}
/**
 * Запрос позиций портфеля по счёту.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.PositionsRequest
 */
export interface PositionsRequest {
    /**
     * @generated from protobuf field: string account_id = 1;
     */
    accountId: string; // Идентификатор счёта пользователя.
}
/**
 * Список позиций по счёту.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.PositionsResponse
 */
export interface PositionsResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.MoneyValue money = 1;
     */
    money: MoneyValue[]; // Массив валютных позиций портфеля.
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.MoneyValue blocked = 2;
     */
    blocked: MoneyValue[]; // Массив заблокированных валютных позиций портфеля.
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.PositionsSecurities securities = 3;
     */
    securities: PositionsSecurities[]; // Список ценно-бумажных позиций портфеля.
    /**
     * @generated from protobuf field: bool limits_loading_in_progress = 4;
     */
    limitsLoadingInProgress: boolean; // Признак идущей в данный момент выгрузки лимитов.
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.PositionsFutures futures = 5;
     */
    futures: PositionsFutures[]; // Список фьючерсов портфеля.
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.PositionsOptions options = 6;
     */
    options: PositionsOptions[]; // Список опционов портфеля.
}
/**
 * Запрос доступного для вывода остатка.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.WithdrawLimitsRequest
 */
export interface WithdrawLimitsRequest {
    /**
     * @generated from protobuf field: string account_id = 1;
     */
    accountId: string; // Идентификатор счёта пользователя.
}
/**
 * Доступный для вывода остаток.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.WithdrawLimitsResponse
 */
export interface WithdrawLimitsResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.MoneyValue money = 1;
     */
    money: MoneyValue[]; // Массив валютных позиций портфеля.
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.MoneyValue blocked = 2;
     */
    blocked: MoneyValue[]; // Массив заблокированных валютных позиций портфеля.
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.MoneyValue blocked_guarantee = 3;
     */
    blockedGuarantee: MoneyValue[]; // Заблокировано под гарантийное обеспечение фьючерсов.
}
/**
 * Позиции портфеля.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.PortfolioPosition
 */
export interface PortfolioPosition {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатора инструмента.
    /**
     * @generated from protobuf field: string instrument_type = 2;
     */
    instrumentType: string; // Тип инструмента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation quantity = 3;
     */
    quantity?: Quotation; // Количество инструмента в портфеле в штуках.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue average_position_price = 4;
     */
    averagePositionPrice?: MoneyValue; // Средневзвешенная цена позиции. **Возможна задержка до секунды для пересчёта**.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation expected_yield = 5;
     */
    expectedYield?: Quotation; // Текущая рассчитанная доходность позиции.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue current_nkd = 6;
     */
    currentNkd?: MoneyValue; // Текущий НКД.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation average_position_price_pt = 7;
     */
    averagePositionPricePt?: Quotation; // Deprecated Средняя цена позиции в пунктах (для фьючерсов). **Возможна задержка до секунды для пересчёта**.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue current_price = 8;
     */
    currentPrice?: MoneyValue; // Текущая цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue average_position_price_fifo = 9;
     */
    averagePositionPriceFifo?: MoneyValue; // Средняя цена позиции по методу FIFO. **Возможна задержка до секунды для пересчёта**.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation quantity_lots = 10;
     */
    quantityLots?: Quotation; // Deprecated Количество лотов в портфеле.
    /**
     * @generated from protobuf field: bool blocked = 21;
     */
    blocked: boolean; // Заблокировано на бирже.
    /**
     * @generated from protobuf field: string position_uid = 24;
     */
    positionUid: string; // position_uid-идентификатора инструмента
    /**
     * @generated from protobuf field: string instrument_uid = 25;
     */
    instrumentUid: string; // instrument_uid-идентификатора инструмента
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue var_margin = 26;
     */
    varMargin?: MoneyValue; // Вариационная маржа
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation expected_yield_fifo = 27;
     */
    expectedYieldFifo?: Quotation; // Текущая рассчитанная доходность позиции.
}
/**
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.VirtualPortfolioPosition
 */
export interface VirtualPortfolioPosition {
    /**
     * @generated from protobuf field: string position_uid = 1;
     */
    positionUid: string; // position_uid-идентификатора инструмента
    /**
     * @generated from protobuf field: string instrument_uid = 2;
     */
    instrumentUid: string; // instrument_uid-идентификатора инструмента
    /**
     * @generated from protobuf field: string figi = 3;
     */
    figi: string; // Figi-идентификатора инструмента.
    /**
     * @generated from protobuf field: string instrument_type = 4;
     */
    instrumentType: string; // Тип инструмента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation quantity = 5;
     */
    quantity?: Quotation; // Количество инструмента в портфеле в штуках.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue average_position_price = 6;
     */
    averagePositionPrice?: MoneyValue; // Средневзвешенная цена позиции. **Возможна задержка до секунды для пересчёта**.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation expected_yield = 7;
     */
    expectedYield?: Quotation; // Текущая рассчитанная доходность позиции.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation expected_yield_fifo = 8;
     */
    expectedYieldFifo?: Quotation; // Текущая рассчитанная доходность позиции.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp expire_date = 9;
     */
    expireDate?: Timestamp; // Дата до которой нужно продать виртуальные бумаги, после этой даты виртуальная позиция "сгорит"
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue current_price = 10;
     */
    currentPrice?: MoneyValue; // Текущая цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue average_position_price_fifo = 11;
     */
    averagePositionPriceFifo?: MoneyValue; // Средняя цена позиции по методу FIFO. **Возможна задержка до секунды для пересчёта**.
}
/**
 * Баланс позиции ценной бумаги.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.PositionsSecurities
 */
export interface PositionsSecurities {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор бумаги.
    /**
     * @generated from protobuf field: int64 blocked = 2;
     */
    blocked: bigint; // Количество бумаг заблокированных выставленными заявками.
    /**
     * @generated from protobuf field: int64 balance = 3;
     */
    balance: bigint; // Текущий незаблокированный баланс.
    /**
     * @generated from protobuf field: string position_uid = 4;
     */
    positionUid: string; // Уникальный идентификатор позиции.
    /**
     * @generated from protobuf field: string instrument_uid = 5;
     */
    instrumentUid: string; // Уникальный идентификатор  инструмента.
    /**
     * @generated from protobuf field: bool exchange_blocked = 11;
     */
    exchangeBlocked: boolean; // Заблокировано на бирже.
    /**
     * @generated from protobuf field: string instrument_type = 16;
     */
    instrumentType: string; // Тип инструмента.
}
/**
 * Баланс фьючерса.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.PositionsFutures
 */
export interface PositionsFutures {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор фьючерса.
    /**
     * @generated from protobuf field: int64 blocked = 2;
     */
    blocked: bigint; // Количество бумаг заблокированных выставленными заявками.
    /**
     * @generated from protobuf field: int64 balance = 3;
     */
    balance: bigint; // Текущий незаблокированный баланс.
    /**
     * @generated from protobuf field: string position_uid = 4;
     */
    positionUid: string; // Уникальный идентификатор позиции.
    /**
     * @generated from protobuf field: string instrument_uid = 5;
     */
    instrumentUid: string; // Уникальный идентификатор  инструмента.
}
/**
 * Баланс опциона.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.PositionsOptions
 */
export interface PositionsOptions {
    /**
     * @generated from protobuf field: string position_uid = 1;
     */
    positionUid: string; // Уникальный идентификатор позиции опциона.
    /**
     * @generated from protobuf field: string instrument_uid = 2;
     */
    instrumentUid: string; // Уникальный идентификатор  инструмента.
    /**
     * @generated from protobuf field: int64 blocked = 11;
     */
    blocked: bigint; // Количество бумаг заблокированных выставленными заявками.
    /**
     * @generated from protobuf field: int64 balance = 21;
     */
    balance: bigint; // Текущий незаблокированный баланс.
}
/**
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.BrokerReportRequest
 */
export interface BrokerReportRequest {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "generateBrokerReportRequest";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.GenerateBrokerReportRequest generate_broker_report_request = 1;
         */
        generateBrokerReportRequest: GenerateBrokerReportRequest;
    } | {
        oneofKind: "getBrokerReportRequest";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.GetBrokerReportRequest get_broker_report_request = 2;
         */
        getBrokerReportRequest: GetBrokerReportRequest;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.BrokerReportResponse
 */
export interface BrokerReportResponse {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "generateBrokerReportResponse";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.GenerateBrokerReportResponse generate_broker_report_response = 1;
         */
        generateBrokerReportResponse: GenerateBrokerReportResponse;
    } | {
        oneofKind: "getBrokerReportResponse";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.GetBrokerReportResponse get_broker_report_response = 2;
         */
        getBrokerReportResponse: GetBrokerReportResponse;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GenerateBrokerReportRequest
 */
export interface GenerateBrokerReportRequest {
    /**
     * @generated from protobuf field: string account_id = 1;
     */
    accountId: string; // Идентификатор счёта клиента.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp from = 2;
     */
    from?: Timestamp; // Начало периода в часовом поясе UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp to = 3;
     */
    to?: Timestamp; // Окончание периода в часовом поясе UTC.
}
/**
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GenerateBrokerReportResponse
 */
export interface GenerateBrokerReportResponse {
    /**
     * @generated from protobuf field: string task_id = 1;
     */
    taskId: string; // Идентификатор задачи формирования брокерского отчёта.
}
/**
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetBrokerReportRequest
 */
export interface GetBrokerReportRequest {
    /**
     * @generated from protobuf field: string task_id = 1;
     */
    taskId: string; // Идентификатор задачи формирования брокерского отчёта.
    /**
     * @generated from protobuf field: int32 page = 2;
     */
    page: number; // Номер страницы отчета (начинается с 1), значение по умолчанию: 0.
}
/**
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetBrokerReportResponse
 */
export interface GetBrokerReportResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.BrokerReport broker_report = 1;
     */
    brokerReport: BrokerReport[];
    /**
     * @generated from protobuf field: int32 itemsCount = 2;
     */
    itemsCount: number; // Количество записей в отчете.
    /**
     * @generated from protobuf field: int32 pagesCount = 3;
     */
    pagesCount: number; // Количество страниц с данными отчета (начинается с 0).
    /**
     * @generated from protobuf field: int32 page = 4;
     */
    page: number; // Текущая страница (начинается с 0).
}
/**
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.BrokerReport
 */
export interface BrokerReport {
    /**
     * @generated from protobuf field: string trade_id = 1;
     */
    tradeId: string; // Номер сделки.
    /**
     * @generated from protobuf field: string order_id = 2;
     */
    orderId: string; // Номер поручения.
    /**
     * @generated from protobuf field: string figi = 3;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: string execute_sign = 4;
     */
    executeSign: string; // Признак исполнения.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp trade_datetime = 5;
     */
    tradeDatetime?: Timestamp; // Дата и время заключения в часовом поясе UTC.
    /**
     * @generated from protobuf field: string exchange = 6;
     */
    exchange: string; // Торговая площадка.
    /**
     * @generated from protobuf field: string class_code = 7;
     */
    classCode: string; // Режим торгов.
    /**
     * @generated from protobuf field: string direction = 8;
     */
    direction: string; // Вид сделки.
    /**
     * @generated from protobuf field: string name = 9;
     */
    name: string; // Сокращённое наименование актива.
    /**
     * @generated from protobuf field: string ticker = 10;
     */
    ticker: string; // Код актива.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue price = 11;
     */
    price?: MoneyValue; // Цена за единицу.
    /**
     * @generated from protobuf field: int64 quantity = 12;
     */
    quantity: bigint; // Количество.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue order_amount = 13;
     */
    orderAmount?: MoneyValue; // Сумма (без НКД).
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation aci_value = 14;
     */
    aciValue?: Quotation; // НКД.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue total_order_amount = 15;
     */
    totalOrderAmount?: MoneyValue; // Сумма сделки.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue broker_commission = 16;
     */
    brokerCommission?: MoneyValue; // Комиссия брокера.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue exchange_commission = 17;
     */
    exchangeCommission?: MoneyValue; // Комиссия биржи.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue exchange_clearing_commission = 18;
     */
    exchangeClearingCommission?: MoneyValue; // Комиссия клир. центра.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation repo_rate = 19;
     */
    repoRate?: Quotation; // Ставка РЕПО (%).
    /**
     * @generated from protobuf field: string party = 20;
     */
    party: string; // Контрагент/Брокер.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp clear_value_date = 21;
     */
    clearValueDate?: Timestamp; // Дата расчётов в часовом поясе UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp sec_value_date = 22;
     */
    secValueDate?: Timestamp; // Дата поставки в часовом поясе UTC.
    /**
     * @generated from protobuf field: string broker_status = 23;
     */
    brokerStatus: string; // Статус брокера.
    /**
     * @generated from protobuf field: string separate_agreement_type = 24;
     */
    separateAgreementType: string; // Тип дог.
    /**
     * @generated from protobuf field: string separate_agreement_number = 25;
     */
    separateAgreementNumber: string; // Номер дог.
    /**
     * @generated from protobuf field: string separate_agreement_date = 26;
     */
    separateAgreementDate: string; // Дата дог.
    /**
     * @generated from protobuf field: string delivery_type = 27;
     */
    deliveryType: string; // Тип расчёта по сделке.
}
/**
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetDividendsForeignIssuerRequest
 */
export interface GetDividendsForeignIssuerRequest {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "generateDivForeignIssuerReport";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.GenerateDividendsForeignIssuerReportRequest generate_div_foreign_issuer_report = 1;
         */
        generateDivForeignIssuerReport: GenerateDividendsForeignIssuerReportRequest; // Объект запроса формирования отчёта.
    } | {
        oneofKind: "getDivForeignIssuerReport";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.GetDividendsForeignIssuerReportRequest get_div_foreign_issuer_report = 2;
         */
        getDivForeignIssuerReport: GetDividendsForeignIssuerReportRequest; // Объект запроса сформированного отчёта.
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetDividendsForeignIssuerResponse
 */
export interface GetDividendsForeignIssuerResponse {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "generateDivForeignIssuerReportResponse";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.GenerateDividendsForeignIssuerReportResponse generate_div_foreign_issuer_report_response = 1;
         */
        generateDivForeignIssuerReportResponse: GenerateDividendsForeignIssuerReportResponse; // Объект результата задачи запуска формирования отчёта.
    } | {
        oneofKind: "divForeignIssuerReport";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.GetDividendsForeignIssuerReportResponse div_foreign_issuer_report = 2;
         */
        divForeignIssuerReport: GetDividendsForeignIssuerReportResponse; // Отчёт "Справка о доходах за пределами РФ".
    } | {
        oneofKind: undefined;
    };
}
/**
 * Объект запроса формирования отчёта "Справка о доходах за пределами РФ".
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GenerateDividendsForeignIssuerReportRequest
 */
export interface GenerateDividendsForeignIssuerReportRequest {
    /**
     * @generated from protobuf field: string account_id = 1;
     */
    accountId: string; // Идентификатор счёта клиента.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp from = 2;
     */
    from?: Timestamp; // Начало периода (по UTC).
    /**
     * @generated from protobuf field: google.protobuf.Timestamp to = 3;
     */
    to?: Timestamp; // Окончание периода (по UTC).
}
/**
 * Объект запроса сформированного отчёта "Справка о доходах за пределами РФ".
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetDividendsForeignIssuerReportRequest
 */
export interface GetDividendsForeignIssuerReportRequest {
    /**
     * @generated from protobuf field: string task_id = 1;
     */
    taskId: string; // Идентификатор задачи формирования отчёта.
    /**
     * @generated from protobuf field: int32 page = 2;
     */
    page: number; // Номер страницы отчета (начинается с 0), значение по умолчанию: 0.
}
/**
 * Объект результата задачи запуска формирования отчёта "Справка о доходах за пределами РФ".
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GenerateDividendsForeignIssuerReportResponse
 */
export interface GenerateDividendsForeignIssuerReportResponse {
    /**
     * @generated from protobuf field: string task_id = 1;
     */
    taskId: string; // Идентификатор задачи формирования отчёта.
}
/**
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetDividendsForeignIssuerReportResponse
 */
export interface GetDividendsForeignIssuerReportResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.DividendsForeignIssuerReport dividends_foreign_issuer_report = 1;
     */
    dividendsForeignIssuerReport: DividendsForeignIssuerReport[];
    /**
     * @generated from protobuf field: int32 itemsCount = 2;
     */
    itemsCount: number; // Количество записей в отчете.
    /**
     * @generated from protobuf field: int32 pagesCount = 3;
     */
    pagesCount: number; // Количество страниц с данными отчета (начинается с 0).
    /**
     * @generated from protobuf field: int32 page = 4;
     */
    page: number; // Текущая страница (начинается с 0).
}
/**
 * Отчёт "Справка о доходах за пределами РФ".
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.DividendsForeignIssuerReport
 */
export interface DividendsForeignIssuerReport {
    /**
     * @generated from protobuf field: google.protobuf.Timestamp record_date = 1;
     */
    recordDate?: Timestamp; // Дата фиксации реестра.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp payment_date = 2;
     */
    paymentDate?: Timestamp; // Дата выплаты.
    /**
     * @generated from protobuf field: string security_name = 3;
     */
    securityName: string; // Наименование ценной бумаги.
    /**
     * @generated from protobuf field: string isin = 4;
     */
    isin: string; // ISIN-идентификатор ценной бумаги.
    /**
     * @generated from protobuf field: string issuer_country = 5;
     */
    issuerCountry: string; // Страна эмитента. Для депозитарных расписок указывается страна эмитента базового актива.
    /**
     * @generated from protobuf field: int64 quantity = 6;
     */
    quantity: bigint; // Количество ценных бумаг.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dividend = 7;
     */
    dividend?: Quotation; // Выплаты на одну бумагу
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation external_commission = 8;
     */
    externalCommission?: Quotation; // Комиссия внешних платёжных агентов.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dividend_gross = 9;
     */
    dividendGross?: Quotation; // Сумма до удержания налога.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation tax = 10;
     */
    tax?: Quotation; // Сумма налога, удержанного агентом.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dividend_amount = 11;
     */
    dividendAmount?: Quotation; // Итоговая сумма выплаты.
    /**
     * @generated from protobuf field: string currency = 12;
     */
    currency: string; // Валюта.
}
/**
 * Запрос установки stream-соединения.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.PortfolioStreamRequest
 */
export interface PortfolioStreamRequest {
    /**
     * @generated from protobuf field: repeated string accounts = 1;
     */
    accounts: string[]; // Массив идентификаторов счётов пользователя
}
/**
 * Информация по позициям и доходностям портфелей.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.PortfolioStreamResponse
 */
export interface PortfolioStreamResponse {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "subscriptions";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.PortfolioSubscriptionResult subscriptions = 1;
         */
        subscriptions: PortfolioSubscriptionResult; // Объект результата подписки.
    } | {
        oneofKind: "portfolio";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.PortfolioResponse portfolio = 2;
         */
        portfolio: PortfolioResponse; // Объект стриминга портфеля.
    } | {
        oneofKind: "ping";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Ping ping = 3;
         */
        ping: Ping; // Проверка активности стрима.
    } | {
        oneofKind: undefined;
    };
}
/**
 * Объект результата подписки.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.PortfolioSubscriptionResult
 */
export interface PortfolioSubscriptionResult {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.AccountSubscriptionStatus accounts = 1;
     */
    accounts: AccountSubscriptionStatus[]; // Массив счетов клиента.
}
/**
 * Счет клиента.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.AccountSubscriptionStatus
 */
export interface AccountSubscriptionStatus {
    /**
     * @generated from protobuf field: string account_id = 1;
     */
    accountId: string; // Идентификатор счёта
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.PortfolioSubscriptionStatus subscription_status = 6;
     */
    subscriptionStatus: PortfolioSubscriptionStatus; // Результат подписки.
}
/**
 * Запрос списка операций по счёту с пагинацией.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetOperationsByCursorRequest
 */
export interface GetOperationsByCursorRequest {
    /**
     * @generated from protobuf field: string account_id = 1;
     */
    accountId: string; // Идентификатор счёта клиента. Обязательный параметр для данного метода, остальные параметры опциональны.
    /**
     * @generated from protobuf field: string instrument_id = 2;
     */
    instrumentId: string; // Идентификатор инструмента (Figi инструмента или uid инструмента)
    /**
     * @generated from protobuf field: google.protobuf.Timestamp from = 6;
     */
    from?: Timestamp; // Начало периода (по UTC).
    /**
     * @generated from protobuf field: google.protobuf.Timestamp to = 7;
     */
    to?: Timestamp; // Окончание периода (по UTC).
    /**
     * @generated from protobuf field: string cursor = 11;
     */
    cursor: string; // Идентификатор элемента, с которого начать формировать ответ.
    /**
     * @generated from protobuf field: int32 limit = 12;
     */
    limit: number; // Лимит количества операций. По умолчанию устанавливается значение **100**, максимальное значение 1000.
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.OperationType operation_types = 13;
     */
    operationTypes: OperationType[]; // Тип операции. Принимает значение из списка OperationType.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.OperationState state = 14;
     */
    state: OperationState; // Статус запрашиваемых операций, возможные значения указаны в OperationState.
    /**
     * @generated from protobuf field: bool without_commissions = 15;
     */
    withoutCommissions: boolean; // Флаг возвращать ли комиссии, по умолчанию false
    /**
     * @generated from protobuf field: bool without_trades = 16;
     */
    withoutTrades: boolean; // Флаг получения ответа без массива сделок.
    /**
     * @generated from protobuf field: bool without_overnights = 17;
     */
    withoutOvernights: boolean; // Флаг не показывать overnight операций.
}
/**
 * Список операций по счёту с пагинацией.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetOperationsByCursorResponse
 */
export interface GetOperationsByCursorResponse {
    /**
     * @generated from protobuf field: bool has_next = 1;
     */
    hasNext: boolean; // Признак, есть ли следующий элемент.
    /**
     * @generated from protobuf field: string next_cursor = 2;
     */
    nextCursor: string; // Следующий курсор.
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.OperationItem items = 6;
     */
    items: OperationItem[]; // Список операций.
}
/**
 * Данные об операции.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.OperationItem
 */
export interface OperationItem {
    /**
     * @generated from protobuf field: string cursor = 1;
     */
    cursor: string; // Курсор.
    /**
     * @generated from protobuf field: string broker_account_id = 6;
     */
    brokerAccountId: string; // Номер счета клиента.
    /**
     * @generated from protobuf field: string id = 16;
     */
    id: string; // Идентификатор операции, может меняться с течением времени.
    /**
     * @generated from protobuf field: string parent_operation_id = 17;
     */
    parentOperationId: string; // Идентификатор родительской операции, может измениться, если изменился id родительской операции.
    /**
     * @generated from protobuf field: string name = 18;
     */
    name: string; // Название операции.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp date = 21;
     */
    date?: Timestamp; // Дата поручения.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.OperationType type = 22;
     */
    type: OperationType; // Тип операции.
    /**
     * @generated from protobuf field: string description = 23;
     */
    description: string; // Описание операции.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.OperationState state = 24;
     */
    state: OperationState; // Статус поручения.
    /**
     * @generated from protobuf field: string instrument_uid = 31;
     */
    instrumentUid: string; // Уникальный идентификатор инструмента.
    /**
     * @generated from protobuf field: string figi = 32;
     */
    figi: string; // Figi.
    /**
     * @generated from protobuf field: string instrument_type = 33;
     */
    instrumentType: string; // Тип инструмента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.InstrumentType instrument_kind = 34;
     */
    instrumentKind: InstrumentType; // Тип инструмента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue payment = 41;
     */
    payment?: MoneyValue; // Сумма операции.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue price = 42;
     */
    price?: MoneyValue; // Цена операции за 1 инструмент.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue commission = 43;
     */
    commission?: MoneyValue; // Комиссия.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue yield = 44;
     */
    yield?: MoneyValue; // Доходность.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation yield_relative = 45;
     */
    yieldRelative?: Quotation; // Относительная доходность.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue accrued_int = 46;
     */
    accruedInt?: MoneyValue; // Накопленный купонный доход.
    /**
     * @generated from protobuf field: int64 quantity = 51;
     */
    quantity: bigint; // Количество единиц инструмента.
    /**
     * @generated from protobuf field: int64 quantity_rest = 52;
     */
    quantityRest: bigint; // Неисполненный остаток по сделке.
    /**
     * @generated from protobuf field: int64 quantity_done = 53;
     */
    quantityDone: bigint; // Исполненный остаток.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp cancel_date_time = 56;
     */
    cancelDateTime?: Timestamp; // Дата и время снятия заявки.
    /**
     * @generated from protobuf field: string cancel_reason = 57;
     */
    cancelReason: string; // Причина отмены операции.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.OperationItemTrades trades_info = 61;
     */
    tradesInfo?: OperationItemTrades; // Массив сделок.
    /**
     * @generated from protobuf field: string asset_uid = 64;
     */
    assetUid: string; // Идентификатор актива
}
/**
 * Массив с информацией о сделках.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.OperationItemTrades
 */
export interface OperationItemTrades {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.OperationItemTrade trades = 6;
     */
    trades: OperationItemTrade[];
}
/**
 * Сделка по операции.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.OperationItemTrade
 */
export interface OperationItemTrade {
    /**
     * @generated from protobuf field: string num = 1;
     */
    num: string; // Номер сделки
    /**
     * @generated from protobuf field: google.protobuf.Timestamp date = 6;
     */
    date?: Timestamp; // Дата сделки
    /**
     * @generated from protobuf field: int64 quantity = 11;
     */
    quantity: bigint; // Количество в единицах.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue price = 16;
     */
    price?: MoneyValue; // Цена.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue yield = 21;
     */
    yield?: MoneyValue; // Доходность.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation yield_relative = 22;
     */
    yieldRelative?: Quotation; // Относительная доходность.
}
/**
 * Запрос установки stream-соединения позиций.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.PositionsStreamRequest
 */
export interface PositionsStreamRequest {
    /**
     * @generated from protobuf field: repeated string accounts = 1;
     */
    accounts: string[]; // Массив идентификаторов счётов пользователя
}
/**
 * Информация по изменению позиций портфеля.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.PositionsStreamResponse
 */
export interface PositionsStreamResponse {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "subscriptions";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.PositionsSubscriptionResult subscriptions = 1;
         */
        subscriptions: PositionsSubscriptionResult; // Объект результата подписки.
    } | {
        oneofKind: "position";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.PositionData position = 2;
         */
        position: PositionData; // Объект стриминга позиций.
    } | {
        oneofKind: "ping";
        /**
         * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Ping ping = 3;
         */
        ping: Ping; // Проверка активности стрима.
    } | {
        oneofKind: undefined;
    };
}
/**
 * Объект результата подписки.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.PositionsSubscriptionResult
 */
export interface PositionsSubscriptionResult {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.PositionsSubscriptionStatus accounts = 1;
     */
    accounts: PositionsSubscriptionStatus[]; // Массив счетов клиента.
}
/**
 * Счет клиента.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.PositionsSubscriptionStatus
 */
export interface PositionsSubscriptionStatus {
    /**
     * @generated from protobuf field: string account_id = 1;
     */
    accountId: string; // Идентификатор счёта
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.PositionsAccountSubscriptionStatus subscription_status = 6;
     */
    subscriptionStatus: PositionsAccountSubscriptionStatus; // Результат подписки.
}
/**
 * Данные о позиции портфеля.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.PositionData
 */
export interface PositionData {
    /**
     * @generated from protobuf field: string account_id = 1;
     */
    accountId: string; // Идентификатор счёта.
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.PositionsMoney money = 2;
     */
    money: PositionsMoney[]; // Массив валютных позиций портфеля.
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.PositionsSecurities securities = 3;
     */
    securities: PositionsSecurities[]; // Список ценно-бумажных позиций портфеля.
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.PositionsFutures futures = 4;
     */
    futures: PositionsFutures[]; // Список фьючерсов портфеля.
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.PositionsOptions options = 5;
     */
    options: PositionsOptions[]; // Список опционов портфеля.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp date = 6;
     */
    date?: Timestamp; // Дата и время операции в формате UTC.
}
/**
 * Валютная позиция портфеля.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.PositionsMoney
 */
export interface PositionsMoney {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue available_value = 1;
     */
    availableValue?: MoneyValue; // Доступное количество валютный позиций.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue blocked_value = 2;
     */
    blockedValue?: MoneyValue; // Заблокированное количество валютный позиций.
}
/**
 * Статус запрашиваемых операций.
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.OperationState
 */
export enum OperationState {
    /**
     * Статус операции не определён
     *
     * @generated from protobuf enum value: OPERATION_STATE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Исполнена.
     *
     * @generated from protobuf enum value: OPERATION_STATE_EXECUTED = 1;
     */
    EXECUTED = 1,
    /**
     * Отменена.
     *
     * @generated from protobuf enum value: OPERATION_STATE_CANCELED = 2;
     */
    CANCELED = 2,
    /**
     * Исполняется.
     *
     * @generated from protobuf enum value: OPERATION_STATE_PROGRESS = 3;
     */
    PROGRESS = 3
}
/**
 * Тип операции.
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.OperationType
 */
export enum OperationType {
    /**
     * Тип операции не определён.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Пополнение брокерского счёта.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_INPUT = 1;
     */
    INPUT = 1,
    /**
     * Удержание НДФЛ по купонам.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_BOND_TAX = 2;
     */
    BOND_TAX = 2,
    /**
     * Вывод ЦБ.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_OUTPUT_SECURITIES = 3;
     */
    OUTPUT_SECURITIES = 3,
    /**
     * Доход по сделке РЕПО овернайт.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_OVERNIGHT = 4;
     */
    OVERNIGHT = 4,
    /**
     * Удержание налога.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_TAX = 5;
     */
    TAX = 5,
    /**
     * Полное погашение облигаций.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_BOND_REPAYMENT_FULL = 6;
     */
    BOND_REPAYMENT_FULL = 6,
    /**
     * Продажа ЦБ с карты.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_SELL_CARD = 7;
     */
    SELL_CARD = 7,
    /**
     * Удержание налога по дивидендам.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_DIVIDEND_TAX = 8;
     */
    DIVIDEND_TAX = 8,
    /**
     * Вывод денежных средств.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_OUTPUT = 9;
     */
    OUTPUT = 9,
    /**
     * Частичное погашение облигаций.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_BOND_REPAYMENT = 10;
     */
    BOND_REPAYMENT = 10,
    /**
     * Корректировка налога.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_TAX_CORRECTION = 11;
     */
    TAX_CORRECTION = 11,
    /**
     * Удержание комиссии за обслуживание брокерского счёта.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_SERVICE_FEE = 12;
     */
    SERVICE_FEE = 12,
    /**
     * Удержание налога за материальную выгоду.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_BENEFIT_TAX = 13;
     */
    BENEFIT_TAX = 13,
    /**
     * Удержание комиссии за непокрытую позицию.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_MARGIN_FEE = 14;
     */
    MARGIN_FEE = 14,
    /**
     * Покупка ЦБ.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_BUY = 15;
     */
    BUY = 15,
    /**
     * Покупка ЦБ с карты.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_BUY_CARD = 16;
     */
    BUY_CARD = 16,
    /**
     * Перевод ценных бумаг из другого депозитария.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_INPUT_SECURITIES = 17;
     */
    INPUT_SECURITIES = 17,
    /**
     * Продажа в результате Margin-call.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_SELL_MARGIN = 18;
     */
    SELL_MARGIN = 18,
    /**
     * Удержание комиссии за операцию.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_BROKER_FEE = 19;
     */
    BROKER_FEE = 19,
    /**
     * Покупка в результате Margin-call.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_BUY_MARGIN = 20;
     */
    BUY_MARGIN = 20,
    /**
     * Выплата дивидендов.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_DIVIDEND = 21;
     */
    DIVIDEND = 21,
    /**
     * Продажа ЦБ.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_SELL = 22;
     */
    SELL = 22,
    /**
     * Выплата купонов.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_COUPON = 23;
     */
    COUPON = 23,
    /**
     * Удержание комиссии SuccessFee.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_SUCCESS_FEE = 24;
     */
    SUCCESS_FEE = 24,
    /**
     * Передача дивидендного дохода.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_DIVIDEND_TRANSFER = 25;
     */
    DIVIDEND_TRANSFER = 25,
    /**
     * Зачисление вариационной маржи.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_ACCRUING_VARMARGIN = 26;
     */
    ACCRUING_VARMARGIN = 26,
    /**
     * Списание вариационной маржи.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_WRITING_OFF_VARMARGIN = 27;
     */
    WRITING_OFF_VARMARGIN = 27,
    /**
     * Покупка в рамках экспирации фьючерсного контракта.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_DELIVERY_BUY = 28;
     */
    DELIVERY_BUY = 28,
    /**
     * Продажа в рамках экспирации фьючерсного контракта.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_DELIVERY_SELL = 29;
     */
    DELIVERY_SELL = 29,
    /**
     * Комиссия за управление по счёту автоследования.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_TRACK_MFEE = 30;
     */
    TRACK_MFEE = 30,
    /**
     * Комиссия за результат по счёту автоследования.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_TRACK_PFEE = 31;
     */
    TRACK_PFEE = 31,
    /**
     * Удержание налога по ставке 15%.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_TAX_PROGRESSIVE = 32;
     */
    TAX_PROGRESSIVE = 32,
    /**
     * Удержание налога по купонам по ставке 15%.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_BOND_TAX_PROGRESSIVE = 33;
     */
    BOND_TAX_PROGRESSIVE = 33,
    /**
     * Удержание налога по дивидендам по ставке 15%.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_DIVIDEND_TAX_PROGRESSIVE = 34;
     */
    DIVIDEND_TAX_PROGRESSIVE = 34,
    /**
     * Удержание налога за материальную выгоду по ставке 15%.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_BENEFIT_TAX_PROGRESSIVE = 35;
     */
    BENEFIT_TAX_PROGRESSIVE = 35,
    /**
     * Корректировка налога по ставке 15%.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_TAX_CORRECTION_PROGRESSIVE = 36;
     */
    TAX_CORRECTION_PROGRESSIVE = 36,
    /**
     * Удержание налога за возмещение по сделкам РЕПО по ставке 15%.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_TAX_REPO_PROGRESSIVE = 37;
     */
    TAX_REPO_PROGRESSIVE = 37,
    /**
     * Удержание налога за возмещение по сделкам РЕПО.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_TAX_REPO = 38;
     */
    TAX_REPO = 38,
    /**
     * Удержание налога по сделкам РЕПО.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_TAX_REPO_HOLD = 39;
     */
    TAX_REPO_HOLD = 39,
    /**
     * Возврат налога по сделкам РЕПО.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_TAX_REPO_REFUND = 40;
     */
    TAX_REPO_REFUND = 40,
    /**
     * Удержание налога по сделкам РЕПО по ставке 15%.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_TAX_REPO_HOLD_PROGRESSIVE = 41;
     */
    TAX_REPO_HOLD_PROGRESSIVE = 41,
    /**
     * Возврат налога по сделкам РЕПО по ставке 15%.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_TAX_REPO_REFUND_PROGRESSIVE = 42;
     */
    TAX_REPO_REFUND_PROGRESSIVE = 42,
    /**
     * Выплата дивидендов на карту.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_DIV_EXT = 43;
     */
    DIV_EXT = 43,
    /**
     * Корректировка налога по купонам.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_TAX_CORRECTION_COUPON = 44;
     */
    TAX_CORRECTION_COUPON = 44,
    /**
     * Комиссия за валютный остаток.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_CASH_FEE = 45;
     */
    CASH_FEE = 45,
    /**
     * Комиссия за вывод валюты с брокерского счета.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_OUT_FEE = 46;
     */
    OUT_FEE = 46,
    /**
     * Гербовый сбор.
     *
     * @generated from protobuf enum value: OPERATION_TYPE_OUT_STAMP_DUTY = 47;
     */
    OUT_STAMP_DUTY = 47,
    /**
     * 	SWIFT-перевод
     *
     * @generated from protobuf enum value: OPERATION_TYPE_OUTPUT_SWIFT = 50;
     */
    OUTPUT_SWIFT = 50,
    /**
     * 	SWIFT-перевод
     *
     * @generated from protobuf enum value: OPERATION_TYPE_INPUT_SWIFT = 51;
     */
    INPUT_SWIFT = 51,
    /**
     *  Перевод на карту
     *
     * @generated from protobuf enum value: OPERATION_TYPE_OUTPUT_ACQUIRING = 53;
     */
    OUTPUT_ACQUIRING = 53,
    /**
     * 	Перевод с карты
     *
     * @generated from protobuf enum value: OPERATION_TYPE_INPUT_ACQUIRING = 54;
     */
    INPUT_ACQUIRING = 54,
    /**
     * 	Комиссия за вывод средств
     *
     * @generated from protobuf enum value: OPERATION_TYPE_OUTPUT_PENALTY = 55;
     */
    OUTPUT_PENALTY = 55,
    /**
     * 	Списание оплаты за сервис Советов
     *
     * @generated from protobuf enum value: OPERATION_TYPE_ADVICE_FEE = 56;
     */
    ADVICE_FEE = 56,
    /**
     *  Перевод ценных бумаг с ИИС на Брокерский счет
     *
     * @generated from protobuf enum value: OPERATION_TYPE_TRANS_IIS_BS = 57;
     */
    TRANS_IIS_BS = 57,
    /**
     *  Перевод ценных бумаг с одного брокерского счета на другой
     *
     * @generated from protobuf enum value: OPERATION_TYPE_TRANS_BS_BS = 58;
     */
    TRANS_BS_BS = 58,
    /**
     *  Вывод денежных средств со счета
     *
     * @generated from protobuf enum value: OPERATION_TYPE_OUT_MULTI = 59;
     */
    OUT_MULTI = 59,
    /**
     *  Пополнение денежных средств со счета
     *
     * @generated from protobuf enum value: OPERATION_TYPE_INP_MULTI = 60;
     */
    INP_MULTI = 60,
    /**
     *  Размещение биржевого овернайта
     *
     * @generated from protobuf enum value: OPERATION_TYPE_OVER_PLACEMENT = 61;
     */
    OVER_PLACEMENT = 61,
    /**
     *  Списание комиссии
     *
     * @generated from protobuf enum value: OPERATION_TYPE_OVER_COM = 62;
     */
    OVER_COM = 62,
    /**
     *  Доход от оверанайта
     *
     * @generated from protobuf enum value: OPERATION_TYPE_OVER_INCOME = 63;
     */
    OVER_INCOME = 63,
    /**
     * Экспирация
     *
     * @generated from protobuf enum value: OPERATION_TYPE_OPTION_EXPIRATION = 64;
     */
    OPTION_EXPIRATION = 64
}
/**
 * Результат подписки.
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.PortfolioSubscriptionStatus
 */
export enum PortfolioSubscriptionStatus {
    /**
     * Тип не определён.
     *
     * @generated from protobuf enum value: PORTFOLIO_SUBSCRIPTION_STATUS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Успешно.
     *
     * @generated from protobuf enum value: PORTFOLIO_SUBSCRIPTION_STATUS_SUCCESS = 1;
     */
    SUCCESS = 1,
    /**
     * Счёт не найден или недостаточно прав.
     *
     * @generated from protobuf enum value: PORTFOLIO_SUBSCRIPTION_STATUS_ACCOUNT_NOT_FOUND = 2;
     */
    ACCOUNT_NOT_FOUND = 2,
    /**
     * Произошла ошибка.
     *
     * @generated from protobuf enum value: PORTFOLIO_SUBSCRIPTION_STATUS_INTERNAL_ERROR = 3;
     */
    INTERNAL_ERROR = 3
}
/**
 * Тип инструмента.
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.InstrumentType
 */
export enum InstrumentType {
    /**
     * @generated from protobuf enum value: INSTRUMENT_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Облигация.
     *
     * @generated from protobuf enum value: INSTRUMENT_TYPE_BOND = 1;
     */
    BOND = 1,
    /**
     * Акция.
     *
     * @generated from protobuf enum value: INSTRUMENT_TYPE_SHARE = 2;
     */
    SHARE = 2,
    /**
     * Валюта.
     *
     * @generated from protobuf enum value: INSTRUMENT_TYPE_CURRENCY = 3;
     */
    CURRENCY = 3,
    /**
     * Exchange-traded fund. Фонд.
     *
     * @generated from protobuf enum value: INSTRUMENT_TYPE_ETF = 4;
     */
    ETF = 4,
    /**
     * Фьючерс.
     *
     * @generated from protobuf enum value: INSTRUMENT_TYPE_FUTURES = 5;
     */
    FUTURES = 5,
    /**
     * Структурная нота.
     *
     * @generated from protobuf enum value: INSTRUMENT_TYPE_SP = 6;
     */
    SP = 6,
    /**
     * Опцион.
     *
     * @generated from protobuf enum value: INSTRUMENT_TYPE_OPTION = 7;
     */
    OPTION = 7
}
/**
 * Результат подписки.
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.PositionsAccountSubscriptionStatus
 */
export enum PositionsAccountSubscriptionStatus {
    /**
     * Тип не определён.
     *
     * @generated from protobuf enum value: POSITIONS_SUBSCRIPTION_STATUS_UNSPECIFIED = 0;
     */
    POSITIONS_SUBSCRIPTION_STATUS_UNSPECIFIED = 0,
    /**
     * Успешно.
     *
     * @generated from protobuf enum value: POSITIONS_SUBSCRIPTION_STATUS_SUCCESS = 1;
     */
    POSITIONS_SUBSCRIPTION_STATUS_SUCCESS = 1,
    /**
     * Счёт не найден или недостаточно прав.
     *
     * @generated from protobuf enum value: POSITIONS_SUBSCRIPTION_STATUS_ACCOUNT_NOT_FOUND = 2;
     */
    POSITIONS_SUBSCRIPTION_STATUS_ACCOUNT_NOT_FOUND = 2,
    /**
     * Произошла ошибка.
     *
     * @generated from protobuf enum value: POSITIONS_SUBSCRIPTION_STATUS_INTERNAL_ERROR = 3;
     */
    POSITIONS_SUBSCRIPTION_STATUS_INTERNAL_ERROR = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class OperationsRequest$Type extends MessageType<OperationsRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.OperationsRequest", [
            { no: 1, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "from", kind: "message", T: () => Timestamp },
            { no: 3, name: "to", kind: "message", T: () => Timestamp },
            { no: 4, name: "state", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.OperationState", OperationState, "OPERATION_STATE_"] },
            { no: 5, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OperationsRequest>): OperationsRequest {
        const message = { accountId: "", state: 0, figi: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OperationsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OperationsRequest): OperationsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_id */ 1:
                    message.accountId = reader.string();
                    break;
                case /* google.protobuf.Timestamp from */ 2:
                    message.from = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.from);
                    break;
                case /* google.protobuf.Timestamp to */ 3:
                    message.to = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.to);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.OperationState state */ 4:
                    message.state = reader.int32();
                    break;
                case /* string figi */ 5:
                    message.figi = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OperationsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_id = 1; */
        if (message.accountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountId);
        /* google.protobuf.Timestamp from = 2; */
        if (message.from)
            Timestamp.internalBinaryWrite(message.from, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp to = 3; */
        if (message.to)
            Timestamp.internalBinaryWrite(message.to, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.OperationState state = 4; */
        if (message.state !== 0)
            writer.tag(4, WireType.Varint).int32(message.state);
        /* string figi = 5; */
        if (message.figi !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.figi);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.OperationsRequest
 */
export const OperationsRequest = new OperationsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OperationsResponse$Type extends MessageType<OperationsResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.OperationsResponse", [
            { no: 1, name: "operations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Operation }
        ]);
    }
    create(value?: PartialMessage<OperationsResponse>): OperationsResponse {
        const message = { operations: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OperationsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OperationsResponse): OperationsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.Operation operations */ 1:
                    message.operations.push(Operation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OperationsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.Operation operations = 1; */
        for (let i = 0; i < message.operations.length; i++)
            Operation.internalBinaryWrite(message.operations[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.OperationsResponse
 */
export const OperationsResponse = new OperationsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Operation$Type extends MessageType<Operation> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.Operation", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "parent_operation_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "currency", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "payment", kind: "message", T: () => MoneyValue },
            { no: 5, name: "price", kind: "message", T: () => MoneyValue },
            { no: 6, name: "state", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.OperationState", OperationState, "OPERATION_STATE_"] },
            { no: 7, name: "quantity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "quantity_rest", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "instrument_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "date", kind: "message", T: () => Timestamp },
            { no: 12, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "operation_type", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.OperationType", OperationType, "OPERATION_TYPE_"] },
            { no: 14, name: "trades", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => OperationTrade },
            { no: 16, name: "asset_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Operation>): Operation {
        const message = { id: "", parentOperationId: "", currency: "", state: 0, quantity: 0n, quantityRest: 0n, figi: "", instrumentType: "", type: "", operationType: 0, trades: [], assetUid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Operation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Operation): Operation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string parent_operation_id */ 2:
                    message.parentOperationId = reader.string();
                    break;
                case /* string currency */ 3:
                    message.currency = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue payment */ 4:
                    message.payment = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.payment);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue price */ 5:
                    message.price = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.price);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.OperationState state */ 6:
                    message.state = reader.int32();
                    break;
                case /* int64 quantity */ 7:
                    message.quantity = reader.int64().toBigInt();
                    break;
                case /* int64 quantity_rest */ 8:
                    message.quantityRest = reader.int64().toBigInt();
                    break;
                case /* string figi */ 9:
                    message.figi = reader.string();
                    break;
                case /* string instrument_type */ 10:
                    message.instrumentType = reader.string();
                    break;
                case /* google.protobuf.Timestamp date */ 11:
                    message.date = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.date);
                    break;
                case /* string type */ 12:
                    message.type = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.OperationType operation_type */ 13:
                    message.operationType = reader.int32();
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.OperationTrade trades */ 14:
                    message.trades.push(OperationTrade.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string asset_uid */ 16:
                    message.assetUid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Operation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string parent_operation_id = 2; */
        if (message.parentOperationId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.parentOperationId);
        /* string currency = 3; */
        if (message.currency !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.currency);
        /* tinkoff.public.invest.api.contract.v1.MoneyValue payment = 4; */
        if (message.payment)
            MoneyValue.internalBinaryWrite(message.payment, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue price = 5; */
        if (message.price)
            MoneyValue.internalBinaryWrite(message.price, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.OperationState state = 6; */
        if (message.state !== 0)
            writer.tag(6, WireType.Varint).int32(message.state);
        /* int64 quantity = 7; */
        if (message.quantity !== 0n)
            writer.tag(7, WireType.Varint).int64(message.quantity);
        /* int64 quantity_rest = 8; */
        if (message.quantityRest !== 0n)
            writer.tag(8, WireType.Varint).int64(message.quantityRest);
        /* string figi = 9; */
        if (message.figi !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.figi);
        /* string instrument_type = 10; */
        if (message.instrumentType !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.instrumentType);
        /* google.protobuf.Timestamp date = 11; */
        if (message.date)
            Timestamp.internalBinaryWrite(message.date, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* string type = 12; */
        if (message.type !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.type);
        /* tinkoff.public.invest.api.contract.v1.OperationType operation_type = 13; */
        if (message.operationType !== 0)
            writer.tag(13, WireType.Varint).int32(message.operationType);
        /* repeated tinkoff.public.invest.api.contract.v1.OperationTrade trades = 14; */
        for (let i = 0; i < message.trades.length; i++)
            OperationTrade.internalBinaryWrite(message.trades[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* string asset_uid = 16; */
        if (message.assetUid !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.assetUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.Operation
 */
export const Operation = new Operation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OperationTrade$Type extends MessageType<OperationTrade> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.OperationTrade", [
            { no: 1, name: "trade_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "date_time", kind: "message", T: () => Timestamp },
            { no: 3, name: "quantity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "price", kind: "message", T: () => MoneyValue }
        ]);
    }
    create(value?: PartialMessage<OperationTrade>): OperationTrade {
        const message = { tradeId: "", quantity: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OperationTrade>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OperationTrade): OperationTrade {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string trade_id */ 1:
                    message.tradeId = reader.string();
                    break;
                case /* google.protobuf.Timestamp date_time */ 2:
                    message.dateTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.dateTime);
                    break;
                case /* int64 quantity */ 3:
                    message.quantity = reader.int64().toBigInt();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue price */ 4:
                    message.price = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.price);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OperationTrade, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string trade_id = 1; */
        if (message.tradeId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tradeId);
        /* google.protobuf.Timestamp date_time = 2; */
        if (message.dateTime)
            Timestamp.internalBinaryWrite(message.dateTime, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int64 quantity = 3; */
        if (message.quantity !== 0n)
            writer.tag(3, WireType.Varint).int64(message.quantity);
        /* tinkoff.public.invest.api.contract.v1.MoneyValue price = 4; */
        if (message.price)
            MoneyValue.internalBinaryWrite(message.price, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.OperationTrade
 */
export const OperationTrade = new OperationTrade$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PortfolioRequest$Type extends MessageType<PortfolioRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.PortfolioRequest", [
            { no: 1, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "currency", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.PortfolioRequest.CurrencyRequest", PortfolioRequest_CurrencyRequest] }
        ]);
    }
    create(value?: PartialMessage<PortfolioRequest>): PortfolioRequest {
        const message = { accountId: "", currency: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PortfolioRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PortfolioRequest): PortfolioRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_id */ 1:
                    message.accountId = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.PortfolioRequest.CurrencyRequest currency */ 2:
                    message.currency = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PortfolioRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_id = 1; */
        if (message.accountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountId);
        /* tinkoff.public.invest.api.contract.v1.PortfolioRequest.CurrencyRequest currency = 2; */
        if (message.currency !== 0)
            writer.tag(2, WireType.Varint).int32(message.currency);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.PortfolioRequest
 */
export const PortfolioRequest = new PortfolioRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PortfolioResponse$Type extends MessageType<PortfolioResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.PortfolioResponse", [
            { no: 1, name: "total_amount_shares", kind: "message", T: () => MoneyValue },
            { no: 2, name: "total_amount_bonds", kind: "message", T: () => MoneyValue },
            { no: 3, name: "total_amount_etf", kind: "message", T: () => MoneyValue },
            { no: 4, name: "total_amount_currencies", kind: "message", T: () => MoneyValue },
            { no: 5, name: "total_amount_futures", kind: "message", T: () => MoneyValue },
            { no: 6, name: "expected_yield", kind: "message", T: () => Quotation },
            { no: 7, name: "positions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PortfolioPosition },
            { no: 8, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "total_amount_options", kind: "message", T: () => MoneyValue },
            { no: 10, name: "total_amount_sp", kind: "message", T: () => MoneyValue },
            { no: 11, name: "total_amount_portfolio", kind: "message", T: () => MoneyValue },
            { no: 12, name: "virtual_positions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => VirtualPortfolioPosition }
        ]);
    }
    create(value?: PartialMessage<PortfolioResponse>): PortfolioResponse {
        const message = { positions: [], accountId: "", virtualPositions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PortfolioResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PortfolioResponse): PortfolioResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_shares */ 1:
                    message.totalAmountShares = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.totalAmountShares);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_bonds */ 2:
                    message.totalAmountBonds = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.totalAmountBonds);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_etf */ 3:
                    message.totalAmountEtf = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.totalAmountEtf);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_currencies */ 4:
                    message.totalAmountCurrencies = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.totalAmountCurrencies);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_futures */ 5:
                    message.totalAmountFutures = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.totalAmountFutures);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation expected_yield */ 6:
                    message.expectedYield = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.expectedYield);
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.PortfolioPosition positions */ 7:
                    message.positions.push(PortfolioPosition.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string account_id */ 8:
                    message.accountId = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_options */ 9:
                    message.totalAmountOptions = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.totalAmountOptions);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_sp */ 10:
                    message.totalAmountSp = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.totalAmountSp);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_portfolio */ 11:
                    message.totalAmountPortfolio = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.totalAmountPortfolio);
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.VirtualPortfolioPosition virtual_positions */ 12:
                    message.virtualPositions.push(VirtualPortfolioPosition.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PortfolioResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_shares = 1; */
        if (message.totalAmountShares)
            MoneyValue.internalBinaryWrite(message.totalAmountShares, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_bonds = 2; */
        if (message.totalAmountBonds)
            MoneyValue.internalBinaryWrite(message.totalAmountBonds, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_etf = 3; */
        if (message.totalAmountEtf)
            MoneyValue.internalBinaryWrite(message.totalAmountEtf, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_currencies = 4; */
        if (message.totalAmountCurrencies)
            MoneyValue.internalBinaryWrite(message.totalAmountCurrencies, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_futures = 5; */
        if (message.totalAmountFutures)
            MoneyValue.internalBinaryWrite(message.totalAmountFutures, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation expected_yield = 6; */
        if (message.expectedYield)
            Quotation.internalBinaryWrite(message.expectedYield, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated tinkoff.public.invest.api.contract.v1.PortfolioPosition positions = 7; */
        for (let i = 0; i < message.positions.length; i++)
            PortfolioPosition.internalBinaryWrite(message.positions[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string account_id = 8; */
        if (message.accountId !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.accountId);
        /* tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_options = 9; */
        if (message.totalAmountOptions)
            MoneyValue.internalBinaryWrite(message.totalAmountOptions, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_sp = 10; */
        if (message.totalAmountSp)
            MoneyValue.internalBinaryWrite(message.totalAmountSp, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_portfolio = 11; */
        if (message.totalAmountPortfolio)
            MoneyValue.internalBinaryWrite(message.totalAmountPortfolio, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* repeated tinkoff.public.invest.api.contract.v1.VirtualPortfolioPosition virtual_positions = 12; */
        for (let i = 0; i < message.virtualPositions.length; i++)
            VirtualPortfolioPosition.internalBinaryWrite(message.virtualPositions[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.PortfolioResponse
 */
export const PortfolioResponse = new PortfolioResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionsRequest$Type extends MessageType<PositionsRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.PositionsRequest", [
            { no: 1, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PositionsRequest>): PositionsRequest {
        const message = { accountId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PositionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionsRequest): PositionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_id */ 1:
                    message.accountId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_id = 1; */
        if (message.accountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.PositionsRequest
 */
export const PositionsRequest = new PositionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionsResponse$Type extends MessageType<PositionsResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.PositionsResponse", [
            { no: 1, name: "money", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MoneyValue },
            { no: 2, name: "blocked", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MoneyValue },
            { no: 3, name: "securities", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PositionsSecurities },
            { no: 4, name: "limits_loading_in_progress", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "futures", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PositionsFutures },
            { no: 6, name: "options", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PositionsOptions }
        ]);
    }
    create(value?: PartialMessage<PositionsResponse>): PositionsResponse {
        const message = { money: [], blocked: [], securities: [], limitsLoadingInProgress: false, futures: [], options: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PositionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionsResponse): PositionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.MoneyValue money */ 1:
                    message.money.push(MoneyValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.MoneyValue blocked */ 2:
                    message.blocked.push(MoneyValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.PositionsSecurities securities */ 3:
                    message.securities.push(PositionsSecurities.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool limits_loading_in_progress */ 4:
                    message.limitsLoadingInProgress = reader.bool();
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.PositionsFutures futures */ 5:
                    message.futures.push(PositionsFutures.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.PositionsOptions options */ 6:
                    message.options.push(PositionsOptions.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.MoneyValue money = 1; */
        for (let i = 0; i < message.money.length; i++)
            MoneyValue.internalBinaryWrite(message.money[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated tinkoff.public.invest.api.contract.v1.MoneyValue blocked = 2; */
        for (let i = 0; i < message.blocked.length; i++)
            MoneyValue.internalBinaryWrite(message.blocked[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated tinkoff.public.invest.api.contract.v1.PositionsSecurities securities = 3; */
        for (let i = 0; i < message.securities.length; i++)
            PositionsSecurities.internalBinaryWrite(message.securities[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool limits_loading_in_progress = 4; */
        if (message.limitsLoadingInProgress !== false)
            writer.tag(4, WireType.Varint).bool(message.limitsLoadingInProgress);
        /* repeated tinkoff.public.invest.api.contract.v1.PositionsFutures futures = 5; */
        for (let i = 0; i < message.futures.length; i++)
            PositionsFutures.internalBinaryWrite(message.futures[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated tinkoff.public.invest.api.contract.v1.PositionsOptions options = 6; */
        for (let i = 0; i < message.options.length; i++)
            PositionsOptions.internalBinaryWrite(message.options[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.PositionsResponse
 */
export const PositionsResponse = new PositionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WithdrawLimitsRequest$Type extends MessageType<WithdrawLimitsRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.WithdrawLimitsRequest", [
            { no: 1, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WithdrawLimitsRequest>): WithdrawLimitsRequest {
        const message = { accountId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WithdrawLimitsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WithdrawLimitsRequest): WithdrawLimitsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_id */ 1:
                    message.accountId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WithdrawLimitsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_id = 1; */
        if (message.accountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.WithdrawLimitsRequest
 */
export const WithdrawLimitsRequest = new WithdrawLimitsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WithdrawLimitsResponse$Type extends MessageType<WithdrawLimitsResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.WithdrawLimitsResponse", [
            { no: 1, name: "money", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MoneyValue },
            { no: 2, name: "blocked", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MoneyValue },
            { no: 3, name: "blocked_guarantee", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MoneyValue }
        ]);
    }
    create(value?: PartialMessage<WithdrawLimitsResponse>): WithdrawLimitsResponse {
        const message = { money: [], blocked: [], blockedGuarantee: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WithdrawLimitsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WithdrawLimitsResponse): WithdrawLimitsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.MoneyValue money */ 1:
                    message.money.push(MoneyValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.MoneyValue blocked */ 2:
                    message.blocked.push(MoneyValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.MoneyValue blocked_guarantee */ 3:
                    message.blockedGuarantee.push(MoneyValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WithdrawLimitsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.MoneyValue money = 1; */
        for (let i = 0; i < message.money.length; i++)
            MoneyValue.internalBinaryWrite(message.money[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated tinkoff.public.invest.api.contract.v1.MoneyValue blocked = 2; */
        for (let i = 0; i < message.blocked.length; i++)
            MoneyValue.internalBinaryWrite(message.blocked[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated tinkoff.public.invest.api.contract.v1.MoneyValue blocked_guarantee = 3; */
        for (let i = 0; i < message.blockedGuarantee.length; i++)
            MoneyValue.internalBinaryWrite(message.blockedGuarantee[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.WithdrawLimitsResponse
 */
export const WithdrawLimitsResponse = new WithdrawLimitsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PortfolioPosition$Type extends MessageType<PortfolioPosition> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.PortfolioPosition", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "instrument_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "quantity", kind: "message", T: () => Quotation },
            { no: 4, name: "average_position_price", kind: "message", T: () => MoneyValue },
            { no: 5, name: "expected_yield", kind: "message", T: () => Quotation },
            { no: 6, name: "current_nkd", kind: "message", T: () => MoneyValue },
            { no: 7, name: "average_position_price_pt", kind: "message", T: () => Quotation },
            { no: 8, name: "current_price", kind: "message", T: () => MoneyValue },
            { no: 9, name: "average_position_price_fifo", kind: "message", T: () => MoneyValue },
            { no: 10, name: "quantity_lots", kind: "message", T: () => Quotation },
            { no: 21, name: "blocked", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 24, name: "position_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 25, name: "instrument_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 26, name: "var_margin", kind: "message", T: () => MoneyValue },
            { no: 27, name: "expected_yield_fifo", kind: "message", T: () => Quotation }
        ]);
    }
    create(value?: PartialMessage<PortfolioPosition>): PortfolioPosition {
        const message = { figi: "", instrumentType: "", blocked: false, positionUid: "", instrumentUid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PortfolioPosition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PortfolioPosition): PortfolioPosition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* string instrument_type */ 2:
                    message.instrumentType = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation quantity */ 3:
                    message.quantity = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.quantity);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue average_position_price */ 4:
                    message.averagePositionPrice = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.averagePositionPrice);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation expected_yield */ 5:
                    message.expectedYield = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.expectedYield);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue current_nkd */ 6:
                    message.currentNkd = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.currentNkd);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation average_position_price_pt */ 7:
                    message.averagePositionPricePt = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.averagePositionPricePt);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue current_price */ 8:
                    message.currentPrice = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.currentPrice);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue average_position_price_fifo */ 9:
                    message.averagePositionPriceFifo = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.averagePositionPriceFifo);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation quantity_lots */ 10:
                    message.quantityLots = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.quantityLots);
                    break;
                case /* bool blocked */ 21:
                    message.blocked = reader.bool();
                    break;
                case /* string position_uid */ 24:
                    message.positionUid = reader.string();
                    break;
                case /* string instrument_uid */ 25:
                    message.instrumentUid = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue var_margin */ 26:
                    message.varMargin = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.varMargin);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation expected_yield_fifo */ 27:
                    message.expectedYieldFifo = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.expectedYieldFifo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PortfolioPosition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* string instrument_type = 2; */
        if (message.instrumentType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.instrumentType);
        /* tinkoff.public.invest.api.contract.v1.Quotation quantity = 3; */
        if (message.quantity)
            Quotation.internalBinaryWrite(message.quantity, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue average_position_price = 4; */
        if (message.averagePositionPrice)
            MoneyValue.internalBinaryWrite(message.averagePositionPrice, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation expected_yield = 5; */
        if (message.expectedYield)
            Quotation.internalBinaryWrite(message.expectedYield, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue current_nkd = 6; */
        if (message.currentNkd)
            MoneyValue.internalBinaryWrite(message.currentNkd, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation average_position_price_pt = 7; */
        if (message.averagePositionPricePt)
            Quotation.internalBinaryWrite(message.averagePositionPricePt, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue current_price = 8; */
        if (message.currentPrice)
            MoneyValue.internalBinaryWrite(message.currentPrice, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue average_position_price_fifo = 9; */
        if (message.averagePositionPriceFifo)
            MoneyValue.internalBinaryWrite(message.averagePositionPriceFifo, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation quantity_lots = 10; */
        if (message.quantityLots)
            Quotation.internalBinaryWrite(message.quantityLots, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* bool blocked = 21; */
        if (message.blocked !== false)
            writer.tag(21, WireType.Varint).bool(message.blocked);
        /* string position_uid = 24; */
        if (message.positionUid !== "")
            writer.tag(24, WireType.LengthDelimited).string(message.positionUid);
        /* string instrument_uid = 25; */
        if (message.instrumentUid !== "")
            writer.tag(25, WireType.LengthDelimited).string(message.instrumentUid);
        /* tinkoff.public.invest.api.contract.v1.MoneyValue var_margin = 26; */
        if (message.varMargin)
            MoneyValue.internalBinaryWrite(message.varMargin, writer.tag(26, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation expected_yield_fifo = 27; */
        if (message.expectedYieldFifo)
            Quotation.internalBinaryWrite(message.expectedYieldFifo, writer.tag(27, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.PortfolioPosition
 */
export const PortfolioPosition = new PortfolioPosition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VirtualPortfolioPosition$Type extends MessageType<VirtualPortfolioPosition> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.VirtualPortfolioPosition", [
            { no: 1, name: "position_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "instrument_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "instrument_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "quantity", kind: "message", T: () => Quotation },
            { no: 6, name: "average_position_price", kind: "message", T: () => MoneyValue },
            { no: 7, name: "expected_yield", kind: "message", T: () => Quotation },
            { no: 8, name: "expected_yield_fifo", kind: "message", T: () => Quotation },
            { no: 9, name: "expire_date", kind: "message", T: () => Timestamp },
            { no: 10, name: "current_price", kind: "message", T: () => MoneyValue },
            { no: 11, name: "average_position_price_fifo", kind: "message", T: () => MoneyValue }
        ]);
    }
    create(value?: PartialMessage<VirtualPortfolioPosition>): VirtualPortfolioPosition {
        const message = { positionUid: "", instrumentUid: "", figi: "", instrumentType: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VirtualPortfolioPosition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VirtualPortfolioPosition): VirtualPortfolioPosition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string position_uid */ 1:
                    message.positionUid = reader.string();
                    break;
                case /* string instrument_uid */ 2:
                    message.instrumentUid = reader.string();
                    break;
                case /* string figi */ 3:
                    message.figi = reader.string();
                    break;
                case /* string instrument_type */ 4:
                    message.instrumentType = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation quantity */ 5:
                    message.quantity = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.quantity);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue average_position_price */ 6:
                    message.averagePositionPrice = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.averagePositionPrice);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation expected_yield */ 7:
                    message.expectedYield = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.expectedYield);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation expected_yield_fifo */ 8:
                    message.expectedYieldFifo = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.expectedYieldFifo);
                    break;
                case /* google.protobuf.Timestamp expire_date */ 9:
                    message.expireDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expireDate);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue current_price */ 10:
                    message.currentPrice = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.currentPrice);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue average_position_price_fifo */ 11:
                    message.averagePositionPriceFifo = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.averagePositionPriceFifo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VirtualPortfolioPosition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string position_uid = 1; */
        if (message.positionUid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.positionUid);
        /* string instrument_uid = 2; */
        if (message.instrumentUid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.instrumentUid);
        /* string figi = 3; */
        if (message.figi !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.figi);
        /* string instrument_type = 4; */
        if (message.instrumentType !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.instrumentType);
        /* tinkoff.public.invest.api.contract.v1.Quotation quantity = 5; */
        if (message.quantity)
            Quotation.internalBinaryWrite(message.quantity, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue average_position_price = 6; */
        if (message.averagePositionPrice)
            MoneyValue.internalBinaryWrite(message.averagePositionPrice, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation expected_yield = 7; */
        if (message.expectedYield)
            Quotation.internalBinaryWrite(message.expectedYield, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation expected_yield_fifo = 8; */
        if (message.expectedYieldFifo)
            Quotation.internalBinaryWrite(message.expectedYieldFifo, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp expire_date = 9; */
        if (message.expireDate)
            Timestamp.internalBinaryWrite(message.expireDate, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue current_price = 10; */
        if (message.currentPrice)
            MoneyValue.internalBinaryWrite(message.currentPrice, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue average_position_price_fifo = 11; */
        if (message.averagePositionPriceFifo)
            MoneyValue.internalBinaryWrite(message.averagePositionPriceFifo, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.VirtualPortfolioPosition
 */
export const VirtualPortfolioPosition = new VirtualPortfolioPosition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionsSecurities$Type extends MessageType<PositionsSecurities> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.PositionsSecurities", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "blocked", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "balance", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "position_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "instrument_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "exchange_blocked", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "instrument_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PositionsSecurities>): PositionsSecurities {
        const message = { figi: "", blocked: 0n, balance: 0n, positionUid: "", instrumentUid: "", exchangeBlocked: false, instrumentType: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PositionsSecurities>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionsSecurities): PositionsSecurities {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* int64 blocked */ 2:
                    message.blocked = reader.int64().toBigInt();
                    break;
                case /* int64 balance */ 3:
                    message.balance = reader.int64().toBigInt();
                    break;
                case /* string position_uid */ 4:
                    message.positionUid = reader.string();
                    break;
                case /* string instrument_uid */ 5:
                    message.instrumentUid = reader.string();
                    break;
                case /* bool exchange_blocked */ 11:
                    message.exchangeBlocked = reader.bool();
                    break;
                case /* string instrument_type */ 16:
                    message.instrumentType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionsSecurities, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* int64 blocked = 2; */
        if (message.blocked !== 0n)
            writer.tag(2, WireType.Varint).int64(message.blocked);
        /* int64 balance = 3; */
        if (message.balance !== 0n)
            writer.tag(3, WireType.Varint).int64(message.balance);
        /* string position_uid = 4; */
        if (message.positionUid !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.positionUid);
        /* string instrument_uid = 5; */
        if (message.instrumentUid !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.instrumentUid);
        /* bool exchange_blocked = 11; */
        if (message.exchangeBlocked !== false)
            writer.tag(11, WireType.Varint).bool(message.exchangeBlocked);
        /* string instrument_type = 16; */
        if (message.instrumentType !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.instrumentType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.PositionsSecurities
 */
export const PositionsSecurities = new PositionsSecurities$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionsFutures$Type extends MessageType<PositionsFutures> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.PositionsFutures", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "blocked", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "balance", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "position_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "instrument_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PositionsFutures>): PositionsFutures {
        const message = { figi: "", blocked: 0n, balance: 0n, positionUid: "", instrumentUid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PositionsFutures>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionsFutures): PositionsFutures {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* int64 blocked */ 2:
                    message.blocked = reader.int64().toBigInt();
                    break;
                case /* int64 balance */ 3:
                    message.balance = reader.int64().toBigInt();
                    break;
                case /* string position_uid */ 4:
                    message.positionUid = reader.string();
                    break;
                case /* string instrument_uid */ 5:
                    message.instrumentUid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionsFutures, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* int64 blocked = 2; */
        if (message.blocked !== 0n)
            writer.tag(2, WireType.Varint).int64(message.blocked);
        /* int64 balance = 3; */
        if (message.balance !== 0n)
            writer.tag(3, WireType.Varint).int64(message.balance);
        /* string position_uid = 4; */
        if (message.positionUid !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.positionUid);
        /* string instrument_uid = 5; */
        if (message.instrumentUid !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.instrumentUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.PositionsFutures
 */
export const PositionsFutures = new PositionsFutures$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionsOptions$Type extends MessageType<PositionsOptions> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.PositionsOptions", [
            { no: 1, name: "position_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "instrument_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "blocked", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 21, name: "balance", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PositionsOptions>): PositionsOptions {
        const message = { positionUid: "", instrumentUid: "", blocked: 0n, balance: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PositionsOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionsOptions): PositionsOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string position_uid */ 1:
                    message.positionUid = reader.string();
                    break;
                case /* string instrument_uid */ 2:
                    message.instrumentUid = reader.string();
                    break;
                case /* int64 blocked */ 11:
                    message.blocked = reader.int64().toBigInt();
                    break;
                case /* int64 balance */ 21:
                    message.balance = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionsOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string position_uid = 1; */
        if (message.positionUid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.positionUid);
        /* string instrument_uid = 2; */
        if (message.instrumentUid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.instrumentUid);
        /* int64 blocked = 11; */
        if (message.blocked !== 0n)
            writer.tag(11, WireType.Varint).int64(message.blocked);
        /* int64 balance = 21; */
        if (message.balance !== 0n)
            writer.tag(21, WireType.Varint).int64(message.balance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.PositionsOptions
 */
export const PositionsOptions = new PositionsOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BrokerReportRequest$Type extends MessageType<BrokerReportRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.BrokerReportRequest", [
            { no: 1, name: "generate_broker_report_request", kind: "message", oneof: "payload", T: () => GenerateBrokerReportRequest },
            { no: 2, name: "get_broker_report_request", kind: "message", oneof: "payload", T: () => GetBrokerReportRequest }
        ]);
    }
    create(value?: PartialMessage<BrokerReportRequest>): BrokerReportRequest {
        const message = { payload: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BrokerReportRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BrokerReportRequest): BrokerReportRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.GenerateBrokerReportRequest generate_broker_report_request */ 1:
                    message.payload = {
                        oneofKind: "generateBrokerReportRequest",
                        generateBrokerReportRequest: GenerateBrokerReportRequest.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).generateBrokerReportRequest)
                    };
                    break;
                case /* tinkoff.public.invest.api.contract.v1.GetBrokerReportRequest get_broker_report_request */ 2:
                    message.payload = {
                        oneofKind: "getBrokerReportRequest",
                        getBrokerReportRequest: GetBrokerReportRequest.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).getBrokerReportRequest)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BrokerReportRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.GenerateBrokerReportRequest generate_broker_report_request = 1; */
        if (message.payload.oneofKind === "generateBrokerReportRequest")
            GenerateBrokerReportRequest.internalBinaryWrite(message.payload.generateBrokerReportRequest, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.GetBrokerReportRequest get_broker_report_request = 2; */
        if (message.payload.oneofKind === "getBrokerReportRequest")
            GetBrokerReportRequest.internalBinaryWrite(message.payload.getBrokerReportRequest, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.BrokerReportRequest
 */
export const BrokerReportRequest = new BrokerReportRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BrokerReportResponse$Type extends MessageType<BrokerReportResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.BrokerReportResponse", [
            { no: 1, name: "generate_broker_report_response", kind: "message", oneof: "payload", T: () => GenerateBrokerReportResponse },
            { no: 2, name: "get_broker_report_response", kind: "message", oneof: "payload", T: () => GetBrokerReportResponse }
        ]);
    }
    create(value?: PartialMessage<BrokerReportResponse>): BrokerReportResponse {
        const message = { payload: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BrokerReportResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BrokerReportResponse): BrokerReportResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.GenerateBrokerReportResponse generate_broker_report_response */ 1:
                    message.payload = {
                        oneofKind: "generateBrokerReportResponse",
                        generateBrokerReportResponse: GenerateBrokerReportResponse.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).generateBrokerReportResponse)
                    };
                    break;
                case /* tinkoff.public.invest.api.contract.v1.GetBrokerReportResponse get_broker_report_response */ 2:
                    message.payload = {
                        oneofKind: "getBrokerReportResponse",
                        getBrokerReportResponse: GetBrokerReportResponse.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).getBrokerReportResponse)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BrokerReportResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.GenerateBrokerReportResponse generate_broker_report_response = 1; */
        if (message.payload.oneofKind === "generateBrokerReportResponse")
            GenerateBrokerReportResponse.internalBinaryWrite(message.payload.generateBrokerReportResponse, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.GetBrokerReportResponse get_broker_report_response = 2; */
        if (message.payload.oneofKind === "getBrokerReportResponse")
            GetBrokerReportResponse.internalBinaryWrite(message.payload.getBrokerReportResponse, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.BrokerReportResponse
 */
export const BrokerReportResponse = new BrokerReportResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GenerateBrokerReportRequest$Type extends MessageType<GenerateBrokerReportRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GenerateBrokerReportRequest", [
            { no: 1, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "from", kind: "message", T: () => Timestamp },
            { no: 3, name: "to", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<GenerateBrokerReportRequest>): GenerateBrokerReportRequest {
        const message = { accountId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GenerateBrokerReportRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenerateBrokerReportRequest): GenerateBrokerReportRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_id */ 1:
                    message.accountId = reader.string();
                    break;
                case /* google.protobuf.Timestamp from */ 2:
                    message.from = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.from);
                    break;
                case /* google.protobuf.Timestamp to */ 3:
                    message.to = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.to);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GenerateBrokerReportRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_id = 1; */
        if (message.accountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountId);
        /* google.protobuf.Timestamp from = 2; */
        if (message.from)
            Timestamp.internalBinaryWrite(message.from, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp to = 3; */
        if (message.to)
            Timestamp.internalBinaryWrite(message.to, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GenerateBrokerReportRequest
 */
export const GenerateBrokerReportRequest = new GenerateBrokerReportRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GenerateBrokerReportResponse$Type extends MessageType<GenerateBrokerReportResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GenerateBrokerReportResponse", [
            { no: 1, name: "task_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GenerateBrokerReportResponse>): GenerateBrokerReportResponse {
        const message = { taskId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GenerateBrokerReportResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenerateBrokerReportResponse): GenerateBrokerReportResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string task_id */ 1:
                    message.taskId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GenerateBrokerReportResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string task_id = 1; */
        if (message.taskId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.taskId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GenerateBrokerReportResponse
 */
export const GenerateBrokerReportResponse = new GenerateBrokerReportResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBrokerReportRequest$Type extends MessageType<GetBrokerReportRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetBrokerReportRequest", [
            { no: 1, name: "task_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "page", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetBrokerReportRequest>): GetBrokerReportRequest {
        const message = { taskId: "", page: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetBrokerReportRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBrokerReportRequest): GetBrokerReportRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string task_id */ 1:
                    message.taskId = reader.string();
                    break;
                case /* int32 page */ 2:
                    message.page = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBrokerReportRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string task_id = 1; */
        if (message.taskId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.taskId);
        /* int32 page = 2; */
        if (message.page !== 0)
            writer.tag(2, WireType.Varint).int32(message.page);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetBrokerReportRequest
 */
export const GetBrokerReportRequest = new GetBrokerReportRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBrokerReportResponse$Type extends MessageType<GetBrokerReportResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetBrokerReportResponse", [
            { no: 1, name: "broker_report", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BrokerReport },
            { no: 2, name: "itemsCount", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "pagesCount", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "page", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetBrokerReportResponse>): GetBrokerReportResponse {
        const message = { brokerReport: [], itemsCount: 0, pagesCount: 0, page: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetBrokerReportResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBrokerReportResponse): GetBrokerReportResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.BrokerReport broker_report */ 1:
                    message.brokerReport.push(BrokerReport.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 itemsCount */ 2:
                    message.itemsCount = reader.int32();
                    break;
                case /* int32 pagesCount */ 3:
                    message.pagesCount = reader.int32();
                    break;
                case /* int32 page */ 4:
                    message.page = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBrokerReportResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.BrokerReport broker_report = 1; */
        for (let i = 0; i < message.brokerReport.length; i++)
            BrokerReport.internalBinaryWrite(message.brokerReport[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 itemsCount = 2; */
        if (message.itemsCount !== 0)
            writer.tag(2, WireType.Varint).int32(message.itemsCount);
        /* int32 pagesCount = 3; */
        if (message.pagesCount !== 0)
            writer.tag(3, WireType.Varint).int32(message.pagesCount);
        /* int32 page = 4; */
        if (message.page !== 0)
            writer.tag(4, WireType.Varint).int32(message.page);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetBrokerReportResponse
 */
export const GetBrokerReportResponse = new GetBrokerReportResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BrokerReport$Type extends MessageType<BrokerReport> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.BrokerReport", [
            { no: 1, name: "trade_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "execute_sign", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "trade_datetime", kind: "message", T: () => Timestamp },
            { no: 6, name: "exchange", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "class_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "price", kind: "message", T: () => MoneyValue },
            { no: 12, name: "quantity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "order_amount", kind: "message", T: () => MoneyValue },
            { no: 14, name: "aci_value", kind: "message", T: () => Quotation },
            { no: 15, name: "total_order_amount", kind: "message", T: () => MoneyValue },
            { no: 16, name: "broker_commission", kind: "message", T: () => MoneyValue },
            { no: 17, name: "exchange_commission", kind: "message", T: () => MoneyValue },
            { no: 18, name: "exchange_clearing_commission", kind: "message", T: () => MoneyValue },
            { no: 19, name: "repo_rate", kind: "message", T: () => Quotation },
            { no: 20, name: "party", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 21, name: "clear_value_date", kind: "message", T: () => Timestamp },
            { no: 22, name: "sec_value_date", kind: "message", T: () => Timestamp },
            { no: 23, name: "broker_status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 24, name: "separate_agreement_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 25, name: "separate_agreement_number", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 26, name: "separate_agreement_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 27, name: "delivery_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BrokerReport>): BrokerReport {
        const message = { tradeId: "", orderId: "", figi: "", executeSign: "", exchange: "", classCode: "", direction: "", name: "", ticker: "", quantity: 0n, party: "", brokerStatus: "", separateAgreementType: "", separateAgreementNumber: "", separateAgreementDate: "", deliveryType: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BrokerReport>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BrokerReport): BrokerReport {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string trade_id */ 1:
                    message.tradeId = reader.string();
                    break;
                case /* string order_id */ 2:
                    message.orderId = reader.string();
                    break;
                case /* string figi */ 3:
                    message.figi = reader.string();
                    break;
                case /* string execute_sign */ 4:
                    message.executeSign = reader.string();
                    break;
                case /* google.protobuf.Timestamp trade_datetime */ 5:
                    message.tradeDatetime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.tradeDatetime);
                    break;
                case /* string exchange */ 6:
                    message.exchange = reader.string();
                    break;
                case /* string class_code */ 7:
                    message.classCode = reader.string();
                    break;
                case /* string direction */ 8:
                    message.direction = reader.string();
                    break;
                case /* string name */ 9:
                    message.name = reader.string();
                    break;
                case /* string ticker */ 10:
                    message.ticker = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue price */ 11:
                    message.price = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.price);
                    break;
                case /* int64 quantity */ 12:
                    message.quantity = reader.int64().toBigInt();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue order_amount */ 13:
                    message.orderAmount = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.orderAmount);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation aci_value */ 14:
                    message.aciValue = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.aciValue);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue total_order_amount */ 15:
                    message.totalOrderAmount = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.totalOrderAmount);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue broker_commission */ 16:
                    message.brokerCommission = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.brokerCommission);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue exchange_commission */ 17:
                    message.exchangeCommission = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.exchangeCommission);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue exchange_clearing_commission */ 18:
                    message.exchangeClearingCommission = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.exchangeClearingCommission);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation repo_rate */ 19:
                    message.repoRate = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.repoRate);
                    break;
                case /* string party */ 20:
                    message.party = reader.string();
                    break;
                case /* google.protobuf.Timestamp clear_value_date */ 21:
                    message.clearValueDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.clearValueDate);
                    break;
                case /* google.protobuf.Timestamp sec_value_date */ 22:
                    message.secValueDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.secValueDate);
                    break;
                case /* string broker_status */ 23:
                    message.brokerStatus = reader.string();
                    break;
                case /* string separate_agreement_type */ 24:
                    message.separateAgreementType = reader.string();
                    break;
                case /* string separate_agreement_number */ 25:
                    message.separateAgreementNumber = reader.string();
                    break;
                case /* string separate_agreement_date */ 26:
                    message.separateAgreementDate = reader.string();
                    break;
                case /* string delivery_type */ 27:
                    message.deliveryType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BrokerReport, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string trade_id = 1; */
        if (message.tradeId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tradeId);
        /* string order_id = 2; */
        if (message.orderId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.orderId);
        /* string figi = 3; */
        if (message.figi !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.figi);
        /* string execute_sign = 4; */
        if (message.executeSign !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.executeSign);
        /* google.protobuf.Timestamp trade_datetime = 5; */
        if (message.tradeDatetime)
            Timestamp.internalBinaryWrite(message.tradeDatetime, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string exchange = 6; */
        if (message.exchange !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.exchange);
        /* string class_code = 7; */
        if (message.classCode !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.classCode);
        /* string direction = 8; */
        if (message.direction !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.direction);
        /* string name = 9; */
        if (message.name !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.name);
        /* string ticker = 10; */
        if (message.ticker !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.ticker);
        /* tinkoff.public.invest.api.contract.v1.MoneyValue price = 11; */
        if (message.price)
            MoneyValue.internalBinaryWrite(message.price, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* int64 quantity = 12; */
        if (message.quantity !== 0n)
            writer.tag(12, WireType.Varint).int64(message.quantity);
        /* tinkoff.public.invest.api.contract.v1.MoneyValue order_amount = 13; */
        if (message.orderAmount)
            MoneyValue.internalBinaryWrite(message.orderAmount, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation aci_value = 14; */
        if (message.aciValue)
            Quotation.internalBinaryWrite(message.aciValue, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue total_order_amount = 15; */
        if (message.totalOrderAmount)
            MoneyValue.internalBinaryWrite(message.totalOrderAmount, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue broker_commission = 16; */
        if (message.brokerCommission)
            MoneyValue.internalBinaryWrite(message.brokerCommission, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue exchange_commission = 17; */
        if (message.exchangeCommission)
            MoneyValue.internalBinaryWrite(message.exchangeCommission, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue exchange_clearing_commission = 18; */
        if (message.exchangeClearingCommission)
            MoneyValue.internalBinaryWrite(message.exchangeClearingCommission, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation repo_rate = 19; */
        if (message.repoRate)
            Quotation.internalBinaryWrite(message.repoRate, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* string party = 20; */
        if (message.party !== "")
            writer.tag(20, WireType.LengthDelimited).string(message.party);
        /* google.protobuf.Timestamp clear_value_date = 21; */
        if (message.clearValueDate)
            Timestamp.internalBinaryWrite(message.clearValueDate, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp sec_value_date = 22; */
        if (message.secValueDate)
            Timestamp.internalBinaryWrite(message.secValueDate, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* string broker_status = 23; */
        if (message.brokerStatus !== "")
            writer.tag(23, WireType.LengthDelimited).string(message.brokerStatus);
        /* string separate_agreement_type = 24; */
        if (message.separateAgreementType !== "")
            writer.tag(24, WireType.LengthDelimited).string(message.separateAgreementType);
        /* string separate_agreement_number = 25; */
        if (message.separateAgreementNumber !== "")
            writer.tag(25, WireType.LengthDelimited).string(message.separateAgreementNumber);
        /* string separate_agreement_date = 26; */
        if (message.separateAgreementDate !== "")
            writer.tag(26, WireType.LengthDelimited).string(message.separateAgreementDate);
        /* string delivery_type = 27; */
        if (message.deliveryType !== "")
            writer.tag(27, WireType.LengthDelimited).string(message.deliveryType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.BrokerReport
 */
export const BrokerReport = new BrokerReport$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDividendsForeignIssuerRequest$Type extends MessageType<GetDividendsForeignIssuerRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetDividendsForeignIssuerRequest", [
            { no: 1, name: "generate_div_foreign_issuer_report", kind: "message", oneof: "payload", T: () => GenerateDividendsForeignIssuerReportRequest },
            { no: 2, name: "get_div_foreign_issuer_report", kind: "message", oneof: "payload", T: () => GetDividendsForeignIssuerReportRequest }
        ]);
    }
    create(value?: PartialMessage<GetDividendsForeignIssuerRequest>): GetDividendsForeignIssuerRequest {
        const message = { payload: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetDividendsForeignIssuerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDividendsForeignIssuerRequest): GetDividendsForeignIssuerRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.GenerateDividendsForeignIssuerReportRequest generate_div_foreign_issuer_report */ 1:
                    message.payload = {
                        oneofKind: "generateDivForeignIssuerReport",
                        generateDivForeignIssuerReport: GenerateDividendsForeignIssuerReportRequest.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).generateDivForeignIssuerReport)
                    };
                    break;
                case /* tinkoff.public.invest.api.contract.v1.GetDividendsForeignIssuerReportRequest get_div_foreign_issuer_report */ 2:
                    message.payload = {
                        oneofKind: "getDivForeignIssuerReport",
                        getDivForeignIssuerReport: GetDividendsForeignIssuerReportRequest.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).getDivForeignIssuerReport)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDividendsForeignIssuerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.GenerateDividendsForeignIssuerReportRequest generate_div_foreign_issuer_report = 1; */
        if (message.payload.oneofKind === "generateDivForeignIssuerReport")
            GenerateDividendsForeignIssuerReportRequest.internalBinaryWrite(message.payload.generateDivForeignIssuerReport, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.GetDividendsForeignIssuerReportRequest get_div_foreign_issuer_report = 2; */
        if (message.payload.oneofKind === "getDivForeignIssuerReport")
            GetDividendsForeignIssuerReportRequest.internalBinaryWrite(message.payload.getDivForeignIssuerReport, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetDividendsForeignIssuerRequest
 */
export const GetDividendsForeignIssuerRequest = new GetDividendsForeignIssuerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDividendsForeignIssuerResponse$Type extends MessageType<GetDividendsForeignIssuerResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetDividendsForeignIssuerResponse", [
            { no: 1, name: "generate_div_foreign_issuer_report_response", kind: "message", oneof: "payload", T: () => GenerateDividendsForeignIssuerReportResponse },
            { no: 2, name: "div_foreign_issuer_report", kind: "message", oneof: "payload", T: () => GetDividendsForeignIssuerReportResponse }
        ]);
    }
    create(value?: PartialMessage<GetDividendsForeignIssuerResponse>): GetDividendsForeignIssuerResponse {
        const message = { payload: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetDividendsForeignIssuerResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDividendsForeignIssuerResponse): GetDividendsForeignIssuerResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.GenerateDividendsForeignIssuerReportResponse generate_div_foreign_issuer_report_response */ 1:
                    message.payload = {
                        oneofKind: "generateDivForeignIssuerReportResponse",
                        generateDivForeignIssuerReportResponse: GenerateDividendsForeignIssuerReportResponse.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).generateDivForeignIssuerReportResponse)
                    };
                    break;
                case /* tinkoff.public.invest.api.contract.v1.GetDividendsForeignIssuerReportResponse div_foreign_issuer_report */ 2:
                    message.payload = {
                        oneofKind: "divForeignIssuerReport",
                        divForeignIssuerReport: GetDividendsForeignIssuerReportResponse.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).divForeignIssuerReport)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDividendsForeignIssuerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.GenerateDividendsForeignIssuerReportResponse generate_div_foreign_issuer_report_response = 1; */
        if (message.payload.oneofKind === "generateDivForeignIssuerReportResponse")
            GenerateDividendsForeignIssuerReportResponse.internalBinaryWrite(message.payload.generateDivForeignIssuerReportResponse, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.GetDividendsForeignIssuerReportResponse div_foreign_issuer_report = 2; */
        if (message.payload.oneofKind === "divForeignIssuerReport")
            GetDividendsForeignIssuerReportResponse.internalBinaryWrite(message.payload.divForeignIssuerReport, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetDividendsForeignIssuerResponse
 */
export const GetDividendsForeignIssuerResponse = new GetDividendsForeignIssuerResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GenerateDividendsForeignIssuerReportRequest$Type extends MessageType<GenerateDividendsForeignIssuerReportRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GenerateDividendsForeignIssuerReportRequest", [
            { no: 1, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "from", kind: "message", T: () => Timestamp },
            { no: 3, name: "to", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<GenerateDividendsForeignIssuerReportRequest>): GenerateDividendsForeignIssuerReportRequest {
        const message = { accountId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GenerateDividendsForeignIssuerReportRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenerateDividendsForeignIssuerReportRequest): GenerateDividendsForeignIssuerReportRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_id */ 1:
                    message.accountId = reader.string();
                    break;
                case /* google.protobuf.Timestamp from */ 2:
                    message.from = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.from);
                    break;
                case /* google.protobuf.Timestamp to */ 3:
                    message.to = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.to);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GenerateDividendsForeignIssuerReportRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_id = 1; */
        if (message.accountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountId);
        /* google.protobuf.Timestamp from = 2; */
        if (message.from)
            Timestamp.internalBinaryWrite(message.from, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp to = 3; */
        if (message.to)
            Timestamp.internalBinaryWrite(message.to, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GenerateDividendsForeignIssuerReportRequest
 */
export const GenerateDividendsForeignIssuerReportRequest = new GenerateDividendsForeignIssuerReportRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDividendsForeignIssuerReportRequest$Type extends MessageType<GetDividendsForeignIssuerReportRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetDividendsForeignIssuerReportRequest", [
            { no: 1, name: "task_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "page", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetDividendsForeignIssuerReportRequest>): GetDividendsForeignIssuerReportRequest {
        const message = { taskId: "", page: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetDividendsForeignIssuerReportRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDividendsForeignIssuerReportRequest): GetDividendsForeignIssuerReportRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string task_id */ 1:
                    message.taskId = reader.string();
                    break;
                case /* int32 page */ 2:
                    message.page = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDividendsForeignIssuerReportRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string task_id = 1; */
        if (message.taskId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.taskId);
        /* int32 page = 2; */
        if (message.page !== 0)
            writer.tag(2, WireType.Varint).int32(message.page);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetDividendsForeignIssuerReportRequest
 */
export const GetDividendsForeignIssuerReportRequest = new GetDividendsForeignIssuerReportRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GenerateDividendsForeignIssuerReportResponse$Type extends MessageType<GenerateDividendsForeignIssuerReportResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GenerateDividendsForeignIssuerReportResponse", [
            { no: 1, name: "task_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GenerateDividendsForeignIssuerReportResponse>): GenerateDividendsForeignIssuerReportResponse {
        const message = { taskId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GenerateDividendsForeignIssuerReportResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenerateDividendsForeignIssuerReportResponse): GenerateDividendsForeignIssuerReportResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string task_id */ 1:
                    message.taskId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GenerateDividendsForeignIssuerReportResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string task_id = 1; */
        if (message.taskId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.taskId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GenerateDividendsForeignIssuerReportResponse
 */
export const GenerateDividendsForeignIssuerReportResponse = new GenerateDividendsForeignIssuerReportResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDividendsForeignIssuerReportResponse$Type extends MessageType<GetDividendsForeignIssuerReportResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetDividendsForeignIssuerReportResponse", [
            { no: 1, name: "dividends_foreign_issuer_report", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DividendsForeignIssuerReport },
            { no: 2, name: "itemsCount", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "pagesCount", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "page", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetDividendsForeignIssuerReportResponse>): GetDividendsForeignIssuerReportResponse {
        const message = { dividendsForeignIssuerReport: [], itemsCount: 0, pagesCount: 0, page: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetDividendsForeignIssuerReportResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDividendsForeignIssuerReportResponse): GetDividendsForeignIssuerReportResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.DividendsForeignIssuerReport dividends_foreign_issuer_report */ 1:
                    message.dividendsForeignIssuerReport.push(DividendsForeignIssuerReport.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 itemsCount */ 2:
                    message.itemsCount = reader.int32();
                    break;
                case /* int32 pagesCount */ 3:
                    message.pagesCount = reader.int32();
                    break;
                case /* int32 page */ 4:
                    message.page = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDividendsForeignIssuerReportResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.DividendsForeignIssuerReport dividends_foreign_issuer_report = 1; */
        for (let i = 0; i < message.dividendsForeignIssuerReport.length; i++)
            DividendsForeignIssuerReport.internalBinaryWrite(message.dividendsForeignIssuerReport[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 itemsCount = 2; */
        if (message.itemsCount !== 0)
            writer.tag(2, WireType.Varint).int32(message.itemsCount);
        /* int32 pagesCount = 3; */
        if (message.pagesCount !== 0)
            writer.tag(3, WireType.Varint).int32(message.pagesCount);
        /* int32 page = 4; */
        if (message.page !== 0)
            writer.tag(4, WireType.Varint).int32(message.page);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetDividendsForeignIssuerReportResponse
 */
export const GetDividendsForeignIssuerReportResponse = new GetDividendsForeignIssuerReportResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DividendsForeignIssuerReport$Type extends MessageType<DividendsForeignIssuerReport> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.DividendsForeignIssuerReport", [
            { no: 1, name: "record_date", kind: "message", T: () => Timestamp },
            { no: 2, name: "payment_date", kind: "message", T: () => Timestamp },
            { no: 3, name: "security_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "isin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "issuer_country", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "quantity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "dividend", kind: "message", T: () => Quotation },
            { no: 8, name: "external_commission", kind: "message", T: () => Quotation },
            { no: 9, name: "dividend_gross", kind: "message", T: () => Quotation },
            { no: 10, name: "tax", kind: "message", T: () => Quotation },
            { no: 11, name: "dividend_amount", kind: "message", T: () => Quotation },
            { no: 12, name: "currency", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DividendsForeignIssuerReport>): DividendsForeignIssuerReport {
        const message = { securityName: "", isin: "", issuerCountry: "", quantity: 0n, currency: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DividendsForeignIssuerReport>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DividendsForeignIssuerReport): DividendsForeignIssuerReport {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp record_date */ 1:
                    message.recordDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.recordDate);
                    break;
                case /* google.protobuf.Timestamp payment_date */ 2:
                    message.paymentDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.paymentDate);
                    break;
                case /* string security_name */ 3:
                    message.securityName = reader.string();
                    break;
                case /* string isin */ 4:
                    message.isin = reader.string();
                    break;
                case /* string issuer_country */ 5:
                    message.issuerCountry = reader.string();
                    break;
                case /* int64 quantity */ 6:
                    message.quantity = reader.int64().toBigInt();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dividend */ 7:
                    message.dividend = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dividend);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation external_commission */ 8:
                    message.externalCommission = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.externalCommission);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dividend_gross */ 9:
                    message.dividendGross = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dividendGross);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation tax */ 10:
                    message.tax = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.tax);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation dividend_amount */ 11:
                    message.dividendAmount = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dividendAmount);
                    break;
                case /* string currency */ 12:
                    message.currency = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DividendsForeignIssuerReport, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp record_date = 1; */
        if (message.recordDate)
            Timestamp.internalBinaryWrite(message.recordDate, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp payment_date = 2; */
        if (message.paymentDate)
            Timestamp.internalBinaryWrite(message.paymentDate, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string security_name = 3; */
        if (message.securityName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.securityName);
        /* string isin = 4; */
        if (message.isin !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.isin);
        /* string issuer_country = 5; */
        if (message.issuerCountry !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.issuerCountry);
        /* int64 quantity = 6; */
        if (message.quantity !== 0n)
            writer.tag(6, WireType.Varint).int64(message.quantity);
        /* tinkoff.public.invest.api.contract.v1.Quotation dividend = 7; */
        if (message.dividend)
            Quotation.internalBinaryWrite(message.dividend, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation external_commission = 8; */
        if (message.externalCommission)
            Quotation.internalBinaryWrite(message.externalCommission, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation dividend_gross = 9; */
        if (message.dividendGross)
            Quotation.internalBinaryWrite(message.dividendGross, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation tax = 10; */
        if (message.tax)
            Quotation.internalBinaryWrite(message.tax, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation dividend_amount = 11; */
        if (message.dividendAmount)
            Quotation.internalBinaryWrite(message.dividendAmount, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* string currency = 12; */
        if (message.currency !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.currency);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.DividendsForeignIssuerReport
 */
export const DividendsForeignIssuerReport = new DividendsForeignIssuerReport$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PortfolioStreamRequest$Type extends MessageType<PortfolioStreamRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.PortfolioStreamRequest", [
            { no: 1, name: "accounts", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PortfolioStreamRequest>): PortfolioStreamRequest {
        const message = { accounts: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PortfolioStreamRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PortfolioStreamRequest): PortfolioStreamRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string accounts */ 1:
                    message.accounts.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PortfolioStreamRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string accounts = 1; */
        for (let i = 0; i < message.accounts.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.accounts[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.PortfolioStreamRequest
 */
export const PortfolioStreamRequest = new PortfolioStreamRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PortfolioStreamResponse$Type extends MessageType<PortfolioStreamResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.PortfolioStreamResponse", [
            { no: 1, name: "subscriptions", kind: "message", oneof: "payload", T: () => PortfolioSubscriptionResult },
            { no: 2, name: "portfolio", kind: "message", oneof: "payload", T: () => PortfolioResponse },
            { no: 3, name: "ping", kind: "message", oneof: "payload", T: () => Ping }
        ]);
    }
    create(value?: PartialMessage<PortfolioStreamResponse>): PortfolioStreamResponse {
        const message = { payload: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PortfolioStreamResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PortfolioStreamResponse): PortfolioStreamResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.PortfolioSubscriptionResult subscriptions */ 1:
                    message.payload = {
                        oneofKind: "subscriptions",
                        subscriptions: PortfolioSubscriptionResult.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).subscriptions)
                    };
                    break;
                case /* tinkoff.public.invest.api.contract.v1.PortfolioResponse portfolio */ 2:
                    message.payload = {
                        oneofKind: "portfolio",
                        portfolio: PortfolioResponse.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).portfolio)
                    };
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Ping ping */ 3:
                    message.payload = {
                        oneofKind: "ping",
                        ping: Ping.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).ping)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PortfolioStreamResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.PortfolioSubscriptionResult subscriptions = 1; */
        if (message.payload.oneofKind === "subscriptions")
            PortfolioSubscriptionResult.internalBinaryWrite(message.payload.subscriptions, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.PortfolioResponse portfolio = 2; */
        if (message.payload.oneofKind === "portfolio")
            PortfolioResponse.internalBinaryWrite(message.payload.portfolio, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Ping ping = 3; */
        if (message.payload.oneofKind === "ping")
            Ping.internalBinaryWrite(message.payload.ping, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.PortfolioStreamResponse
 */
export const PortfolioStreamResponse = new PortfolioStreamResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PortfolioSubscriptionResult$Type extends MessageType<PortfolioSubscriptionResult> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.PortfolioSubscriptionResult", [
            { no: 1, name: "accounts", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AccountSubscriptionStatus }
        ]);
    }
    create(value?: PartialMessage<PortfolioSubscriptionResult>): PortfolioSubscriptionResult {
        const message = { accounts: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PortfolioSubscriptionResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PortfolioSubscriptionResult): PortfolioSubscriptionResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.AccountSubscriptionStatus accounts */ 1:
                    message.accounts.push(AccountSubscriptionStatus.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PortfolioSubscriptionResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.AccountSubscriptionStatus accounts = 1; */
        for (let i = 0; i < message.accounts.length; i++)
            AccountSubscriptionStatus.internalBinaryWrite(message.accounts[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.PortfolioSubscriptionResult
 */
export const PortfolioSubscriptionResult = new PortfolioSubscriptionResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountSubscriptionStatus$Type extends MessageType<AccountSubscriptionStatus> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.AccountSubscriptionStatus", [
            { no: 1, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "subscription_status", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.PortfolioSubscriptionStatus", PortfolioSubscriptionStatus, "PORTFOLIO_SUBSCRIPTION_STATUS_"] }
        ]);
    }
    create(value?: PartialMessage<AccountSubscriptionStatus>): AccountSubscriptionStatus {
        const message = { accountId: "", subscriptionStatus: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountSubscriptionStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountSubscriptionStatus): AccountSubscriptionStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_id */ 1:
                    message.accountId = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.PortfolioSubscriptionStatus subscription_status */ 6:
                    message.subscriptionStatus = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountSubscriptionStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_id = 1; */
        if (message.accountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountId);
        /* tinkoff.public.invest.api.contract.v1.PortfolioSubscriptionStatus subscription_status = 6; */
        if (message.subscriptionStatus !== 0)
            writer.tag(6, WireType.Varint).int32(message.subscriptionStatus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.AccountSubscriptionStatus
 */
export const AccountSubscriptionStatus = new AccountSubscriptionStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetOperationsByCursorRequest$Type extends MessageType<GetOperationsByCursorRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetOperationsByCursorRequest", [
            { no: 1, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "instrument_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "from", kind: "message", T: () => Timestamp },
            { no: 7, name: "to", kind: "message", T: () => Timestamp },
            { no: 11, name: "cursor", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "limit", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "operation_types", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["tinkoff.public.invest.api.contract.v1.OperationType", OperationType, "OPERATION_TYPE_"] },
            { no: 14, name: "state", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.OperationState", OperationState, "OPERATION_STATE_"] },
            { no: 15, name: "without_commissions", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "without_trades", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "without_overnights", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetOperationsByCursorRequest>): GetOperationsByCursorRequest {
        const message = { accountId: "", instrumentId: "", cursor: "", limit: 0, operationTypes: [], state: 0, withoutCommissions: false, withoutTrades: false, withoutOvernights: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetOperationsByCursorRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetOperationsByCursorRequest): GetOperationsByCursorRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_id */ 1:
                    message.accountId = reader.string();
                    break;
                case /* string instrument_id */ 2:
                    message.instrumentId = reader.string();
                    break;
                case /* google.protobuf.Timestamp from */ 6:
                    message.from = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.from);
                    break;
                case /* google.protobuf.Timestamp to */ 7:
                    message.to = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.to);
                    break;
                case /* string cursor */ 11:
                    message.cursor = reader.string();
                    break;
                case /* int32 limit */ 12:
                    message.limit = reader.int32();
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.OperationType operation_types */ 13:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.operationTypes.push(reader.int32());
                    else
                        message.operationTypes.push(reader.int32());
                    break;
                case /* tinkoff.public.invest.api.contract.v1.OperationState state */ 14:
                    message.state = reader.int32();
                    break;
                case /* bool without_commissions */ 15:
                    message.withoutCommissions = reader.bool();
                    break;
                case /* bool without_trades */ 16:
                    message.withoutTrades = reader.bool();
                    break;
                case /* bool without_overnights */ 17:
                    message.withoutOvernights = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetOperationsByCursorRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_id = 1; */
        if (message.accountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountId);
        /* string instrument_id = 2; */
        if (message.instrumentId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.instrumentId);
        /* google.protobuf.Timestamp from = 6; */
        if (message.from)
            Timestamp.internalBinaryWrite(message.from, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp to = 7; */
        if (message.to)
            Timestamp.internalBinaryWrite(message.to, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string cursor = 11; */
        if (message.cursor !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.cursor);
        /* int32 limit = 12; */
        if (message.limit !== 0)
            writer.tag(12, WireType.Varint).int32(message.limit);
        /* repeated tinkoff.public.invest.api.contract.v1.OperationType operation_types = 13; */
        if (message.operationTypes.length) {
            writer.tag(13, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.operationTypes.length; i++)
                writer.int32(message.operationTypes[i]);
            writer.join();
        }
        /* tinkoff.public.invest.api.contract.v1.OperationState state = 14; */
        if (message.state !== 0)
            writer.tag(14, WireType.Varint).int32(message.state);
        /* bool without_commissions = 15; */
        if (message.withoutCommissions !== false)
            writer.tag(15, WireType.Varint).bool(message.withoutCommissions);
        /* bool without_trades = 16; */
        if (message.withoutTrades !== false)
            writer.tag(16, WireType.Varint).bool(message.withoutTrades);
        /* bool without_overnights = 17; */
        if (message.withoutOvernights !== false)
            writer.tag(17, WireType.Varint).bool(message.withoutOvernights);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetOperationsByCursorRequest
 */
export const GetOperationsByCursorRequest = new GetOperationsByCursorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetOperationsByCursorResponse$Type extends MessageType<GetOperationsByCursorResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.GetOperationsByCursorResponse", [
            { no: 1, name: "has_next", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "next_cursor", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => OperationItem }
        ]);
    }
    create(value?: PartialMessage<GetOperationsByCursorResponse>): GetOperationsByCursorResponse {
        const message = { hasNext: false, nextCursor: "", items: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetOperationsByCursorResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetOperationsByCursorResponse): GetOperationsByCursorResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool has_next */ 1:
                    message.hasNext = reader.bool();
                    break;
                case /* string next_cursor */ 2:
                    message.nextCursor = reader.string();
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.OperationItem items */ 6:
                    message.items.push(OperationItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetOperationsByCursorResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool has_next = 1; */
        if (message.hasNext !== false)
            writer.tag(1, WireType.Varint).bool(message.hasNext);
        /* string next_cursor = 2; */
        if (message.nextCursor !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextCursor);
        /* repeated tinkoff.public.invest.api.contract.v1.OperationItem items = 6; */
        for (let i = 0; i < message.items.length; i++)
            OperationItem.internalBinaryWrite(message.items[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetOperationsByCursorResponse
 */
export const GetOperationsByCursorResponse = new GetOperationsByCursorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OperationItem$Type extends MessageType<OperationItem> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.OperationItem", [
            { no: 1, name: "cursor", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "broker_account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "parent_operation_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 21, name: "date", kind: "message", T: () => Timestamp },
            { no: 22, name: "type", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.OperationType", OperationType, "OPERATION_TYPE_"] },
            { no: 23, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 24, name: "state", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.OperationState", OperationState, "OPERATION_STATE_"] },
            { no: 31, name: "instrument_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 32, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 33, name: "instrument_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 34, name: "instrument_kind", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.InstrumentType", InstrumentType, "INSTRUMENT_TYPE_"] },
            { no: 41, name: "payment", kind: "message", T: () => MoneyValue },
            { no: 42, name: "price", kind: "message", T: () => MoneyValue },
            { no: 43, name: "commission", kind: "message", T: () => MoneyValue },
            { no: 44, name: "yield", kind: "message", T: () => MoneyValue },
            { no: 45, name: "yield_relative", kind: "message", T: () => Quotation },
            { no: 46, name: "accrued_int", kind: "message", T: () => MoneyValue },
            { no: 51, name: "quantity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 52, name: "quantity_rest", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 53, name: "quantity_done", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 56, name: "cancel_date_time", kind: "message", T: () => Timestamp },
            { no: 57, name: "cancel_reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 61, name: "trades_info", kind: "message", T: () => OperationItemTrades },
            { no: 64, name: "asset_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OperationItem>): OperationItem {
        const message = { cursor: "", brokerAccountId: "", id: "", parentOperationId: "", name: "", type: 0, description: "", state: 0, instrumentUid: "", figi: "", instrumentType: "", instrumentKind: 0, quantity: 0n, quantityRest: 0n, quantityDone: 0n, cancelReason: "", assetUid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OperationItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OperationItem): OperationItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cursor */ 1:
                    message.cursor = reader.string();
                    break;
                case /* string broker_account_id */ 6:
                    message.brokerAccountId = reader.string();
                    break;
                case /* string id */ 16:
                    message.id = reader.string();
                    break;
                case /* string parent_operation_id */ 17:
                    message.parentOperationId = reader.string();
                    break;
                case /* string name */ 18:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Timestamp date */ 21:
                    message.date = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.date);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.OperationType type */ 22:
                    message.type = reader.int32();
                    break;
                case /* string description */ 23:
                    message.description = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.OperationState state */ 24:
                    message.state = reader.int32();
                    break;
                case /* string instrument_uid */ 31:
                    message.instrumentUid = reader.string();
                    break;
                case /* string figi */ 32:
                    message.figi = reader.string();
                    break;
                case /* string instrument_type */ 33:
                    message.instrumentType = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.InstrumentType instrument_kind */ 34:
                    message.instrumentKind = reader.int32();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue payment */ 41:
                    message.payment = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.payment);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue price */ 42:
                    message.price = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.price);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue commission */ 43:
                    message.commission = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.commission);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue yield */ 44:
                    message.yield = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.yield);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation yield_relative */ 45:
                    message.yieldRelative = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.yieldRelative);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue accrued_int */ 46:
                    message.accruedInt = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.accruedInt);
                    break;
                case /* int64 quantity */ 51:
                    message.quantity = reader.int64().toBigInt();
                    break;
                case /* int64 quantity_rest */ 52:
                    message.quantityRest = reader.int64().toBigInt();
                    break;
                case /* int64 quantity_done */ 53:
                    message.quantityDone = reader.int64().toBigInt();
                    break;
                case /* google.protobuf.Timestamp cancel_date_time */ 56:
                    message.cancelDateTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.cancelDateTime);
                    break;
                case /* string cancel_reason */ 57:
                    message.cancelReason = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.OperationItemTrades trades_info */ 61:
                    message.tradesInfo = OperationItemTrades.internalBinaryRead(reader, reader.uint32(), options, message.tradesInfo);
                    break;
                case /* string asset_uid */ 64:
                    message.assetUid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OperationItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cursor = 1; */
        if (message.cursor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cursor);
        /* string broker_account_id = 6; */
        if (message.brokerAccountId !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.brokerAccountId);
        /* string id = 16; */
        if (message.id !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.id);
        /* string parent_operation_id = 17; */
        if (message.parentOperationId !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.parentOperationId);
        /* string name = 18; */
        if (message.name !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Timestamp date = 21; */
        if (message.date)
            Timestamp.internalBinaryWrite(message.date, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.OperationType type = 22; */
        if (message.type !== 0)
            writer.tag(22, WireType.Varint).int32(message.type);
        /* string description = 23; */
        if (message.description !== "")
            writer.tag(23, WireType.LengthDelimited).string(message.description);
        /* tinkoff.public.invest.api.contract.v1.OperationState state = 24; */
        if (message.state !== 0)
            writer.tag(24, WireType.Varint).int32(message.state);
        /* string instrument_uid = 31; */
        if (message.instrumentUid !== "")
            writer.tag(31, WireType.LengthDelimited).string(message.instrumentUid);
        /* string figi = 32; */
        if (message.figi !== "")
            writer.tag(32, WireType.LengthDelimited).string(message.figi);
        /* string instrument_type = 33; */
        if (message.instrumentType !== "")
            writer.tag(33, WireType.LengthDelimited).string(message.instrumentType);
        /* tinkoff.public.invest.api.contract.v1.InstrumentType instrument_kind = 34; */
        if (message.instrumentKind !== 0)
            writer.tag(34, WireType.Varint).int32(message.instrumentKind);
        /* tinkoff.public.invest.api.contract.v1.MoneyValue payment = 41; */
        if (message.payment)
            MoneyValue.internalBinaryWrite(message.payment, writer.tag(41, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue price = 42; */
        if (message.price)
            MoneyValue.internalBinaryWrite(message.price, writer.tag(42, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue commission = 43; */
        if (message.commission)
            MoneyValue.internalBinaryWrite(message.commission, writer.tag(43, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue yield = 44; */
        if (message.yield)
            MoneyValue.internalBinaryWrite(message.yield, writer.tag(44, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation yield_relative = 45; */
        if (message.yieldRelative)
            Quotation.internalBinaryWrite(message.yieldRelative, writer.tag(45, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue accrued_int = 46; */
        if (message.accruedInt)
            MoneyValue.internalBinaryWrite(message.accruedInt, writer.tag(46, WireType.LengthDelimited).fork(), options).join();
        /* int64 quantity = 51; */
        if (message.quantity !== 0n)
            writer.tag(51, WireType.Varint).int64(message.quantity);
        /* int64 quantity_rest = 52; */
        if (message.quantityRest !== 0n)
            writer.tag(52, WireType.Varint).int64(message.quantityRest);
        /* int64 quantity_done = 53; */
        if (message.quantityDone !== 0n)
            writer.tag(53, WireType.Varint).int64(message.quantityDone);
        /* google.protobuf.Timestamp cancel_date_time = 56; */
        if (message.cancelDateTime)
            Timestamp.internalBinaryWrite(message.cancelDateTime, writer.tag(56, WireType.LengthDelimited).fork(), options).join();
        /* string cancel_reason = 57; */
        if (message.cancelReason !== "")
            writer.tag(57, WireType.LengthDelimited).string(message.cancelReason);
        /* tinkoff.public.invest.api.contract.v1.OperationItemTrades trades_info = 61; */
        if (message.tradesInfo)
            OperationItemTrades.internalBinaryWrite(message.tradesInfo, writer.tag(61, WireType.LengthDelimited).fork(), options).join();
        /* string asset_uid = 64; */
        if (message.assetUid !== "")
            writer.tag(64, WireType.LengthDelimited).string(message.assetUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.OperationItem
 */
export const OperationItem = new OperationItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OperationItemTrades$Type extends MessageType<OperationItemTrades> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.OperationItemTrades", [
            { no: 6, name: "trades", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => OperationItemTrade }
        ]);
    }
    create(value?: PartialMessage<OperationItemTrades>): OperationItemTrades {
        const message = { trades: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OperationItemTrades>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OperationItemTrades): OperationItemTrades {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.OperationItemTrade trades */ 6:
                    message.trades.push(OperationItemTrade.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OperationItemTrades, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.OperationItemTrade trades = 6; */
        for (let i = 0; i < message.trades.length; i++)
            OperationItemTrade.internalBinaryWrite(message.trades[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.OperationItemTrades
 */
export const OperationItemTrades = new OperationItemTrades$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OperationItemTrade$Type extends MessageType<OperationItemTrade> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.OperationItemTrade", [
            { no: 1, name: "num", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "date", kind: "message", T: () => Timestamp },
            { no: 11, name: "quantity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 16, name: "price", kind: "message", T: () => MoneyValue },
            { no: 21, name: "yield", kind: "message", T: () => MoneyValue },
            { no: 22, name: "yield_relative", kind: "message", T: () => Quotation }
        ]);
    }
    create(value?: PartialMessage<OperationItemTrade>): OperationItemTrade {
        const message = { num: "", quantity: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OperationItemTrade>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OperationItemTrade): OperationItemTrade {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string num */ 1:
                    message.num = reader.string();
                    break;
                case /* google.protobuf.Timestamp date */ 6:
                    message.date = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.date);
                    break;
                case /* int64 quantity */ 11:
                    message.quantity = reader.int64().toBigInt();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue price */ 16:
                    message.price = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.price);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue yield */ 21:
                    message.yield = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.yield);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation yield_relative */ 22:
                    message.yieldRelative = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.yieldRelative);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OperationItemTrade, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string num = 1; */
        if (message.num !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.num);
        /* google.protobuf.Timestamp date = 6; */
        if (message.date)
            Timestamp.internalBinaryWrite(message.date, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* int64 quantity = 11; */
        if (message.quantity !== 0n)
            writer.tag(11, WireType.Varint).int64(message.quantity);
        /* tinkoff.public.invest.api.contract.v1.MoneyValue price = 16; */
        if (message.price)
            MoneyValue.internalBinaryWrite(message.price, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue yield = 21; */
        if (message.yield)
            MoneyValue.internalBinaryWrite(message.yield, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation yield_relative = 22; */
        if (message.yieldRelative)
            Quotation.internalBinaryWrite(message.yieldRelative, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.OperationItemTrade
 */
export const OperationItemTrade = new OperationItemTrade$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionsStreamRequest$Type extends MessageType<PositionsStreamRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.PositionsStreamRequest", [
            { no: 1, name: "accounts", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PositionsStreamRequest>): PositionsStreamRequest {
        const message = { accounts: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PositionsStreamRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionsStreamRequest): PositionsStreamRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string accounts */ 1:
                    message.accounts.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionsStreamRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string accounts = 1; */
        for (let i = 0; i < message.accounts.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.accounts[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.PositionsStreamRequest
 */
export const PositionsStreamRequest = new PositionsStreamRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionsStreamResponse$Type extends MessageType<PositionsStreamResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.PositionsStreamResponse", [
            { no: 1, name: "subscriptions", kind: "message", oneof: "payload", T: () => PositionsSubscriptionResult },
            { no: 2, name: "position", kind: "message", oneof: "payload", T: () => PositionData },
            { no: 3, name: "ping", kind: "message", oneof: "payload", T: () => Ping }
        ]);
    }
    create(value?: PartialMessage<PositionsStreamResponse>): PositionsStreamResponse {
        const message = { payload: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PositionsStreamResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionsStreamResponse): PositionsStreamResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.PositionsSubscriptionResult subscriptions */ 1:
                    message.payload = {
                        oneofKind: "subscriptions",
                        subscriptions: PositionsSubscriptionResult.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).subscriptions)
                    };
                    break;
                case /* tinkoff.public.invest.api.contract.v1.PositionData position */ 2:
                    message.payload = {
                        oneofKind: "position",
                        position: PositionData.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).position)
                    };
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Ping ping */ 3:
                    message.payload = {
                        oneofKind: "ping",
                        ping: Ping.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).ping)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionsStreamResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.PositionsSubscriptionResult subscriptions = 1; */
        if (message.payload.oneofKind === "subscriptions")
            PositionsSubscriptionResult.internalBinaryWrite(message.payload.subscriptions, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.PositionData position = 2; */
        if (message.payload.oneofKind === "position")
            PositionData.internalBinaryWrite(message.payload.position, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Ping ping = 3; */
        if (message.payload.oneofKind === "ping")
            Ping.internalBinaryWrite(message.payload.ping, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.PositionsStreamResponse
 */
export const PositionsStreamResponse = new PositionsStreamResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionsSubscriptionResult$Type extends MessageType<PositionsSubscriptionResult> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.PositionsSubscriptionResult", [
            { no: 1, name: "accounts", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PositionsSubscriptionStatus }
        ]);
    }
    create(value?: PartialMessage<PositionsSubscriptionResult>): PositionsSubscriptionResult {
        const message = { accounts: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PositionsSubscriptionResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionsSubscriptionResult): PositionsSubscriptionResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.PositionsSubscriptionStatus accounts */ 1:
                    message.accounts.push(PositionsSubscriptionStatus.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionsSubscriptionResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.PositionsSubscriptionStatus accounts = 1; */
        for (let i = 0; i < message.accounts.length; i++)
            PositionsSubscriptionStatus.internalBinaryWrite(message.accounts[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.PositionsSubscriptionResult
 */
export const PositionsSubscriptionResult = new PositionsSubscriptionResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionsSubscriptionStatus$Type extends MessageType<PositionsSubscriptionStatus> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.PositionsSubscriptionStatus", [
            { no: 1, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "subscription_status", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.PositionsAccountSubscriptionStatus", PositionsAccountSubscriptionStatus] }
        ]);
    }
    create(value?: PartialMessage<PositionsSubscriptionStatus>): PositionsSubscriptionStatus {
        const message = { accountId: "", subscriptionStatus: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PositionsSubscriptionStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionsSubscriptionStatus): PositionsSubscriptionStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_id */ 1:
                    message.accountId = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.PositionsAccountSubscriptionStatus subscription_status */ 6:
                    message.subscriptionStatus = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionsSubscriptionStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_id = 1; */
        if (message.accountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountId);
        /* tinkoff.public.invest.api.contract.v1.PositionsAccountSubscriptionStatus subscription_status = 6; */
        if (message.subscriptionStatus !== 0)
            writer.tag(6, WireType.Varint).int32(message.subscriptionStatus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.PositionsSubscriptionStatus
 */
export const PositionsSubscriptionStatus = new PositionsSubscriptionStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionData$Type extends MessageType<PositionData> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.PositionData", [
            { no: 1, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "money", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PositionsMoney },
            { no: 3, name: "securities", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PositionsSecurities },
            { no: 4, name: "futures", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PositionsFutures },
            { no: 5, name: "options", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PositionsOptions },
            { no: 6, name: "date", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<PositionData>): PositionData {
        const message = { accountId: "", money: [], securities: [], futures: [], options: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PositionData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionData): PositionData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_id */ 1:
                    message.accountId = reader.string();
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.PositionsMoney money */ 2:
                    message.money.push(PositionsMoney.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.PositionsSecurities securities */ 3:
                    message.securities.push(PositionsSecurities.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.PositionsFutures futures */ 4:
                    message.futures.push(PositionsFutures.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.PositionsOptions options */ 5:
                    message.options.push(PositionsOptions.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Timestamp date */ 6:
                    message.date = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.date);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_id = 1; */
        if (message.accountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountId);
        /* repeated tinkoff.public.invest.api.contract.v1.PositionsMoney money = 2; */
        for (let i = 0; i < message.money.length; i++)
            PositionsMoney.internalBinaryWrite(message.money[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated tinkoff.public.invest.api.contract.v1.PositionsSecurities securities = 3; */
        for (let i = 0; i < message.securities.length; i++)
            PositionsSecurities.internalBinaryWrite(message.securities[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated tinkoff.public.invest.api.contract.v1.PositionsFutures futures = 4; */
        for (let i = 0; i < message.futures.length; i++)
            PositionsFutures.internalBinaryWrite(message.futures[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated tinkoff.public.invest.api.contract.v1.PositionsOptions options = 5; */
        for (let i = 0; i < message.options.length; i++)
            PositionsOptions.internalBinaryWrite(message.options[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp date = 6; */
        if (message.date)
            Timestamp.internalBinaryWrite(message.date, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.PositionData
 */
export const PositionData = new PositionData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionsMoney$Type extends MessageType<PositionsMoney> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.PositionsMoney", [
            { no: 1, name: "available_value", kind: "message", T: () => MoneyValue },
            { no: 2, name: "blocked_value", kind: "message", T: () => MoneyValue }
        ]);
    }
    create(value?: PartialMessage<PositionsMoney>): PositionsMoney {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PositionsMoney>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionsMoney): PositionsMoney {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue available_value */ 1:
                    message.availableValue = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.availableValue);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue blocked_value */ 2:
                    message.blockedValue = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.blockedValue);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionsMoney, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.MoneyValue available_value = 1; */
        if (message.availableValue)
            MoneyValue.internalBinaryWrite(message.availableValue, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue blocked_value = 2; */
        if (message.blockedValue)
            MoneyValue.internalBinaryWrite(message.blockedValue, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.PositionsMoney
 */
export const PositionsMoney = new PositionsMoney$Type();
/**
 * @generated ServiceType for protobuf service tinkoff.public.invest.api.contract.v1.OperationsService
 */
export const OperationsService = new ServiceType("tinkoff.public.invest.api.contract.v1.OperationsService", [
    { name: "GetOperations", options: {}, I: OperationsRequest, O: OperationsResponse },
    { name: "GetPortfolio", options: {}, I: PortfolioRequest, O: PortfolioResponse },
    { name: "GetPositions", options: {}, I: PositionsRequest, O: PositionsResponse },
    { name: "GetWithdrawLimits", options: {}, I: WithdrawLimitsRequest, O: WithdrawLimitsResponse },
    { name: "GetBrokerReport", options: {}, I: BrokerReportRequest, O: BrokerReportResponse },
    { name: "GetDividendsForeignIssuer", options: {}, I: GetDividendsForeignIssuerRequest, O: GetDividendsForeignIssuerResponse },
    { name: "GetOperationsByCursor", options: {}, I: GetOperationsByCursorRequest, O: GetOperationsByCursorResponse }
]);
/**
 * @generated ServiceType for protobuf service tinkoff.public.invest.api.contract.v1.OperationsStreamService
 */
export const OperationsStreamService = new ServiceType("tinkoff.public.invest.api.contract.v1.OperationsStreamService", [
    { name: "PortfolioStream", serverStreaming: true, options: {}, I: PortfolioStreamRequest, O: PortfolioStreamResponse },
    { name: "PositionsStream", serverStreaming: true, options: {}, I: PositionsStreamRequest, O: PositionsStreamResponse }
]);
